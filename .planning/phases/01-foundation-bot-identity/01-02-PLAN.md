---
phase: 01-foundation-bot-identity
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - migrations/20260210_001_initial.sql
  - crates/boternity-infra/src/lib.rs
  - crates/boternity-infra/src/sqlite/mod.rs
  - crates/boternity-infra/src/sqlite/pool.rs
  - crates/boternity-infra/src/sqlite/bot.rs
  - crates/boternity-infra/src/sqlite/soul.rs
  - crates/boternity-infra/src/sqlite/secret.rs
  - crates/boternity-infra/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "SQLite database is created with WAL mode and all tables (bots, soul_versions, secrets)"
    - "Split read/write pools work -- reads use multi-connection pool, writes use single-connection pool"
    - "Repository implementations pass basic CRUD operations against a real SQLite database"
    - "Foreign key constraints are enforced (deleting a bot cascades to soul_versions and secrets)"
  artifacts:
    - path: "migrations/20260210_001_initial.sql"
      provides: "Initial database schema with bots, soul_versions, secrets tables"
      contains: "CREATE TABLE bots"
    - path: "crates/boternity-infra/src/sqlite/pool.rs"
      provides: "DatabasePool with split reader/writer connections in WAL mode"
      contains: "pub struct DatabasePool"
    - path: "crates/boternity-infra/src/sqlite/bot.rs"
      provides: "SqliteBotRepository implementing BotRepository trait"
      contains: "impl BotRepository for SqliteBotRepository"
    - path: "crates/boternity-infra/src/sqlite/soul.rs"
      provides: "SqliteSoulRepository implementing SoulRepository trait"
      contains: "impl SoulRepository for SqliteSoulRepository"
    - path: "crates/boternity-infra/src/sqlite/secret.rs"
      provides: "SqliteSecretRepository implementing SecretProvider (vault storage)"
      contains: "impl SecretProvider for SqliteSecretRepository"
  key_links:
    - from: "crates/boternity-infra/src/sqlite/bot.rs"
      to: "crates/boternity-core/src/repository/bot.rs"
      via: "trait implementation"
      pattern: "impl BotRepository for"
    - from: "crates/boternity-infra/src/sqlite/pool.rs"
      to: "migrations/"
      via: "sqlx::migrate!()"
      pattern: "sqlx::migrate!"
    - from: "crates/boternity-infra/src/sqlite/pool.rs"
      to: "SqliteJournalMode::Wal"
      via: "WAL mode configuration"
      pattern: "journal_mode.*Wal"
---

<objective>
Implement the SQLite storage layer with split read/write pools, WAL mode, migrations, and repository trait implementations for bots, soul versions, and secrets.

Purpose: All data persistence in Phase 1 flows through this layer. The repository implementations connect the domain-level traits from boternity-core to real SQLite storage, establishing the infrastructure foundation that CLI and REST API will build on.
Output: Working SQLite database with schema, split read/write pool, and all three repository implementations.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-bot-identity/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation-bot-identity/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQLite migration and database pool with WAL mode</name>
  <files>
    migrations/20260210_001_initial.sql
    crates/boternity-infra/src/sqlite/mod.rs
    crates/boternity-infra/src/sqlite/pool.rs
    crates/boternity-infra/src/lib.rs
  </files>
  <action>
    Create the initial SQL migration file (migrations/20260210_001_initial.sql) with these tables:

    bots table:
    - id TEXT PRIMARY KEY (UUID string)
    - slug TEXT NOT NULL UNIQUE
    - name TEXT NOT NULL
    - description TEXT NOT NULL DEFAULT ''
    - status TEXT NOT NULL DEFAULT 'active' CHECK(status IN ('active', 'disabled', 'archived'))
    - category TEXT NOT NULL DEFAULT 'assistant' CHECK(category IN ('assistant', 'creative', 'research', 'utility'))
    - tags TEXT NOT NULL DEFAULT '[]' (JSON array stored as text)
    - user_id TEXT (nullable, for future multi-user per CONTEXT.md)
    - conversation_count INTEGER NOT NULL DEFAULT 0
    - total_tokens_used INTEGER NOT NULL DEFAULT 0
    - version_count INTEGER NOT NULL DEFAULT 0
    - created_at TEXT NOT NULL (ISO 8601)
    - updated_at TEXT NOT NULL (ISO 8601)
    - last_active_at TEXT (nullable, ISO 8601)
    - INDEX on slug, status, category, created_at

    soul_versions table:
    - id TEXT PRIMARY KEY (UUID string)
    - bot_id TEXT NOT NULL REFERENCES bots(id) ON DELETE CASCADE
    - content TEXT NOT NULL (full SOUL.md content)
    - hash TEXT NOT NULL (SHA-256 hex)
    - version INTEGER NOT NULL
    - message TEXT (optional commit message)
    - created_at TEXT NOT NULL
    - UNIQUE(bot_id, version)
    - INDEX on bot_id, INDEX on (bot_id, version)

    secrets table:
    - id TEXT PRIMARY KEY (UUID string)
    - key TEXT NOT NULL
    - encrypted_value BLOB NOT NULL (AES-256-GCM encrypted)
    - scope TEXT NOT NULL DEFAULT 'global' (either 'global' or bot UUID)
    - provider TEXT NOT NULL DEFAULT 'vault' CHECK(provider IN ('vault', 'keychain', 'environment'))
    - created_at TEXT NOT NULL
    - updated_at TEXT NOT NULL
    - UNIQUE(key, scope)
    - INDEX on (key, scope)

    api_keys table (for REST API auth per CONTEXT.md):
    - id TEXT PRIMARY KEY
    - key_hash TEXT NOT NULL (SHA-256 of the API key)
    - name TEXT NOT NULL DEFAULT 'default'
    - created_at TEXT NOT NULL
    - last_used_at TEXT

    Create DatabasePool in pool.rs following RESEARCH.md Pattern 3:
    - pub struct DatabasePool { pub reader: SqlitePool, pub writer: SqlitePool }
    - reader pool: max_connections = num_cpus * 2 (or hardcode 8 as reasonable default), read_only(true), WAL mode, foreign_keys(true), busy_timeout(5s), create_if_missing(true)
    - writer pool: max_connections = 1 (single writer for SQLite), WAL mode, foreign_keys(true), busy_timeout(5s), create_if_missing(true)
    - Run migrations via sqlx::migrate!("./migrations").run(&self.writer) on pool creation
    - IMPORTANT: Set journal_mode(SqliteJournalMode::Wal) on BOTH reader and writer options (per Pitfall 2 in RESEARCH.md)
    - Add a public method: pub async fn new(database_url: &str) -> Result&lt;Self, sqlx::Error&gt;

    Update boternity-infra/src/lib.rs to declare pub mod sqlite.
    Create sqlite/mod.rs to declare pub mod pool, pub mod bot, pub mod soul, pub mod secret.

    Use `BOTERNITY_DATA_DIR` env var (defaulting to ~/.boternity) for the database path per Claude's discretion in CONTEXT.md. Provide a helper function: pub fn default_database_url() -> String that resolves to {data_dir}/boternity.db.
  </action>
  <verify>
    Run `cargo build -p boternity-infra` -- compiles without errors.
    Write a small integration test (in boternity-infra/tests/ or inline #[cfg(test)] in pool.rs) that creates a DatabasePool with "sqlite::memory:" (or a temp file), verifies tables exist by querying sqlite_master.
  </verify>
  <done>
    SQLite migration creates all four tables. DatabasePool provides split read/write pools with WAL mode. Migrations run automatically on pool creation. Foreign key constraints enforced.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement repository trait adapters for SQLite</name>
  <files>
    crates/boternity-infra/src/sqlite/bot.rs
    crates/boternity-infra/src/sqlite/soul.rs
    crates/boternity-infra/src/sqlite/secret.rs
  </files>
  <action>
    Implement SqliteBotRepository (bot.rs):
    - struct SqliteBotRepository { pool: DatabasePool } with ::new(pool) constructor
    - impl BotRepository for SqliteBotRepository using sqlx::query! / sqlx::query_as! macros
    - create(): INSERT into bots table using writer pool. Map domain Bot to SQL columns. Use serde_json::to_string for tags. Return created bot.
    - get_by_id(): SELECT from bots using reader pool. Map SQL row back to domain Bot. Parse tags from JSON string.
    - get_by_slug(): SELECT WHERE slug = ? using reader pool.
    - list(): SELECT with optional WHERE clauses based on BotFilter. Support status, category filtering. Support sort_by (created_at, updated_at, name) with sort_order (asc/desc). Support limit/offset pagination (cursor pagination is an option per Claude's discretion, but offset is simpler for Phase 1 -- use offset). Use reader pool.
    - update(): UPDATE bots SET ... WHERE id = ? using writer pool. Update updated_at to now.
    - delete(): DELETE FROM bots WHERE id = ? using writer pool. Foreign key cascade handles soul_versions and secrets.
    - IMPORTANT: Do NOT put sqlx::FromRow on domain types. Create local SqliteRow structs (private to this module) that derive FromRow, then map to domain types with From/Into impls.
    - Map RepositoryError appropriately: sqlx::Error -> RepositoryError::Query, not found -> RepositoryError::NotFound, unique constraint violation -> RepositoryError::Conflict.

    Implement SqliteSoulRepository (soul.rs):
    - struct SqliteSoulRepository { pool: DatabasePool }
    - impl SoulRepository:
    - save_version(): INSERT INTO soul_versions. Also UPDATE bots SET version_count = version_count + 1 WHERE id = ?. Use writer pool for both in a transaction (BEGIN IMMEDIATE per Pitfall 1 in RESEARCH.md).
    - get_current(): SELECT from soul_versions WHERE bot_id = ? ORDER BY version DESC LIMIT 1 using reader pool.
    - get_version(): SELECT WHERE bot_id = ? AND version = ? using reader pool.
    - list_versions(): SELECT all versions for bot_id, ordered by version DESC, using reader pool. Return Vec of SoulVersion (version, hash, created_at, message -- NOT full content to keep response lightweight).
    - get_stored_hash(): SELECT hash FROM soul_versions WHERE bot_id = ? ORDER BY version DESC LIMIT 1 using reader pool.

    Implement SqliteSecretRepository (secret.rs):
    - struct SqliteSecretRepository { pool: DatabasePool }
    - impl SecretProvider for SqliteSecretRepository:
    - This repository handles only the vault storage backend. It stores encrypted values (BLOB) in the secrets table.
    - get(): SELECT encrypted_value WHERE key = ? AND scope = ? using reader pool. Return the raw encrypted bytes (decryption happens in the service layer). For now, return the blob as base64 string -- actual crypto integration comes in Plan 04.
    - set(): UPSERT (INSERT OR REPLACE) into secrets using writer pool. Store encrypted_value as BLOB.
    - delete(): DELETE WHERE key = ? AND scope = ? using writer pool.
    - list(): SELECT key, scope, provider, created_at, updated_at (NOT the encrypted value) WHERE scope = ? using reader pool. Return Vec of SecretEntry.
    - IMPORTANT: Never log or include encrypted_value in Debug output. Use skip_serializing on encrypted fields.

    For all repositories:
    - Use sqlx::query() with string SQL (not query! macro) for Phase 1 to avoid needing a live database at compile time. Add a TODO comment noting that these should migrate to sqlx::query!() macros with offline mode (.sqlx/ directory) in a future pass.
    - Handle RepositoryError mapping consistently via a shared helper function: fn map_sqlx_error(e: sqlx::Error) -> RepositoryError.
  </action>
  <verify>
    Run `cargo build -p boternity-infra` -- compiles without errors.
    Run `cargo test -p boternity-infra` -- write integration tests that:
    1. Create a DatabasePool with an in-memory SQLite database
    2. Create a bot via SqliteBotRepository::create()
    3. Retrieve it via get_by_id() and get_by_slug()
    4. List bots and verify count
    5. Update bot status and verify
    6. Delete bot and verify it's gone
    7. Save a soul version and retrieve it
    8. Verify foreign key cascade (delete bot -> soul versions deleted)
  </verify>
  <done>
    All three repository implementations compile and pass integration tests against a real SQLite database. CRUD operations work for bots, soul versions, and secrets. Foreign key cascades function correctly. No sqlx types leak into domain types.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` passes for entire workspace
2. `cargo test -p boternity-infra` -- all integration tests pass
3. SQLite database created with WAL mode (verify with `PRAGMA journal_mode` query in test)
4. Foreign key cascade works (delete bot removes soul_versions and secrets)
5. Split pool: writer has max_connections=1, reader has max_connections>1
6. No sqlx types in boternity-types or boternity-core crates
</verification>

<success_criteria>
- SQLite migration creates bots, soul_versions, secrets, api_keys tables with correct schema
- DatabasePool provides WAL-mode split read/write pools
- SqliteBotRepository implements full CRUD with filtering, sorting, pagination
- SqliteSoulRepository implements version storage with bot.version_count update in transaction
- SqliteSecretRepository implements encrypted secret storage (BLOB)
- Integration tests prove all operations work against real SQLite
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-bot-identity/01-02-SUMMARY.md`
</output>
