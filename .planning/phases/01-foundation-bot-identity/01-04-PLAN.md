---
phase: 01-foundation-bot-identity
plan: 04
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - crates/boternity-core/src/service/secret.rs
  - crates/boternity-core/src/service/mod.rs
  - crates/boternity-infra/src/crypto/vault.rs
  - crates/boternity-infra/src/crypto/mod.rs
  - crates/boternity-infra/src/keychain/mod.rs
  - crates/boternity-infra/src/secret/mod.rs
  - crates/boternity-infra/src/secret/env.rs
  - crates/boternity-infra/src/secret/chain.rs
  - crates/boternity-infra/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "User can store a secret and retrieve it via the vault backend"
    - "Secrets are encrypted at rest using AES-256-GCM (not plaintext)"
    - "OS keychain integration works (macOS Keychain / Linux Secret Service)"
    - "Environment variables override vault and keychain secrets"
    - "Secret values never appear in Debug output, logs, or error messages"
    - "Resolution chain follows precedence: env vars > per-bot > global vault"
  artifacts:
    - path: "crates/boternity-core/src/service/secret.rs"
      provides: "SecretService with resolution chain logic"
      contains: "pub struct SecretService"
    - path: "crates/boternity-infra/src/crypto/vault.rs"
      provides: "AES-256-GCM encryption for vault secrets"
      contains: "pub struct VaultCrypto"
    - path: "crates/boternity-infra/src/keychain/mod.rs"
      provides: "OS keychain adapter via keyring crate"
      contains: "pub struct KeychainProvider"
    - path: "crates/boternity-infra/src/secret/env.rs"
      provides: "Environment variable secret provider"
      contains: "pub struct EnvSecretProvider"
    - path: "crates/boternity-infra/src/secret/chain.rs"
      provides: "Chained secret resolution combining all providers"
      contains: "pub struct SecretChain"
  key_links:
    - from: "crates/boternity-core/src/service/secret.rs"
      to: "crates/boternity-core/src/repository/secret.rs"
      via: "SecretProvider trait usage"
      pattern: "SecretProvider"
    - from: "crates/boternity-infra/src/crypto/vault.rs"
      to: "aes_gcm::Aes256Gcm"
      via: "AES-256-GCM encryption"
      pattern: "Aes256Gcm"
    - from: "crates/boternity-infra/src/keychain/mod.rs"
      to: "keyring::Entry"
      via: "OS keychain access"
      pattern: "keyring::Entry"
---

<objective>
Implement the secrets vault with AES-256-GCM encryption, OS keychain integration, environment variable fallback, and the resolution chain that combines all three providers.

Purpose: Bots need API keys to function. The secrets system provides secure storage with zero-friction defaults (auto-generated vault key) and the flexibility of multiple backends per user preference.
Output: Working SecretService with encrypted vault, OS keychain adapter, env var provider, and a chain that resolves secrets in the correct precedence order.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-bot-identity/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation-bot-identity/01-01-SUMMARY.md
@.planning/phases/01-foundation-bot-identity/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement vault encryption and secret provider backends</name>
  <files>
    crates/boternity-infra/src/crypto/vault.rs
    crates/boternity-infra/src/crypto/mod.rs
    crates/boternity-infra/src/keychain/mod.rs
    crates/boternity-infra/src/secret/mod.rs
    crates/boternity-infra/src/secret/env.rs
    crates/boternity-infra/src/lib.rs
  </files>
  <action>
    Implement VaultCrypto (crypto/vault.rs) following RESEARCH.md code example:
    - pub struct VaultCrypto { cipher: Aes256Gcm }
    - ::new(key: &[u8; 32]) -> Self: Create cipher from 32-byte key
    - ::from_password(password: &str) -> Result&lt;Self, VaultError&gt;: Derive 32-byte key using Argon2id with OWASP recommended params (19 MiB memory, 2 iterations, 1 parallelism). Use a fixed salt derived from "boternity-vault" + machine id (or just "boternity-vault-v1" for simplicity).
    - ::from_keychain() -> Result&lt;Self, VaultError&gt;: Try to load master key from OS keychain. If not found, auto-generate a random 32-byte key, store it in keychain under service="boternity" user="vault-master-key", then create cipher. This is the zero-friction default path per RESEARCH.md open question 1 recommendation.
    - encrypt(&self, plaintext: &[u8]) -> Result&lt;Vec&lt;u8&gt;, VaultError&gt;: Generate random 12-byte nonce, encrypt with AES-256-GCM, prepend nonce to ciphertext (nonce || ciphertext format).
    - decrypt(&self, data: &[u8]) -> Result&lt;Vec&lt;u8&gt;, VaultError&gt;: Split first 12 bytes as nonce, decrypt remaining ciphertext.
    - IMPORTANT: VaultError should never contain plaintext or key material in its Display/Debug output.

    Implement KeychainProvider (keychain/mod.rs) following RESEARCH.md example:
    - pub struct KeychainProvider { service_name: String }
    - impl SecretProvider (from boternity-core trait) for KeychainProvider
    - ::new() -> Self with service_name = "boternity"
    - get(): keyring::Entry::new(service, key).get_password(). Map NoEntry to Ok(None), other errors to SecretError::ProviderUnavailable.
    - set(): keyring::Entry::new(service, key).set_password(value).
    - delete(): keyring::Entry::new(service, key).delete_credential().
    - list(): keyring does NOT support listing. Return empty vec with a TODO comment. In practice, the vault (SQLite) maintains the key index; keychain is a storage backend only.
    - For per-bot scoping: prefix key with "bot/{slug}/" when scope is Bot(id). Global scope uses key as-is.

    Implement EnvSecretProvider (secret/env.rs):
    - pub struct EnvSecretProvider;
    - impl SecretProvider for EnvSecretProvider
    - get(): std::env::var(key).ok(). Key names are used directly as env var names (e.g., "ANTHROPIC_API_KEY" checks env var ANTHROPIC_API_KEY). For bot-scoped secrets, also check BOTERNITY_{SLUG}_{KEY} format.
    - set(): Return Err(SecretError::ProviderUnavailable) -- cannot set env vars as a storage backend.
    - delete(): Return Err(SecretError::ProviderUnavailable).
    - list(): Return empty vec (env vars can't be enumerated for a specific scope).

    Implement VaultSecretProvider that wraps SqliteSecretRepository + VaultCrypto:
    - pub struct VaultSecretProvider { repo: Arc&lt;dyn SecretProvider&gt;, crypto: VaultCrypto }
    - This sits in boternity-infra/src/secret/mod.rs
    - get(): Retrieve encrypted bytes from repo, decrypt with crypto, return plaintext string.
    - set(): Encrypt plaintext with crypto, store encrypted bytes via repo.
    - delete(): Delegate to repo.
    - list(): Delegate to repo (returns entries without values).

    Update lib.rs to declare pub mod keychain; pub mod secret;
    Update crypto/mod.rs to declare pub mod vault; (hash already exists from Plan 03)
  </action>
  <verify>
    Run `cargo build -p boternity-infra` -- compiles without errors.
    Run `cargo test -p boternity-infra` -- write tests:
    1. VaultCrypto: encrypt then decrypt a known string, verify roundtrip produces original
    2. VaultCrypto: decrypt with wrong key fails
    3. VaultCrypto: nonce is random (encrypt same plaintext twice, ciphertexts differ)
    4. EnvSecretProvider: set env var, get via provider, verify value matches
    5. VaultSecretProvider: roundtrip through encrypt-store-retrieve-decrypt
  </verify>
  <done>
    AES-256-GCM vault encryption works with roundtrip verification. Auto-generated master key stored in OS keychain as zero-friction default. KeychainProvider wraps keyring crate. EnvSecretProvider reads from environment. VaultSecretProvider combines SQLite storage with encryption. All providers implement SecretProvider trait.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SecretService with resolution chain</name>
  <files>
    crates/boternity-core/src/service/secret.rs
    crates/boternity-core/src/service/mod.rs
    crates/boternity-infra/src/secret/chain.rs
  </files>
  <action>
    Implement SecretService (boternity-core/src/service/secret.rs):
    - pub struct SecretService { providers: Vec&lt;Arc&lt;dyn SecretProvider&gt;&gt; }
    - The providers list is ordered by precedence (first match wins).
    - ::new(providers: Vec&lt;Arc&lt;dyn SecretProvider&gt;&gt;) -> Self
    - get_secret(key: &str, scope: &SecretScope) -> Result&lt;Option&lt;String&gt;, SecretError&gt;:
      For Bot scope: First try providers with Bot scope, then fall back to Global scope.
      Precedence per CONTEXT.md: env vars > per-bot keys > global vault.
      Iterate through providers in order, return first Some result.
    - set_secret(key: &str, value: &str, scope: &SecretScope) -> Result&lt;(), SecretError&gt;:
      Write to the first provider that supports writes (env provider will return ProviderUnavailable, skip to next).
    - delete_secret(key: &str, scope: &SecretScope) -> Result&lt;(), SecretError&gt;:
      Delete from all providers that have this key.
    - list_secrets(scope: &SecretScope) -> Result&lt;Vec&lt;SecretEntry&gt;, SecretError&gt;:
      Aggregate from all providers, deduplicate by key (first provider wins).
    - mask_secret(value: &str) -> String:
      Show last 4 chars: "****{last4}". For values shorter than 4 chars, show "****".
      Per CONTEXT.md: `bnity list secrets` shows "ANTHROPIC_API_KEY: ****r3xk"

    IMPORTANT: SecretService is in boternity-core. It uses only the SecretProvider trait. No concrete infra types.

    Implement SecretChain (boternity-infra/src/secret/chain.rs):
    - pub fn build_secret_chain(vault: VaultSecretProvider, keychain: Option&lt;KeychainProvider&gt;, include_env: bool) -> Vec&lt;Arc&lt;dyn SecretProvider&gt;&gt;
    - Default chain order: [EnvSecretProvider, KeychainProvider (if available), VaultSecretProvider]
    - This function lives in infra because it wires concrete implementations.
    - The keychain is optional because it may not be available on all platforms (headless servers).

    Update core/service/mod.rs to declare pub mod secret;

    Create a Secret&lt;T&gt; wrapper type in boternity-types (if not already created in Plan 01):
    - pub struct Secret&lt;T&gt;(T)
    - impl Debug: always prints "***REDACTED***"
    - impl Display: always prints "***REDACTED***"
    - impl&lt;T&gt; Secret&lt;T&gt; { pub fn expose(&self) -> &T, pub fn new(value: T) -> Self }
    - This prevents accidental logging of secret values per Pitfall 5 in RESEARCH.md.
  </action>
  <verify>
    Run `cargo build` -- entire workspace compiles.
    Run `cargo test -p boternity-core -p boternity-infra` -- write tests:
    1. SecretService with mock providers: env provider returns value, vault doesn't -> env value returned (precedence test)
    2. SecretService with mock providers: env returns None, vault returns value -> vault value returned (fallback test)
    3. SecretService bot scope: first checks bot-scoped, then falls back to global
    4. mask_secret("sk-abcdefghijklmnop") returns "****mnop"
    5. mask_secret("abc") returns "****"
    6. Secret&lt;String&gt; Debug output is "***REDACTED***", not the actual value
    Run `cargo tree -p boternity-core | grep -E "sqlx|boternity-infra"` -- must return empty.
  </verify>
  <done>
    SecretService resolves secrets through provider chain with correct precedence (env > per-bot > global). Secret masking shows last 4 chars. Secret&lt;T&gt; wrapper prevents accidental logging. SecretChain builder wires concrete providers in infra. boternity-core still has zero infra dependencies.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` passes for entire workspace
2. `cargo test -p boternity-core -p boternity-infra` -- all tests pass
3. VaultCrypto roundtrip: encrypt("hello") -> decrypt -> "hello"
4. SecretService precedence: env > keychain > vault (verified with mock providers)
5. Secret&lt;String&gt;::new("secret").to_string() == "***REDACTED***"
6. `cargo tree -p boternity-core | grep boternity-infra` returns empty
</verification>

<success_criteria>
- AES-256-GCM vault encrypts secrets at rest with auto-generated master key
- OS keychain integration stores/retrieves via keyring crate
- Environment variables override all other providers
- Resolution chain: env vars > per-bot keys > global vault (per CONTEXT.md)
- Secret values never appear in Debug/Display output (Secret&lt;T&gt; wrapper)
- SecretService is in boternity-core with zero infra dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-bot-identity/01-04-SUMMARY.md`
</output>
