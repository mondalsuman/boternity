---
phase: 01-foundation-bot-identity
plan: 05
type: execute
wave: 4
depends_on: ["01-02", "01-03", "01-04"]
files_modified:
  - crates/boternity-api/src/main.rs
  - crates/boternity-api/src/state.rs
  - crates/boternity-api/src/cli/mod.rs
  - crates/boternity-api/src/cli/bot.rs
  - crates/boternity-api/src/cli/secret.rs
  - crates/boternity-api/src/cli/status.rs
  - crates/boternity-api/src/http/mod.rs
  - crates/boternity-api/src/http/router.rs
  - crates/boternity-api/src/http/handlers/mod.rs
  - crates/boternity-api/src/http/handlers/bot.rs
  - crates/boternity-api/src/http/handlers/soul.rs
  - crates/boternity-api/src/http/handlers/secret.rs
  - crates/boternity-api/src/http/extractors/mod.rs
  - crates/boternity-api/src/http/extractors/auth.rs
  - crates/boternity-api/src/http/extractors/query.rs
  - crates/boternity-api/src/http/error.rs
  - crates/boternity-api/src/http/response.rs
  - crates/boternity-api/Cargo.toml
autonomous: false

must_haves:
  truths:
    - "User can create a bot via `bnity create bot` (interactive wizard) and via `bnity create bot --name X` (one-shot)"
    - "User can list bots via `bnity list bots` with a rich colored table (name, status, description, emoji)"
    - "User can delete a bot via `bnity delete bot <slug>` with confirmation prompt"
    - "User can set and list secrets via `bnity set secret KEY` and `bnity list secrets`"
    - "REST API at /api/v1/bots returns bot list in envelope format with _links and meta"
    - "REST API requires API key auth on every request"
    - "CLI and REST API operations are consistent (create via CLI, list via API shows the bot)"
  artifacts:
    - path: "crates/boternity-api/src/main.rs"
      provides: "Application entry point wiring CLI and HTTP server"
      contains: "fn main"
    - path: "crates/boternity-api/src/cli/bot.rs"
      provides: "CLI commands for bot lifecycle (create, list, show, delete, clone)"
      contains: "create_bot"
    - path: "crates/boternity-api/src/http/router.rs"
      provides: "Axum router with all REST API routes"
      contains: "Router::new"
    - path: "crates/boternity-api/src/http/handlers/bot.rs"
      provides: "HTTP handlers for bot CRUD endpoints"
      contains: "pub async fn list_bots"
    - path: "crates/boternity-api/src/http/response.rs"
      provides: "Envelope response format with data, meta, errors, _links"
      contains: "pub struct ApiResponse"
    - path: "crates/boternity-api/src/http/extractors/auth.rs"
      provides: "API key authentication extractor"
      contains: "ApiKey"
  key_links:
    - from: "crates/boternity-api/src/main.rs"
      to: "crates/boternity-api/src/state.rs"
      via: "AppState wiring with services"
      pattern: "AppState"
    - from: "crates/boternity-api/src/http/handlers/bot.rs"
      to: "crates/boternity-core/src/service/bot.rs"
      via: "BotService method calls"
      pattern: "bot_service"
    - from: "crates/boternity-api/src/cli/bot.rs"
      to: "crates/boternity-core/src/service/bot.rs"
      via: "BotService method calls"
      pattern: "bot_service"
---

<objective>
Build the CLI (`bnity`) with bot lifecycle commands and secrets management, plus the REST API with all bot endpoints, API key auth, and the envelope response format. Both interfaces share the same services.

Purpose: This is how users interact with Boternity. The CLI provides a polished terminal experience (per CONTEXT.md: "a joy to use"), and the REST API enables programmatic access with the exact response format specified in CONTEXT.md.
Output: Working `bnity` CLI binary with bot CRUD + secrets commands, and a REST API server at /api/v1/* with authentication.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-bot-identity/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation-bot-identity/01-02-SUMMARY.md
@.planning/phases/01-foundation-bot-identity/01-03-SUMMARY.md
@.planning/phases/01-foundation-bot-identity/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CLI commands with clap</name>
  <files>
    crates/boternity-api/src/main.rs
    crates/boternity-api/src/state.rs
    crates/boternity-api/src/cli/mod.rs
    crates/boternity-api/src/cli/bot.rs
    crates/boternity-api/src/cli/secret.rs
    crates/boternity-api/src/cli/status.rs
    crates/boternity-api/Cargo.toml
  </files>
  <action>
    Add CLI-specific dependencies to boternity-api/Cargo.toml:
    - dialoguer (for interactive prompts, confirmation dialogs, password input)
    - indicatif (for progress spinners)
    - comfy-table or tabled (for rich table output)
    - console (for colored output, TTY detection)
    - clap_complete (for shell completions generation)

    Create the main CLI structure (cli/mod.rs) using clap derive:
    - Binary name: "bnity" (set in Cargo.toml [[bin]] section)
    - Top-level: #[derive(Parser)] with name = "bnity", about = "Manage your AI bot fleet"
    - Global flags: --json (machine-readable output), --quiet (errors only), --verbose/-v (detailed), --debug/-vv (trace)
    - Commands enum with verb-noun structure per CONTEXT.md:
      - create bot [--name NAME] [--description DESC] [--category CAT]
      - list bots [--status STATUS] [--category CAT] [--sort FIELD] [--json]
      - show &lt;slug&gt; [--json]
      - delete bot &lt;slug&gt; [--force]
      - clone bot &lt;slug&gt; --name NEW_NAME
      - set secret &lt;KEY&gt; [--value VALUE] [--bot SLUG]
      - list secrets [--bot SLUG]
      - check &lt;slug&gt; (health check)
      - status (system dashboard)
      - serve [--port PORT] [--host HOST] (start REST API server)
      - completions &lt;SHELL&gt; (generate shell completions: bash, zsh, fish)
    - Short aliases per CONTEXT.md: ls (list bots), rm (delete), new (create bot)

    Implement bot commands (cli/bot.rs):
    - create_bot: If --name provided, use one-shot mode. If bare `bnity create bot`, launch interactive wizard using dialoguer:
      1. Prompt for name (required)
      2. Prompt for short description (required, per CONTEXT.md)
      3. Prompt for category (select from Assistant/Creative/Research/Utility)
      4. Prompt for tags (comma-separated, optional)
      5. Ask: "Edit SOUL.md now? [y/N]" -- if yes, open in $EDITOR
      Display: spinner during creation, then rich output showing created bot with emoji.
    - list_bots: Query BotService, display as colored table (name with emoji, status colored, description truncated, last active relative time, model). If --json, output raw JSON.
    - show_bot: Full profile view per CONTEXT.md -- name, description, status, soul preview (first 5 lines), config summary, stats (conversation_count, total_tokens, version_count), timestamps.
    - delete_bot: Confirm with dialoguer unless --force. Show what will be deleted (bot name, files). Delete via BotService.
    - clone_bot: Clone via BotService, show new bot details.

    Implement secret commands (cli/secret.rs):
    - set_secret: If --value provided, use directly. Otherwise, use dialoguer::Password for hidden input (per CONTEXT.md: "never in shell history"). Set via SecretService. Show "Secret KEY set successfully".
    - list_secrets: List via SecretService, show table with key name + masked last 4 chars per CONTEXT.md: "ANTHROPIC_API_KEY: ****r3xk"

    Implement status command (cli/status.rs):
    - System dashboard showing: version, data directory, database size, total bots (by status), total secrets count, API server status (running/not running).

    Implement completions command:
    - Use clap_complete to generate shell completion scripts for bash, zsh, fish.
    - Output to stdout (user pipes to appropriate location).

    Create AppState (state.rs):
    - pub struct AppState { pub bot_service: Arc&lt;BotService&gt;, pub soul_service: Arc&lt;SoulService&gt;, pub secret_service: Arc&lt;SecretService&gt; }
    - impl Clone for AppState (all fields are Arc)

    Wire main.rs:
    - Parse CLI args
    - Initialize DatabasePool
    - Create concrete repositories (SqliteBotRepository, SqliteSoulRepository, etc.)
    - Create services (BotService, SoulService, SecretService) with repository trait objects
    - Build AppState
    - Dispatch to appropriate CLI handler OR start HTTP server (for `serve` command)
    - TTY detection: auto-disable colors when output is piped (use console::Term::stdout().is_term())

    Help system: Add #[command(about = "...", long_about = "...")] with 2-3 usage examples per command as per CONTEXT.md.
  </action>
  <verify>
    Run `cargo build -p boternity-api` -- compiles without errors.
    Run the built binary: `./target/debug/bnity --help` -- shows command list.
    Run `./target/debug/bnity create bot --name "Test Bot" --description "A test"` -- creates bot, shows output.
    Run `./target/debug/bnity list bots` -- shows the created bot in a table.
    Run `./target/debug/bnity show test-bot` -- shows full profile.
    Run `./target/debug/bnity list bots --json` -- outputs valid JSON.
    Run `./target/debug/bnity delete bot test-bot --force` -- deletes without prompt.
    Run `./target/debug/bnity completions zsh` -- outputs zsh completions script.
  </verify>
  <done>
    CLI binary `bnity` with all bot lifecycle commands working. Interactive wizard for bot creation. Rich colored table for bot listing. Secret management with hidden input. Shell completions for bash/zsh/fish. All commands use shared BotService/SoulService/SecretService.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement REST API with Axum</name>
  <files>
    crates/boternity-api/src/http/mod.rs
    crates/boternity-api/src/http/router.rs
    crates/boternity-api/src/http/handlers/mod.rs
    crates/boternity-api/src/http/handlers/bot.rs
    crates/boternity-api/src/http/handlers/soul.rs
    crates/boternity-api/src/http/handlers/secret.rs
    crates/boternity-api/src/http/extractors/mod.rs
    crates/boternity-api/src/http/extractors/auth.rs
    crates/boternity-api/src/http/extractors/query.rs
    crates/boternity-api/src/http/error.rs
    crates/boternity-api/src/http/response.rs
  </files>
  <action>
    Create the response envelope (response.rs) per CONTEXT.md:
    - pub struct ApiResponse&lt;T: Serialize&gt; { pub data: T, pub meta: ResponseMeta, pub errors: Vec&lt;ApiError&gt;, pub _links: HashMap&lt;String, String&gt; }
    - pub struct ResponseMeta { pub request_id: String, pub timestamp: String, pub response_time_ms: Option&lt;u64&gt; }
    - pub struct ApiError { pub code: String, pub message: String, pub details: Option&lt;serde_json::Value&gt; }
    - Implement IntoResponse for ApiResponse -- wraps in Json, sets status code.
    - Helper: ApiResponse::success(data, links) and ApiResponse::error(code, message, status)
    - Generate request_id as UUID v7 per request.

    Create error handling (error.rs):
    - pub enum AppError { NotFound(String), BadRequest(String), Conflict(String), Unauthorized, Internal(String) }
    - impl IntoResponse for AppError: Convert to the CONTEXT.md error format:
      { "error": { "code": "BOT_NOT_FOUND", "message": "Bot 'luna' not found", "details": {} } }
    - Map BotError, SoulError, SecretError, RepositoryError to appropriate AppError variants.

    Create API key auth extractor (extractors/auth.rs):
    - pub struct ApiKeyAuth(pub String);
    - impl FromRequestParts: Extract API key from Authorization header (Bearer token) or X-API-Key header.
    - Verify key against hashed keys in api_keys table (SHA-256 comparison).
    - On first run: If no API keys exist, auto-generate one, store hash in database, print the key to console ONCE ("Your API key: bnty_xxxx. Save this -- it won't be shown again.").
    - Return 401 Unauthorized with proper error format if key is missing or invalid.

    Create query parameter extractors (extractors/query.rs):
    - Sparse fieldsets: ?fields=name,status,created_at (parse into a set, filter response fields)
    - Filtering: ?status=active&category=research (map to BotFilter)
    - Sorting: ?sort=created_at&order=desc
    - Pagination: ?limit=20&offset=0 (offset pagination, per Claude's discretion)

    Create bot handlers (handlers/bot.rs):
    - POST /api/v1/bots: Create bot. Accept JSON body { name, description?, category?, tags? }. Return 201 with created bot in envelope. Include _links: { self, soul, identity, secrets }.
    - GET /api/v1/bots: List bots. Support ?status, ?category, ?sort, ?order, ?limit, ?offset, ?fields. Return 200 with array in envelope. Include _links: { self } for each bot.
    - GET /api/v1/bots/{id}: Get single bot by UUID or slug. Return 200 with bot in envelope. Include _links: { self, soul, identity, secrets }.
    - PUT /api/v1/bots/{id}: Update bot. Accept JSON body with optional fields. Return 200.
    - DELETE /api/v1/bots/{id}: Delete bot. Return 204 No Content.
    - POST /api/v1/bots/{id}/clone: Clone bot. Accept { name } body. Return 201.

    Create soul handlers (handlers/soul.rs):
    - GET /api/v1/bots/{id}/soul: Get current soul content. Return 200 with soul in envelope.
    - GET /api/v1/bots/{id}/soul/versions: List soul versions. Return 200 with version history.
    - GET /api/v1/bots/{id}/soul/versions/{version}: Get specific version.

    Create secret handlers (handlers/secret.rs):
    - GET /api/v1/secrets: List secrets (masked values). Support ?scope=global or ?scope=bot:{slug}.
    - PUT /api/v1/secrets/{key}: Set a secret. Accept { value, scope? } body. Return 200.
    - DELETE /api/v1/secrets/{key}: Delete a secret. Return 204.
    - IMPORTANT: Never return secret values in responses. Only key names + masked last 4 chars.

    Create router (router.rs):
    - Wire all routes with axum Router.
    - Apply middleware layers: tower_http::trace::TraceLayer, tower_http::cors::CorsLayer::permissive(), response time header (X-Response-Time), request ID header (X-Request-Id).
    - All routes under /api/v1/ prefix.
    - Use Axum 0.8 path syntax: /{id} not /:id (per Pitfall 3 in RESEARCH.md).

    Update main.rs `serve` command handler:
    - Create TcpListener on specified host:port (default 127.0.0.1:3000)
    - Use axum::serve(listener, app) (Axum 0.8 pattern, NOT axum::Server)
    - Print server URL on startup
    - Graceful shutdown on SIGINT/SIGTERM
  </action>
  <verify>
    Run `cargo build -p boternity-api` -- compiles without errors.
    Start server: `./target/debug/bnity serve &`
    Note the auto-generated API key from console output.
    Test endpoints:
    - `curl -H "Authorization: Bearer APIKEY" http://localhost:3000/api/v1/bots` -- returns 200 with envelope format
    - `curl -X POST -H "Authorization: Bearer APIKEY" -H "Content-Type: application/json" -d '{"name":"Luna"}' http://localhost:3000/api/v1/bots` -- returns 201
    - `curl http://localhost:3000/api/v1/bots` -- returns 401 (no auth)
    - `curl -H "Authorization: Bearer APIKEY" http://localhost:3000/api/v1/bots/luna` -- returns 200 with bot details and _links
    - Verify response has: data, meta (request_id, timestamp), _links
    - Verify error response has: error.code, error.message format
    Kill server.
  </verify>
  <done>
    REST API at /api/v1/* with full bot CRUD, soul version endpoints, and secret management. API key auth on every request. Envelope response format with data/meta/errors/_links. HATEOAS links in every response. Filtering, sorting, pagination on list endpoints. Proper error format with machine-readable codes.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete CLI (`bnity`) and REST API for bot lifecycle management. Interactive bot creation wizard, rich colored output, secrets management, and a REST API with auth and envelope responses.</what-built>
  <how-to-verify>
    1. Run `./target/debug/bnity create bot --name "Luna" --description "A curious researcher"` -- verify bot is created with styled output showing emoji
    2. Run `./target/debug/bnity list bots` -- verify colored table with Luna showing
    3. Run `./target/debug/bnity show luna` -- verify full profile with soul preview, config, stats
    4. Run `./target/debug/bnity set secret ANTHROPIC_API_KEY` -- verify hidden input prompt (type a test value)
    5. Run `./target/debug/bnity list secrets` -- verify masked output "ANTHROPIC_API_KEY: ****xxxx"
    6. Run `./target/debug/bnity status` -- verify system dashboard
    7. Start server: `./target/debug/bnity serve` -- note the API key
    8. In another terminal: `curl -H "Authorization: Bearer <KEY>" http://localhost:3000/api/v1/bots` -- verify Luna appears in envelope format
    9. Verify: `ls ~/.boternity/bots/luna/` shows SOUL.md, IDENTITY.md, USER.md
    10. Read SOUL.md -- verify it has a human-like personality, not a generic bot template
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `cargo build -p boternity-api` compiles
2. `bnity --help` shows all commands with examples
3. `bnity create bot --name X` creates bot with files on disk
4. `bnity list bots` shows rich colored table
5. `bnity serve` starts REST API on port 3000
6. All REST endpoints return envelope format with proper auth
7. CLI and API are consistent (create via one, visible via other)
8. Shell completions generate for bash/zsh/fish
</verification>

<success_criteria>
- `bnity` CLI binary with create/list/show/delete/clone/set-secret/list-secrets/check/status/serve/completions commands
- Interactive wizard for `bnity create bot` (bare command)
- One-shot mode with `bnity create bot --name X --description Y`
- Rich colored tables, emojis, spinners in CLI output
- REST API at /api/v1/* with API key auth on every request
- Envelope response format per CONTEXT.md: { data, meta, errors, _links }
- Error format per CONTEXT.md: { error: { code, message, details } }
- HATEOAS _links in every response
- Filtering (?status, ?category), sorting (?sort, ?order), pagination (?limit, ?offset) on list endpoints
- CLI and API share the same services (consistent state)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-bot-identity/01-05-SUMMARY.md`
</output>
