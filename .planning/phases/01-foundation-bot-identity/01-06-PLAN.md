---
phase: 01-foundation-bot-identity
plan: 06
type: execute
wave: 4
depends_on: ["01-02", "01-03"]
files_modified:
  - crates/boternity-core/src/service/soul.rs
  - crates/boternity-core/src/service/bot.rs
  - crates/boternity-api/src/cli/soul.rs
  - crates/boternity-api/src/cli/mod.rs
  - crates/boternity-api/src/http/handlers/soul.rs
autonomous: true

must_haves:
  truths:
    - "Every SOUL.md edit creates a new version with the previous content preserved"
    - "User can list all versions of a bot's soul with timestamps and diff summary"
    - "User can rollback to any previous soul version"
    - "SHA-256 hash mismatch at bot startup is a hard block -- bot refuses to start with clear error"
    - "No API endpoint or service method can modify SOUL.md except the explicit admin update method"
    - "Soul update requires going through update_soul() which creates a version entry"
  artifacts:
    - path: "crates/boternity-core/src/service/soul.rs"
      provides: "SoulService with versioning, rollback, and integrity enforcement"
      contains: "update_soul"
    - path: "crates/boternity-api/src/cli/soul.rs"
      provides: "CLI commands for soul management (edit, history, rollback, verify)"
      contains: "soul_history"
  key_links:
    - from: "crates/boternity-core/src/service/soul.rs"
      to: "crates/boternity-core/src/repository/soul.rs"
      via: "SoulRepository for version persistence"
      pattern: "soul_repo"
    - from: "crates/boternity-core/src/service/soul.rs"
      to: "ContentHasher"
      via: "SHA-256 hash computation for every version"
      pattern: "hasher.compute_hash"
    - from: "crates/boternity-core/src/service/bot.rs"
      to: "crates/boternity-core/src/service/soul.rs"
      via: "Integrity check before bot operations"
      pattern: "verify_soul_integrity"
---

<objective>
Implement soul versioning (every edit tracked, full history, rollback) and immutability enforcement (SHA-256 hash verification, hard block on mismatch, no runtime modification).

Purpose: SOUL.md immutability is a security requirement (CVE-2026-25253 mitigation per roadmap). Soul versioning ensures identity changes are intentional and reversible. This is the final piece that makes Phase 1's identity system complete and secure.
Output: Soul versioning with history/rollback, integrity verification at bot startup, and immutability enforcement preventing runtime modification.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-bot-identity/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation-bot-identity/01-02-SUMMARY.md
@.planning/phases/01-foundation-bot-identity/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement soul versioning and immutability in boternity-core</name>
  <files>
    crates/boternity-core/src/service/soul.rs
    crates/boternity-core/src/service/bot.rs
  </files>
  <action>
    Extend SoulService (already created in Plan 03) with versioning methods:

    update_soul(bot_id: &BotId, new_content: String, message: Option&lt;String&gt;) -> Result&lt;Soul, SoulError&gt;:
    1. Get current soul version number from soul_repo.get_current() (if exists, increment; if first, version = 1)
    2. Compute SHA-256 hash of new_content using ContentHasher
    3. Create Soul struct with incremented version, new hash, new content
    4. Save to database via soul_repo.save_version()
    5. Write new content to SOUL.md on disk via FileSystem trait
    6. Return the new Soul
    This is the ONLY method that can modify SOUL.md. It always creates a new version entry.

    rollback_soul(bot_id: &BotId, target_version: i32) -> Result&lt;Soul, SoulError&gt;:
    1. Retrieve the target version content from soul_repo.get_version()
    2. If not found, return SoulError::NotFound
    3. Call update_soul() with the old content and message "Rollback to version {target_version}"
    This creates a NEW version with the old content (preserving full linear history).

    verify_soul_integrity(bot_id: &BotId, soul_path: &Path) -> Result&lt;SoulIntegrityResult, SoulError&gt;:
    1. Read SOUL.md content from disk via FileSystem trait
    2. Compute SHA-256 hash of file content
    3. Get stored hash from soul_repo.get_stored_hash()
    4. Compare hashes
    5. Return SoulIntegrityResult { valid: bool, expected_hash: String, actual_hash: String, version: i32 }
    This does NOT modify anything -- it is a pure read/verify operation.

    Add a new enum to boternity-types:
    pub struct SoulIntegrityResult {
        pub valid: bool,
        pub expected_hash: String,
        pub actual_hash: String,
        pub version: i32,
    }

    get_soul_diff(bot_id: &BotId, from_version: i32, to_version: i32) -> Result&lt;String, SoulError&gt;:
    1. Retrieve both versions' content
    2. Compute a simple line-by-line diff (additions with +, removals with -)
    3. Return the diff as a string
    Do NOT add a diff library dependency -- implement a simple line diff (split by newline, compare lines, mark additions/removals). This is sufficient for viewing changes between soul versions.

    Enforce immutability in BotService:
    - Add ensure_soul_integrity(bot_id: &BotId) -> Result&lt;(), BotError&gt; method:
      1. Call soul_service.verify_soul_integrity()
      2. If hash mismatch: return Err(BotError::SoulIntegrityViolation { expected_hash, actual_hash })
      3. This is called in any bot operation that would "start" a bot (not yet in Phase 1, but set up the guard)
    - IMPORTANT: There must be NO method on BotService or any other service that directly writes to SOUL.md without going through SoulService::update_soul(). Verify this by reviewing all FileSystem.write_file calls -- only SoulService::update_soul() and the initial bot creation in BotService::create_bot() should write SOUL.md.

    Add a soul_readonly flag concept: In the runtime path, SOUL.md reads are unrestricted but writes go ONLY through update_soul(). Document this invariant with a comment at the top of soul.rs.
  </action>
  <verify>
    Run `cargo build -p boternity-core` -- compiles without errors.
    Run `cargo test -p boternity-core` -- write tests:
    1. update_soul increments version number (v1 -> v2 -> v3)
    2. update_soul computes and stores correct SHA-256 hash
    3. rollback_soul creates a new version with the old content (linear history preserved)
    4. verify_soul_integrity returns valid=true when hash matches
    5. verify_soul_integrity returns valid=false when file is tampered (hash mismatch)
    6. get_soul_diff shows additions and removals between versions
    7. Verify update_soul is the only write path (review code for direct file writes)
    Run `cargo tree -p boternity-core | grep boternity-infra` -- must return empty.
  </verify>
  <done>
    Soul versioning: every update creates a new version with SHA-256 hash. Rollback retrieves old version content and creates a new version entry. Integrity verification compares disk hash with stored hash. No runtime modification path bypasses versioning. Immutability invariant documented and enforced.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add soul CLI commands and update REST API handlers</name>
  <files>
    crates/boternity-api/src/cli/soul.rs
    crates/boternity-api/src/cli/mod.rs
    crates/boternity-api/src/http/handlers/soul.rs
  </files>
  <action>
    Create soul CLI commands (cli/soul.rs):

    `bnity edit soul <slug>` (or `bnity soul edit <slug>`):
    1. Verify bot exists
    2. Open current SOUL.md in $EDITOR (or $VISUAL, fall back to vi/nano)
    3. Wait for editor to close
    4. Read the edited file content
    5. If content changed: call SoulService::update_soul() with the new content
    6. Show: "Soul updated: version {N} (hash: {short_hash})"
    7. If content unchanged: show "No changes made"
    This is the explicit admin edit path per CONTEXT.md: "edits only via admin UI/CLI"

    `bnity soul history <slug>`:
    1. Get all soul versions via SoulService::get_soul_versions()
    2. Display as a table: version number, hash (first 8 chars), created_at (relative time), message
    3. Most recent version at top

    `bnity soul diff <slug> [--from V1] [--to V2]`:
    1. If --from and --to provided, show diff between those versions
    2. If only --from, diff from that version to current
    3. If neither, diff between current and previous version
    4. Color the diff output: green for additions, red for removals

    `bnity soul rollback <slug> <version>`:
    1. Confirm: "Rollback luna's soul to version {V}? This creates a new version. [y/N]"
    2. Call SoulService::rollback_soul()
    3. Show: "Soul rolled back: now at version {N} (content from version {V})"

    `bnity soul verify <slug>` (or integrate into `bnity check <slug>`):
    1. Call SoulService::verify_soul_integrity()
    2. If valid: green checkmark "Soul integrity verified (version {V}, hash: {short_hash})"
    3. If invalid: red X "SOUL INTEGRITY VIOLATION! Expected hash {expected}, found {actual}. The SOUL.md file has been modified outside of Boternity. Use `bnity soul history {slug}` to view versions and `bnity edit soul {slug}` to properly update."

    Update cli/mod.rs to add soul subcommand group and wire soul.rs handlers.

    Update REST API soul handlers (http/handlers/soul.rs) to include versioning endpoints:
    - GET /api/v1/bots/{id}/soul: Already exists from Plan 05. Ensure it returns current version with hash and version number.
    - GET /api/v1/bots/{id}/soul/versions: List all versions with hash, version number, created_at, message.
    - GET /api/v1/bots/{id}/soul/versions/{version}: Get specific version content.
    - PUT /api/v1/bots/{id}/soul: Update soul content. Accept { content, message? } body. Calls SoulService::update_soul(). Returns new version in envelope.
    - POST /api/v1/bots/{id}/soul/rollback: Rollback. Accept { version } body. Calls SoulService::rollback_soul(). Returns new version.
    - GET /api/v1/bots/{id}/soul/verify: Check integrity. Returns SoulIntegrityResult in envelope.
    - IMPORTANT: PUT /api/v1/bots/{id}/soul is the ONLY endpoint that modifies SOUL.md. There must be no other endpoint that can write to it. This enforces the immutability contract via API.
  </action>
  <verify>
    Run `cargo build -p boternity-api` -- compiles without errors.
    Test CLI flow:
    1. `bnity create bot --name "TestBot" --description "Test"` -- create a bot
    2. `bnity soul history testbot` -- shows version 1 (initial)
    3. `bnity edit soul testbot` -- opens editor, make a change, save
    4. `bnity soul history testbot` -- shows version 1 and version 2
    5. `bnity soul diff testbot` -- shows the diff between v1 and v2
    6. `bnity soul rollback testbot 1` -- rolls back to v1 content
    7. `bnity soul history testbot` -- shows v1, v2, and v3 (rollback)
    8. `bnity soul verify testbot` -- shows green checkmark
    9. Manually edit ~/.boternity/bots/testbot/SOUL.md with a text editor
    10. `bnity soul verify testbot` -- shows red INTEGRITY VIOLATION
    Test REST API:
    - PUT /api/v1/bots/{id}/soul with new content -- returns 200 with new version
    - GET /api/v1/bots/{id}/soul/versions -- returns version history
    - POST /api/v1/bots/{id}/soul/rollback -- returns rolled-back version
    - GET /api/v1/bots/{id}/soul/verify -- returns integrity result
    Clean up: `bnity delete bot testbot --force`
  </verify>
  <done>
    Soul management CLI: edit (opens $EDITOR), history (version table), diff (colored output), rollback (with confirmation), verify (integrity check). REST API: soul CRUD with versioning, rollback, and integrity verification endpoints. SOUL.md can only be modified through explicit admin commands (CLI edit, API PUT), never at runtime. Hash mismatch produces a clear, actionable error.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` passes for entire workspace
2. `cargo test` passes all tests across all crates
3. Soul versioning: create -> edit -> edit -> rollback produces versions 1, 2, 3, 4 (linear history)
4. `bnity soul verify <slug>` returns valid for untampered SOUL.md
5. `bnity soul verify <slug>` returns INTEGRITY VIOLATION after manual file edit
6. REST PUT /api/v1/bots/{id}/soul creates new version (not overwrite)
7. No other endpoint or method can modify SOUL.md (audit the codebase)
8. `cargo tree -p boternity-core | grep boternity-infra` returns empty
</verification>

<success_criteria>
- Every SOUL.md edit creates a new version entry (full history preserved forever)
- Rollback creates a NEW version with old content (linear history, never rewrites)
- SHA-256 integrity verification works: valid when untampered, VIOLATION when modified externally
- Hash mismatch is a HARD BLOCK with clear error message (per CONTEXT.md: "no exceptions")
- Only SoulService::update_soul() can modify SOUL.md (immutability enforced)
- CLI provides: edit, history, diff, rollback, verify commands
- REST API provides: GET/PUT soul, GET versions, POST rollback, GET verify endpoints
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-bot-identity/01-06-SUMMARY.md`
</output>
