---
phase: 02-single-agent-chat-llm
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - migrations/20260211_002_chat_and_memory.sql
  - crates/boternity-infra/src/sqlite/chat.rs
  - crates/boternity-infra/src/sqlite/memory.rs
  - crates/boternity-infra/src/sqlite/mod.rs
autonomous: true

must_haves:
  truths:
    - "Chat sessions can be created, queried, updated, and deleted in SQLite"
    - "Chat messages are persisted immediately after completion (not batched at session end)"
    - "Memory entries are stored with full provenance (bot_id, session_id, source_message_id)"
    - "Pending memory extractions are queued for retry on failure"
    - "Context summaries are stored per session for sliding window management"
  artifacts:
    - path: "migrations/20260211_002_chat_and_memory.sql"
      provides: "DDL for chat_sessions, chat_messages, session_memories, pending_memory_extractions, context_summaries"
      contains: "CREATE TABLE IF NOT EXISTS chat_sessions"
    - path: "crates/boternity-infra/src/sqlite/chat.rs"
      provides: "SqliteChatRepository implementing ChatRepository"
      contains: "impl ChatRepository for SqliteChatRepository"
    - path: "crates/boternity-infra/src/sqlite/memory.rs"
      provides: "SqliteMemoryRepository implementing MemoryRepository"
      contains: "impl MemoryRepository for SqliteMemoryRepository"
  key_links:
    - from: "crates/boternity-infra/src/sqlite/chat.rs"
      to: "crates/boternity-core/src/chat/repository.rs"
      via: "implements ChatRepository trait"
      pattern: "impl ChatRepository for SqliteChatRepository"
    - from: "crates/boternity-infra/src/sqlite/memory.rs"
      to: "crates/boternity-core/src/memory/store.rs"
      via: "implements MemoryRepository trait"
      pattern: "impl MemoryRepository for SqliteMemoryRepository"
    - from: "crates/boternity-infra/src/sqlite/chat.rs"
      to: "crates/boternity-infra/src/sqlite/pool.rs"
      via: "uses DatabasePool for split read/write"
      pattern: "self\\.pool\\.writer\\(\\)|self\\.pool\\.reader\\(\\)"
---

<objective>
Create SQLite persistence for chat sessions, messages, memories, and context summaries.

Purpose: Every conversation, message, and memory must survive process exit. Immediate message persistence prevents data loss on crash (Pitfall 7 from research). The pending_memory_extractions table enables retry-on-failure for memory extraction. Context summaries support the sliding window context management.

Output: SQL migration file and two repository implementations (SqliteChatRepository, SqliteMemoryRepository) following existing SqliteBotRepository patterns.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-single-agent-chat-llm/02-RESEARCH.md
@.planning/phases/02-single-agent-chat-llm/02-01-SUMMARY.md
@crates/boternity-infra/src/sqlite/bot.rs
@crates/boternity-infra/src/sqlite/pool.rs
@crates/boternity-infra/src/sqlite/mod.rs
@migrations/20260210_001_initial.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create chat and memory migration</name>
  <files>
    migrations/20260211_002_chat_and_memory.sql
  </files>
  <action>
Create the SQL migration file following the exact schema from RESEARCH.md. The file goes in the `migrations/` directory at the workspace root (matching existing 20260210_001_initial.sql).

Tables to create:

**chat_sessions:** id (TEXT PK, UUIDv7), bot_id (TEXT NOT NULL REFERENCES bots(id) ON DELETE CASCADE), title (TEXT nullable), started_at (TEXT NOT NULL ISO 8601), ended_at (TEXT nullable), total_input_tokens (INTEGER NOT NULL DEFAULT 0), total_output_tokens (INTEGER NOT NULL DEFAULT 0), message_count (INTEGER NOT NULL DEFAULT 0), model (TEXT NOT NULL), status (TEXT NOT NULL DEFAULT 'active' CHECK IN ('active', 'completed', 'crashed'))
- Indexes: bot_id, started_at DESC

**chat_messages:** id (TEXT PK, UUIDv7), session_id (TEXT NOT NULL REFERENCES chat_sessions(id) ON DELETE CASCADE), role (TEXT NOT NULL CHECK IN ('user', 'assistant', 'system')), content (TEXT NOT NULL), created_at (TEXT NOT NULL ISO 8601), input_tokens (INTEGER nullable), output_tokens (INTEGER nullable), model (TEXT nullable), stop_reason (TEXT nullable), response_ms (INTEGER nullable)
- Index: session_id + created_at compound

**session_memories:** id (TEXT PK, UUIDv7), bot_id (TEXT NOT NULL REFERENCES bots(id) ON DELETE CASCADE), session_id (TEXT NOT NULL REFERENCES chat_sessions(id)), fact (TEXT NOT NULL), category (TEXT NOT NULL CHECK IN ('preference', 'fact', 'decision', 'context', 'correction')), importance (INTEGER NOT NULL CHECK BETWEEN 1 AND 5), source_message_id (TEXT nullable), superseded_by (TEXT nullable), created_at (TEXT NOT NULL ISO 8601), is_manual (INTEGER NOT NULL DEFAULT 0)
- Indexes: bot_id + importance DESC + created_at DESC compound, session_id

**pending_memory_extractions:** id (TEXT PK), session_id (TEXT NOT NULL REFERENCES chat_sessions(id)), bot_id (TEXT NOT NULL REFERENCES bots(id)), attempt_count (INTEGER NOT NULL DEFAULT 0), last_attempt_at (TEXT nullable), next_attempt_at (TEXT NOT NULL), error_message (TEXT nullable), created_at (TEXT NOT NULL)

**context_summaries:** id (TEXT PK, UUIDv7), session_id (TEXT NOT NULL REFERENCES chat_sessions(id) ON DELETE CASCADE), summary (TEXT NOT NULL), messages_start (INTEGER NOT NULL), messages_end (INTEGER NOT NULL), token_count (INTEGER NOT NULL), created_at (TEXT NOT NULL)
- Index: session_id + created_at DESC compound

Use `CREATE TABLE IF NOT EXISTS` and `CREATE INDEX IF NOT EXISTS` for idempotency.
  </action>
  <verify>
The migration file exists and contains valid SQL. Run `sqlite3 :memory: < migrations/20260211_002_chat_and_memory.sql` to verify it parses (may need the bots table from initial migration first -- alternatively just verify syntax).
  </verify>
  <done>Migration creates all 5 tables with proper foreign keys, check constraints, and indexes matching the schema from research.</done>
</task>

<task type="auto">
  <name>Task 2: Implement SqliteChatRepository and SqliteMemoryRepository</name>
  <files>
    crates/boternity-infra/src/sqlite/chat.rs
    crates/boternity-infra/src/sqlite/memory.rs
    crates/boternity-infra/src/sqlite/mod.rs
  </files>
  <action>
Implement both repositories following the EXACT pattern of SqliteBotRepository in sqlite/bot.rs:
- Constructor takes `DatabasePool`
- Use `self.pool.writer()` for writes, `self.pool.reader()` for reads
- Use raw `sqlx::query()` with `.bind()` (not query_as! or macros)
- Private `*Row` structs for SQLite-to-domain mapping (matching the BotRow pattern)
- Implement the traits from boternity-core

**chat.rs -- SqliteChatRepository:**
- `struct SqliteChatRepository { pool: DatabasePool }`
- Private `ChatSessionRow` struct for SQLite mapping (all TEXT fields, convert to proper types)
- Private `ChatMessageRow` struct
- `impl ChatRepository for SqliteChatRepository` with all methods from the trait:
  - `create_session` -- INSERT into chat_sessions, return the session
  - `get_session` -- SELECT by id from reader pool
  - `update_session` -- UPDATE chat_sessions SET title, ended_at, total_input_tokens, total_output_tokens, message_count, status
  - `list_sessions` -- SELECT with bot_id filter, ORDER BY started_at DESC, LIMIT/OFFSET
  - `delete_session` -- DELETE by id (CASCADE deletes messages)
  - `get_active_sessions` -- SELECT WHERE bot_id = ? AND status = 'active'
  - `save_message` -- INSERT into chat_messages, also UPDATE chat_sessions SET message_count = message_count + 1
  - `get_messages` -- SELECT by session_id, ORDER BY created_at ASC, LIMIT/OFFSET
  - `get_message_count` -- SELECT COUNT(*) from chat_messages WHERE session_id = ?

**memory.rs -- SqliteMemoryRepository:**
- `struct SqliteMemoryRepository { pool: DatabasePool }`
- Private `MemoryEntryRow` struct
- Private `PendingExtractionRow` struct
- Private `ContextSummaryRow` struct
- `impl MemoryRepository for SqliteMemoryRepository` with all methods from the trait:
  - `save_memory` -- INSERT into session_memories
  - `get_memories` -- SELECT by bot_id, ORDER BY importance DESC, created_at DESC, LIMIT
  - `delete_memory` -- DELETE by id
  - `delete_all_memories` -- DELETE by bot_id, return affected rows count
  - `get_memories_by_session` -- SELECT by session_id
  - `save_pending_extraction` -- INSERT into pending_memory_extractions
  - `get_pending_extractions` -- SELECT by bot_id WHERE attempt_count < 3 (max retries)
  - `delete_pending_extraction` -- DELETE by id
  - `update_pending_extraction` -- UPDATE attempt_count, last_attempt_at, next_attempt_at, error_message
  - `save_context_summary` -- INSERT into context_summaries
  - `get_latest_summary` -- SELECT by session_id ORDER BY created_at DESC LIMIT 1

Row-to-domain conversion: Parse UUID strings with `Uuid::parse_str()`, parse ISO 8601 timestamps with `DateTime::parse_from_rfc3339()`, parse enum strings with `.parse()`. Handle conversion errors by mapping to RepositoryError::Database.

Update `sqlite/mod.rs` to add `pub mod chat; pub mod memory;`
  </action>
  <verify>
Run `cargo check -p boternity-infra` -- both repositories compile and implement their respective traits. Verify that writer pool is used for mutations and reader pool for queries.
  </verify>
  <done>SqliteChatRepository and SqliteMemoryRepository implement their traits with raw sqlx queries, split read/write pools, and private Row mapping structs. Migration creates all 5 tables.</done>
</task>

</tasks>

<verification>
1. `cargo check -p boternity-infra` passes
2. Migration file is valid SQL
3. SqliteChatRepository implements ChatRepository
4. SqliteMemoryRepository implements MemoryRepository
5. Write operations use pool.writer(), reads use pool.reader()
6. Row structs handle TEXT-to-domain type conversion (UUID, DateTime, enums)
7. Foreign keys with ON DELETE CASCADE maintain referential integrity
</verification>

<success_criteria>
- Migration creates chat_sessions, chat_messages, session_memories, pending_memory_extractions, context_summaries tables
- SqliteChatRepository provides full session and message CRUD
- SqliteMemoryRepository provides memory storage, retrieval, pending extraction queue, and context summaries
- All methods follow existing SqliteBotRepository patterns (raw sqlx, split pools, Row mapping)
- `cargo check --workspace` passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-single-agent-chat-llm/02-04-SUMMARY.md`
</output>
