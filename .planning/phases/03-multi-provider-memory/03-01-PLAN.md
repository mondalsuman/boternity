---
phase: 03-multi-provider-memory
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/boternity-types/src/llm.rs
  - crates/boternity-types/src/memory.rs
  - crates/boternity-types/src/storage.rs
  - crates/boternity-types/src/lib.rs
  - crates/boternity-core/src/llm/mod.rs
  - crates/boternity-core/src/llm/health.rs
  - crates/boternity-core/src/llm/fallback.rs
  - crates/boternity-core/src/llm/registry.rs
  - crates/boternity-core/src/memory/mod.rs
  - crates/boternity-core/src/memory/vector.rs
  - crates/boternity-core/src/memory/shared.rs
  - crates/boternity-core/src/memory/embedder.rs
  - crates/boternity-core/src/storage/mod.rs
  - crates/boternity-core/src/storage/file_store.rs
  - crates/boternity-core/src/storage/kv_store.rs
  - crates/boternity-core/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "All Phase 3 domain types compile and are re-exported from boternity-types"
    - "All Phase 3 core traits compile and are re-exported from boternity-core"
    - "No boternity-core dependency on boternity-infra (dependency inversion preserved)"
  artifacts:
    - path: "crates/boternity-types/src/llm.rs"
      provides: "ProviderConfig, FallbackChainConfig, ProviderCostInfo"
      contains: "FallbackChainConfig"
    - path: "crates/boternity-types/src/memory.rs"
      provides: "VectorMemoryEntry, SharedMemoryEntry, TrustLevel, MemoryAuditEntry, AuditAction"
      contains: "TrustLevel"
    - path: "crates/boternity-types/src/storage.rs"
      provides: "StorageFile, FileVersion, KvEntry, FileChunk"
      contains: "StorageFile"
    - path: "crates/boternity-core/src/llm/health.rs"
      provides: "CircuitState, ProviderHealth"
      contains: "CircuitState"
    - path: "crates/boternity-core/src/memory/vector.rs"
      provides: "VectorMemoryStore trait"
      contains: "VectorMemoryStore"
    - path: "crates/boternity-core/src/memory/shared.rs"
      provides: "SharedMemoryStore trait"
      contains: "SharedMemoryStore"
    - path: "crates/boternity-core/src/storage/kv_store.rs"
      provides: "KvStore trait"
      contains: "KvStore"
  key_links:
    - from: "crates/boternity-core/src/memory/vector.rs"
      to: "crates/boternity-types/src/memory.rs"
      via: "imports VectorMemoryEntry"
      pattern: "use boternity_types::memory::VectorMemoryEntry"
    - from: "crates/boternity-core/src/llm/health.rs"
      to: "crates/boternity-types/src/llm.rs"
      via: "imports LlmError for error classification"
      pattern: "use boternity_types::llm::LlmError"
---

<objective>
Define all Phase 3 domain types and core trait abstractions.

Purpose: Establish the type foundation and trait contracts that all Phase 3 implementation plans depend on. This follows the project's types -> core -> infra -> api dependency chain.
Output: Extended types in boternity-types, new traits in boternity-core for vector memory, shared memory, embedder, file storage, KV store, provider health, fallback chain, and provider registry.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-multi-provider-memory/03-RESEARCH.md
@.planning/phases/03-multi-provider-memory/03-CONTEXT.md
@crates/boternity-types/src/llm.rs
@crates/boternity-types/src/memory.rs
@crates/boternity-types/src/lib.rs
@crates/boternity-core/src/llm/mod.rs
@crates/boternity-core/src/llm/provider.rs
@crates/boternity-core/src/memory/store.rs
@crates/boternity-core/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend domain types in boternity-types</name>
  <files>
    crates/boternity-types/src/llm.rs
    crates/boternity-types/src/memory.rs
    crates/boternity-types/src/storage.rs
    crates/boternity-types/src/lib.rs
  </files>
  <action>
Extend `llm.rs` with these new types (ADD to existing, do NOT modify existing types):

1. `ProviderConfig` struct:
   - `name: String` (e.g., "openai", "gemini", "mistral", "glm", "bedrock", "anthropic", "claude_subscription")
   - `provider_type: ProviderType` enum (Anthropic, Bedrock, OpenAiCompatible, ClaudeSubscription)
   - `api_key_secret_name: Option<String>` (reference to secret in vault)
   - `base_url: Option<String>` (override default)
   - `model: String`
   - `priority: u32` (for fallback ordering; lower = higher priority)
   - `enabled: bool`
   - `capabilities: ProviderCapabilities` (reuse existing type)

2. `FallbackChainConfig` struct:
   - `providers: Vec<ProviderConfig>`
   - `rate_limit_queue_timeout_ms: u64` (default 5000, per user decision)
   - `cost_warning_multiplier: f64` (default 3.0, per user decision: warn if fallback >3x primary)

3. `ProviderCostInfo` struct:
   - `provider_name: String`
   - `model: String`
   - `input_cost_per_million: f64`
   - `output_cost_per_million: f64`

4. `ProviderStatusInfo` struct:
   - `name: String`
   - `circuit_state: String` ("closed", "open", "half_open")
   - `last_error: Option<String>`
   - `last_success_ago: Option<String>` (human-readable like "2m ago")
   - `total_calls: u64`
   - `total_failures: u64`
   - `uptime_since: Option<String>` (ISO 8601)

5. `ProviderType` enum: Anthropic, Bedrock, OpenAiCompatible, ClaudeSubscription
   - Derive Debug, Clone, PartialEq, Eq, Serialize, Deserialize
   - Add Display + FromStr impls (snake_case: "anthropic", "bedrock", "openai_compatible", "claude_subscription")

Extend `memory.rs` with these new types (ADD to existing, preserve MemoryEntry and all existing types):

1. `TrustLevel` enum: Public, Trusted, Private
   - Derive Debug, Clone, PartialEq, Eq, Serialize, Deserialize
   - Display + FromStr (lowercase: "public", "trusted", "private")
   - Default impl returns Private (per user decision: private by default)

2. `VectorMemoryEntry` struct:
   - `id: Uuid`
   - `bot_id: Uuid`
   - `fact: String`
   - `category: MemoryCategory` (reuse existing)
   - `importance: u8`
   - `session_id: Option<Uuid>` (None for manual memories)
   - `source_memory_id: Option<Uuid>` (links back to SQLite MemoryEntry)
   - `embedding_model: String`
   - `created_at: DateTime<Utc>`
   - `last_accessed_at: Option<DateTime<Utc>>`
   - `access_count: u32`

3. `SharedMemoryEntry` struct:
   - `id: Uuid`
   - `fact: String`
   - `category: MemoryCategory`
   - `importance: u8`
   - `author_bot_id: Uuid`
   - `author_bot_name: String`
   - `trust_level: TrustLevel`
   - `embedding_model: String`
   - `write_hash: String` (SHA-256 tamper detection)
   - `created_at: DateTime<Utc>`

4. `MemoryAuditEntry` struct:
   - `id: Uuid`
   - `bot_id: Uuid`
   - `memory_id: Uuid`
   - `action: AuditAction`
   - `actor: String` ("system", "user", or bot slug)
   - `details: Option<String>` (JSON context)
   - `created_at: DateTime<Utc>`

5. `AuditAction` enum: Add, Delete, Share, Revoke, Merge
   - Derive Debug, Clone, PartialEq, Eq, Serialize, Deserialize
   - Display + FromStr (lowercase)

6. `RankedMemory` struct:
   - `entry: VectorMemoryEntry`
   - `relevance_score: f32`
   - `distance: f32` (raw cosine distance)
   - `provenance: Option<String>` (e.g., "Written by BotX" for shared memories)

Create NEW `storage.rs`:

1. `StorageFile` struct:
   - `id: Uuid`
   - `bot_id: Uuid`
   - `filename: String`
   - `mime_type: String`
   - `size_bytes: u64`
   - `version: u32`
   - `is_indexed: bool` (whether text content has been chunked and embedded)
   - `created_at: DateTime<Utc>`
   - `updated_at: DateTime<Utc>`

2. `FileVersion` struct:
   - `id: Uuid`
   - `file_id: Uuid`
   - `version: u32`
   - `size_bytes: u64`
   - `created_at: DateTime<Utc>`

3. `FileChunk` struct:
   - `chunk_id: Uuid`
   - `file_id: Uuid`
   - `bot_id: Uuid`
   - `filename: String`
   - `chunk_index: u32`
   - `chunk_text: String`
   - `embedding_model: String`

4. `KvEntry` struct:
   - `bot_id: Uuid`
   - `key: String`
   - `value: serde_json::Value`
   - `created_at: DateTime<Utc>`
   - `updated_at: DateTime<Utc>`

5. `const MAX_FILE_SIZE_BYTES: u64 = 50 * 1024 * 1024;` (50MB per user decision)

Update `lib.rs` to add `pub mod storage;`

Add basic unit tests for enum roundtrips (Display/FromStr, serde) for TrustLevel, AuditAction, ProviderType.
  </action>
  <verify>`cargo test -p boternity-types` passes. `cargo check -p boternity-types` compiles cleanly.</verify>
  <done>All Phase 3 domain types compile, serialize/deserialize correctly, and are exported from boternity-types.</done>
</task>

<task type="auto">
  <name>Task 2: Define core traits in boternity-core</name>
  <files>
    crates/boternity-core/src/llm/mod.rs
    crates/boternity-core/src/llm/health.rs
    crates/boternity-core/src/llm/fallback.rs
    crates/boternity-core/src/llm/registry.rs
    crates/boternity-core/src/memory/mod.rs
    crates/boternity-core/src/memory/vector.rs
    crates/boternity-core/src/memory/shared.rs
    crates/boternity-core/src/memory/embedder.rs
    crates/boternity-core/src/storage/mod.rs
    crates/boternity-core/src/storage/file_store.rs
    crates/boternity-core/src/storage/kv_store.rs
    crates/boternity-core/src/lib.rs
  </files>
  <action>
Create new modules in boternity-core. All traits use RPITIT (native async fn, no async_trait -- per project pattern).

**llm/health.rs** -- Provider health tracking types (these are types in core, not infra, because FallbackChain uses them):
1. `CircuitState` enum: Closed { consecutive_failures: u32 }, Open { opened_at: Instant, wait_duration: Duration }, HalfOpen
   - Derive Debug, Clone
2. `ProviderHealth` struct with fields from RESEARCH.md Pattern 4:
   - name, priority, state, last_error, last_success, last_latency_ms, total_calls, total_failures, uptime_since
   - failure_threshold (default 3), success_threshold (default 1), open_duration (default 30s)
   - rate_limit_until: Option<Instant>
3. Implement `ProviderHealth::new(name, priority)` with defaults
4. `is_available(&mut self) -> bool` -- checks rate limit and circuit state
5. `record_success(&mut self)` -- update state on success
6. `record_failure(&mut self, error: &LlmError)` -- update state on failure
7. `set_rate_limited(&mut self, retry_after_ms: Option<u64>, max_wait_ms: u64)`
8. `is_failover_error(error: &LlmError) -> bool` -- static method, classify which errors trigger failover (Provider, Stream, RateLimited, Overloaded = yes; AuthenticationFailed, InvalidRequest, ContextLengthExceeded = no)
9. `to_status_info(&self) -> ProviderStatusInfo` -- for CLI display

**llm/fallback.rs** -- FallbackChain stub (trait/struct definition only, full logic in Plan 03-03):
1. Define `FallbackChain` struct: `providers: Vec<(ProviderHealth, BoxLlmProvider)>`, `cost_table: HashMap<String, ProviderCostInfo>`, `primary_provider_name: String`, `rate_limit_queue_timeout_ms: u64`, `cost_warning_multiplier: f64`
2. `FallbackChain::new(config: FallbackChainConfig, providers: Vec<BoxLlmProvider>, cost_table: HashMap<String, ProviderCostInfo>) -> Self`
3. `health_status(&self) -> Vec<ProviderStatusInfo>` -- for provider CLI
4. Stub `complete` and `stream` methods with todo!() -- implementation in Plan 03-03

**llm/registry.rs** -- Provider registry:
1. `ProviderRegistry` struct: HashMap<String, BoxLlmProvider>
2. Methods: `register(name, provider)`, `get(name) -> Option<&BoxLlmProvider>`, `list_names() -> Vec<&str>`

**memory/vector.rs** -- VectorMemoryStore trait:
1. `VectorMemoryStore: Send + Sync` trait with RPITIT:
   - `search(&self, bot_id: &Uuid, query_embedding: &[f32], limit: usize, min_similarity: f32) -> Result<Vec<RankedMemory>, RepositoryError>`
   - `add(&self, entry: &VectorMemoryEntry, embedding: &[f32]) -> Result<(), RepositoryError>`
   - `delete(&self, bot_id: &Uuid, memory_id: &Uuid) -> Result<(), RepositoryError>`
   - `delete_all(&self, bot_id: &Uuid) -> Result<u64, RepositoryError>`
   - `count(&self, bot_id: &Uuid) -> Result<u64, RepositoryError>`
   - `check_duplicate(&self, bot_id: &Uuid, embedding: &[f32], threshold: f32) -> Result<Option<VectorMemoryEntry>, RepositoryError>`
   - `get_all_for_reembedding(&self, bot_id: &Uuid, current_model: &str) -> Result<Vec<VectorMemoryEntry>, RepositoryError>` -- returns entries with mismatched embedding_model
   - `update_embedding(&self, memory_id: &Uuid, new_embedding: &[f32], model_name: &str) -> Result<(), RepositoryError>`

**memory/shared.rs** -- SharedMemoryStore trait:
1. `SharedMemoryStore: Send + Sync` trait with RPITIT:
   - `add(&self, entry: &SharedMemoryEntry, embedding: &[f32]) -> Result<(), RepositoryError>`
   - `search(&self, reading_bot_id: &Uuid, trusted_bot_ids: &[Uuid], query_embedding: &[f32], limit: usize, min_similarity: f32) -> Result<Vec<RankedMemory>, RepositoryError>`
   - `delete(&self, memory_id: &Uuid, author_bot_id: &Uuid) -> Result<(), RepositoryError>` -- only author can delete
   - `share(&self, memory_id: &Uuid, trust_level: TrustLevel) -> Result<(), RepositoryError>`
   - `revoke(&self, memory_id: &Uuid, author_bot_id: &Uuid) -> Result<(), RepositoryError>` -- sets back to Private
   - `count_by_author(&self, author_bot_id: &Uuid) -> Result<u64, RepositoryError>` -- for per-bot cap enforcement
   - `verify_integrity(&self, memory_id: &Uuid) -> Result<bool, RepositoryError>` -- check SHA-256 hash

**memory/embedder.rs** -- Embedder trait:
1. `Embedder: Send + Sync` trait:
   - `embed(&self, texts: &[String]) -> impl Future<Output = Result<Vec<Vec<f32>>, RepositoryError>> + Send`
   - `model_name(&self) -> &str`
   - `dimension(&self) -> usize`

**storage/file_store.rs** -- FileStore trait:
1. `FileStore: Send + Sync` trait with RPITIT:
   - `save_file(&self, bot_id: &Uuid, filename: &str, data: &[u8]) -> Result<StorageFile, RepositoryError>`
   - `get_file(&self, bot_id: &Uuid, filename: &str) -> Result<Vec<u8>, RepositoryError>`
   - `delete_file(&self, bot_id: &Uuid, filename: &str) -> Result<(), RepositoryError>`
   - `list_files(&self, bot_id: &Uuid) -> Result<Vec<StorageFile>, RepositoryError>`
   - `get_file_info(&self, bot_id: &Uuid, filename: &str) -> Result<StorageFile, RepositoryError>`
   - `get_versions(&self, file_id: &Uuid) -> Result<Vec<FileVersion>, RepositoryError>`

**storage/kv_store.rs** -- KvStore trait (per RESEARCH.md Pattern 10):
1. `KvStore: Send + Sync` trait with RPITIT:
   - `get(&self, bot_id: &Uuid, key: &str) -> Result<Option<serde_json::Value>, RepositoryError>`
   - `set(&self, bot_id: &Uuid, key: &str, value: &serde_json::Value) -> Result<(), RepositoryError>`
   - `delete(&self, bot_id: &Uuid, key: &str) -> Result<(), RepositoryError>`
   - `list_keys(&self, bot_id: &Uuid) -> Result<Vec<String>, RepositoryError>`
   - `get_entry(&self, bot_id: &Uuid, key: &str) -> Result<Option<KvEntry>, RepositoryError>` -- includes timestamps

Update `llm/mod.rs`: add `pub mod health; pub mod fallback; pub mod registry;`
Update `memory/mod.rs`: add `pub mod vector; pub mod shared; pub mod embedder;`
Create `storage/mod.rs`: add `pub mod file_store; pub mod kv_store;`
Update `lib.rs`: add `pub mod storage;`

IMPORTANT: boternity-core must NOT depend on boternity-infra. All traits use only types from boternity-types, std, uuid, chrono, serde_json.
  </action>
  <verify>`cargo check -p boternity-core` compiles cleanly. `cargo check -p boternity-types` still passes. Verify no boternity-infra in `crates/boternity-core/Cargo.toml`.</verify>
  <done>All Phase 3 core traits compile, follow RPITIT pattern, and are exported from boternity-core. Dependency inversion preserved.</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles successfully
- `cargo test -p boternity-types` passes (enum roundtrip tests)
- `grep -r "boternity-infra" crates/boternity-core/Cargo.toml` returns nothing
- All new types are re-exported from crate roots
</verification>

<success_criteria>
All Phase 3 domain types and core trait abstractions compile cleanly. Types are serializable. Traits use RPITIT pattern. Core has zero dependency on infra.
</success_criteria>

<output>
After completion, create `.planning/phases/03-multi-provider-memory/03-01-SUMMARY.md`
</output>
