---
phase: 03-multi-provider-memory
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - crates/boternity-core/src/llm/health.rs
  - crates/boternity-core/src/llm/fallback.rs
autonomous: true

must_haves:
  truths:
    - "FallbackChain tries providers in priority order and fails over on transient errors"
    - "Circuit breaker transitions through Closed -> Open -> HalfOpen states correctly"
    - "Rate-limited requests queue for up to 5 seconds before failover"
    - "Cost warnings emitted when fallback costs >3x primary"
    - "Capability downgrade warnings emitted when fallback model is weaker"
    - "Auth errors and invalid requests do NOT trigger failover"
  artifacts:
    - path: "crates/boternity-core/src/llm/fallback.rs"
      provides: "FallbackChain with complete() and stream() methods"
      contains: "pub async fn complete"
    - path: "crates/boternity-core/src/llm/health.rs"
      provides: "ProviderHealth with circuit breaker state machine"
      contains: "CircuitState"
  key_links:
    - from: "crates/boternity-core/src/llm/fallback.rs"
      to: "crates/boternity-core/src/llm/health.rs"
      via: "uses ProviderHealth for each provider"
      pattern: "ProviderHealth"
    - from: "crates/boternity-core/src/llm/fallback.rs"
      to: "crates/boternity-core/src/llm/box_provider.rs"
      via: "wraps BoxLlmProvider instances"
      pattern: "BoxLlmProvider"
---

<objective>
Implement the circuit breaker state machine and fallback chain logic.

Purpose: Enable automatic failover between providers when one is down or rate-limited. This covers LLMP-09 (configurable fallback chain) and LLMP-10 (automatic failover).
Output: Working FallbackChain that wraps multiple BoxLlmProviders with per-provider health tracking, rate limit queuing, cost warnings, and capability downgrade warnings.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-multi-provider-memory/03-RESEARCH.md
@.planning/phases/03-multi-provider-memory/03-CONTEXT.md
@.planning/phases/03-multi-provider-memory/03-01-SUMMARY.md
@crates/boternity-core/src/llm/health.rs
@crates/boternity-core/src/llm/fallback.rs
@crates/boternity-core/src/llm/box_provider.rs
@crates/boternity-types/src/llm.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Complete circuit breaker state machine in ProviderHealth</name>
  <files>crates/boternity-core/src/llm/health.rs</files>
  <action>
The Plan 03-01 created ProviderHealth with basic structure. Now implement the full state machine logic:

1. `record_success(&mut self)`:
   - If Closed: reset consecutive_failures to 0
   - If HalfOpen: transition to Closed, set uptime_since to now
   - Update last_success to now, increment total_calls

2. `record_failure(&mut self, error: &LlmError)`:
   - Increment total_failures and total_calls
   - Set last_error to error.to_string()
   - If Closed: increment consecutive_failures. If >= failure_threshold -> transition to Open { opened_at: now, wait_duration: open_duration }
   - If HalfOpen: transition to Open immediately (probe failed)

3. `is_available(&mut self) -> bool` (already stubbed):
   - Check rate_limit_until first -- if now < until, return false. If expired, clear it.
   - Closed -> true
   - Open -> check if opened_at.elapsed() >= wait_duration. If yes, transition to HalfOpen, return true. If no, return false.
   - HalfOpen -> true (allow probe request)

4. `set_rate_limited(&mut self, retry_after_ms: Option<u64>, max_wait_ms: u64)`:
   - Set rate_limit_until to now + min(retry_after_ms.unwrap_or(1000), max_wait_ms)

5. `is_failover_error(error: &LlmError) -> bool`:
   - Match: Provider, Stream, RateLimited, Overloaded -> true (failover)
   - Match: AuthenticationFailed, InvalidRequest, ContextLengthExceeded -> false (user/config error)

6. `to_status_info(&self) -> ProviderStatusInfo`:
   - Map CircuitState to string ("closed", "open", "half_open")
   - Format last_success as human-readable duration ago
   - Format uptime_since as ISO 8601

Add unit tests:
- Test Closed -> Open transition after 3 failures
- Test Open -> HalfOpen transition after timeout
- Test HalfOpen -> Closed on success
- Test HalfOpen -> Open on failure (probe failed)
- Test is_failover_error classification
- Test rate_limit_until expiry
  </action>
  <verify>`cargo test -p boternity-core` passes. All circuit breaker state transitions tested.</verify>
  <done>Circuit breaker state machine complete with all transitions, rate limit queuing, and error classification.</done>
</task>

<task type="auto">
  <name>Task 2: Implement FallbackChain complete() and stream()</name>
  <files>crates/boternity-core/src/llm/fallback.rs</files>
  <action>
Replace the todo!() stubs from Plan 03-01 with full implementation:

1. `pub async fn complete(&mut self, request: &CompletionRequest) -> Result<(CompletionResponse, String, Option<String>), LlmError>`:
   - Sort providers by priority (lower number = higher priority, ties broken by last_latency_ms then provider name)
   - For each provider:
     - Check `health.is_available()`. If not available, skip.
     - If rate-limited but within queue timeout: `tokio::time::sleep` for remaining rate_limit_until duration, then retry
     - Call `provider.complete(request).await`
     - On success: `health.record_success()`, record latency, build failover_warning if not primary provider
     - On failure: check `ProviderHealth::is_failover_error()`. If yes: `health.record_failure()`, continue to next. If no: return error immediately (don't failover on auth/config errors).
   - Build `failover_warning` string if we fell back:
     - Include "Switched to {provider_name}" message
     - If fallback provider capabilities are weaker (lower max_context or max_output): append capability warning per CONTEXT.md ("Running on a smaller model -- responses may be less detailed")
     - Check cost table: if fallback cost > cost_warning_multiplier * primary cost: append cost warning ("Note: {provider_name} costs ~{X}x more than {primary_name}")
   - If ALL providers exhausted: return `LlmError::Provider { message: "All providers in fallback chain are unavailable. Run `bnity provider status` for details." }` per user decision

2. `pub fn stream(&mut self, request: CompletionRequest) -> Pin<Box<dyn Stream<Item = Result<StreamEvent, LlmError>> + Send>>`:
   - Same provider selection logic as complete()
   - Try first available provider's stream()
   - On stream error during iteration: cannot retry mid-stream. Emit error event.
   - Use async_stream::stream! for the fallback logic since we need to try providers before committing to a stream
   - Emit failover_warning as first event metadata if applicable (or return it via a separate method)

3. `pub fn primary_available(&mut self) -> bool`:
   - Check if the primary provider (first by priority) is available. Used for auto-switch-back per user decision.

4. `pub fn health_status(&self) -> Vec<ProviderStatusInfo>`:
   - Map all providers to their ProviderHealth::to_status_info()

Add unit test with mock providers:
- Test happy path: primary succeeds, no failover
- Test failover: primary fails with Provider error, secondary succeeds, returns warning
- Test no failover on auth error: primary returns AuthenticationFailed, error returned immediately
- Test all providers down: returns clear error message
- Test cost warning: fallback >3x more expensive
  </action>
  <verify>`cargo test -p boternity-core` passes. All fallback chain scenarios tested.</verify>
  <done>FallbackChain correctly tries providers in priority order, handles rate limiting, emits cost/capability warnings, and returns clear errors when all providers are down.</done>
</task>

</tasks>

<verification>
- `cargo test -p boternity-core` passes
- `cargo check --workspace` compiles
- Circuit breaker state machine has full test coverage
- Fallback chain tested with mock providers for all scenarios
</verification>

<success_criteria>
Circuit breaker transitions correctly through Closed/Open/HalfOpen states. FallbackChain tries providers in priority order, respects rate limits, warns on cost/capability downgrades, and gives clear errors when all providers are down.
</success_criteria>

<output>
After completion, create `.planning/phases/03-multi-provider-memory/03-03-SUMMARY.md`
</output>
