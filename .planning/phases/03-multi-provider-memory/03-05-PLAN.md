---
phase: 03-multi-provider-memory
plan: 05
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - crates/boternity-infra/src/sqlite/mod.rs
  - crates/boternity-infra/src/sqlite/kv.rs
  - crates/boternity-infra/src/sqlite/audit.rs
  - crates/boternity-infra/src/sqlite/provider_health.rs
  - crates/boternity-infra/src/sqlite/file_metadata.rs
autonomous: true

must_haves:
  truths:
    - "New SQLite migrations run successfully (KV store, audit log, provider health, file metadata)"
    - "SqliteKvStore implements KvStore trait with JSON value support"
    - "Memory audit log records add/delete/share/revoke/merge actions"
    - "Provider health state persists across restarts"
    - "File metadata tracks versions and indexing status"
  artifacts:
    - path: "crates/boternity-infra/src/sqlite/kv.rs"
      provides: "SqliteKvStore implementing KvStore trait"
      contains: "SqliteKvStore"
    - path: "crates/boternity-infra/src/sqlite/audit.rs"
      provides: "SqliteAuditLog for memory audit trail"
      contains: "SqliteAuditLog"
    - path: "crates/boternity-infra/src/sqlite/provider_health.rs"
      provides: "SqliteProviderHealthStore for persistent provider state"
      contains: "SqliteProviderHealthStore"
    - path: "crates/boternity-infra/src/sqlite/file_metadata.rs"
      provides: "SqliteFileMetadataStore for file storage metadata"
      contains: "SqliteFileMetadataStore"
  key_links:
    - from: "crates/boternity-infra/src/sqlite/kv.rs"
      to: "crates/boternity-core/src/storage/kv_store.rs"
      via: "implements KvStore trait"
      pattern: "impl KvStore for SqliteKvStore"
---

<objective>
Create SQLite migrations and implementations for KV store, memory audit log, provider health persistence, and file metadata.

Purpose: All relational data for Phase 3 features lives in SQLite alongside existing Phase 1/2 tables. This plan adds the necessary tables and implementations for structured data that does NOT belong in LanceDB (KV pairs, audit trails, file metadata, provider health state).
Output: Four new SQLite table implementations with full CRUD operations and migrations.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-multi-provider-memory/03-RESEARCH.md
@.planning/phases/03-multi-provider-memory/03-CONTEXT.md
@.planning/phases/03-multi-provider-memory/03-01-SUMMARY.md
@crates/boternity-core/src/storage/kv_store.rs
@crates/boternity-infra/src/sqlite/mod.rs
@crates/boternity-infra/src/sqlite/pool.rs
@crates/boternity-infra/src/sqlite/memory.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQLite migrations for Phase 3 tables</name>
  <files>
    crates/boternity-infra/src/sqlite/pool.rs
  </files>
  <action>
Add new CREATE TABLE statements to the migration function in pool.rs (where existing Phase 1/2 migrations live). Add these after existing tables:

1. **bot_kv_store** (per RESEARCH.md Pattern 10):
```sql
CREATE TABLE IF NOT EXISTS bot_kv_store (
    bot_id     TEXT NOT NULL REFERENCES bots(id) ON DELETE CASCADE,
    key        TEXT NOT NULL,
    value      TEXT NOT NULL,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    PRIMARY KEY (bot_id, key)
);
CREATE INDEX IF NOT EXISTS idx_kv_bot_id ON bot_kv_store(bot_id);
```

2. **memory_audit_log** (per RESEARCH.md Pattern 11):
```sql
CREATE TABLE IF NOT EXISTS memory_audit_log (
    id         TEXT PRIMARY KEY NOT NULL,
    bot_id     TEXT NOT NULL,
    memory_id  TEXT NOT NULL,
    action     TEXT NOT NULL CHECK (action IN ('add', 'delete', 'share', 'revoke', 'merge')),
    actor      TEXT NOT NULL,
    details    TEXT,
    created_at TEXT NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_audit_bot ON memory_audit_log(bot_id, created_at DESC);
```

3. **provider_health** (persist circuit breaker state across restarts):
```sql
CREATE TABLE IF NOT EXISTS provider_health (
    name           TEXT PRIMARY KEY NOT NULL,
    circuit_state  TEXT NOT NULL DEFAULT 'closed',
    last_error     TEXT,
    last_success   TEXT,
    total_calls    INTEGER NOT NULL DEFAULT 0,
    total_failures INTEGER NOT NULL DEFAULT 0,
    uptime_since   TEXT,
    updated_at     TEXT NOT NULL
);
```

4. **bot_files** (file metadata for per-bot storage):
```sql
CREATE TABLE IF NOT EXISTS bot_files (
    id         TEXT PRIMARY KEY NOT NULL,
    bot_id     TEXT NOT NULL REFERENCES bots(id) ON DELETE CASCADE,
    filename   TEXT NOT NULL,
    mime_type  TEXT NOT NULL DEFAULT 'application/octet-stream',
    size_bytes INTEGER NOT NULL,
    version    INTEGER NOT NULL DEFAULT 1,
    is_indexed INTEGER NOT NULL DEFAULT 0,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    UNIQUE(bot_id, filename)
);
CREATE INDEX IF NOT EXISTS idx_files_bot ON bot_files(bot_id);
```

5. **bot_file_versions** (version history):
```sql
CREATE TABLE IF NOT EXISTS bot_file_versions (
    id         TEXT PRIMARY KEY NOT NULL,
    file_id    TEXT NOT NULL REFERENCES bot_files(id) ON DELETE CASCADE,
    version    INTEGER NOT NULL,
    size_bytes INTEGER NOT NULL,
    created_at TEXT NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_file_versions ON bot_file_versions(file_id, version DESC);
```
  </action>
  <verify>Application starts successfully with new migrations. `cargo test -p boternity-infra` passes (existing SQLite tests still work).</verify>
  <done>All Phase 3 SQLite tables created with proper indexes, foreign keys, and constraints.</done>
</task>

<task type="auto">
  <name>Task 2: Implement KV store, audit log, provider health, and file metadata repositories</name>
  <files>
    crates/boternity-infra/src/sqlite/kv.rs
    crates/boternity-infra/src/sqlite/audit.rs
    crates/boternity-infra/src/sqlite/provider_health.rs
    crates/boternity-infra/src/sqlite/file_metadata.rs
    crates/boternity-infra/src/sqlite/mod.rs
  </files>
  <action>
Create four new repository implementations following existing patterns in sqlite/ (see memory.rs and bot.rs for style):

**sqlite/kv.rs** -- `SqliteKvStore`:
- `new(pool: DatabasePool) -> Self`
- Implement KvStore trait:
  - `get(bot_id, key)` -> SELECT value FROM bot_kv_store WHERE bot_id = ? AND key = ?; parse JSON
  - `set(bot_id, key, value)` -> INSERT OR REPLACE with serde_json::to_string(value), set updated_at
  - `delete(bot_id, key)` -> DELETE FROM bot_kv_store WHERE bot_id = ? AND key = ?
  - `list_keys(bot_id)` -> SELECT key FROM bot_kv_store WHERE bot_id = ? ORDER BY key
  - `get_entry(bot_id, key)` -> SELECT * and map to KvEntry

**sqlite/audit.rs** -- `SqliteAuditLog`:
- `new(pool: DatabasePool) -> Self`
- Methods (not a trait -- used directly by infra layer):
  - `log(entry: &MemoryAuditEntry) -> Result<(), RepositoryError>` -> INSERT
  - `get_for_bot(bot_id, limit) -> Result<Vec<MemoryAuditEntry>, RepositoryError>` -> SELECT ORDER BY created_at DESC LIMIT ?
  - `get_for_memory(memory_id) -> Result<Vec<MemoryAuditEntry>, RepositoryError>` -> SELECT WHERE memory_id = ?

**sqlite/provider_health.rs** -- `SqliteProviderHealthStore`:
- `new(pool: DatabasePool) -> Self`
- Methods:
  - `save(name, circuit_state, last_error, last_success, total_calls, total_failures, uptime_since)` -> INSERT OR REPLACE
  - `load(name) -> Result<Option<ProviderHealthRow>, RepositoryError>` -- returns raw row data, caller reconstructs ProviderHealth
  - `load_all() -> Result<Vec<ProviderHealthRow>, RepositoryError>`
  - Define `ProviderHealthRow` struct for DB mapping (private, like BotRow pattern)

**sqlite/file_metadata.rs** -- `SqliteFileMetadataStore`:
- `new(pool: DatabasePool) -> Self`
- Methods:
  - `save_file(file: &StorageFile)` -> INSERT
  - `update_file(file: &StorageFile)` -> UPDATE (for version bump, is_indexed change)
  - `get_file(bot_id, filename)` -> SELECT WHERE bot_id = ? AND filename = ?
  - `get_file_by_id(file_id)` -> SELECT WHERE id = ?
  - `list_files(bot_id)` -> SELECT WHERE bot_id = ? ORDER BY filename
  - `delete_file(bot_id, filename)` -> DELETE (CASCADE handles versions)
  - `save_version(version: &FileVersion)` -> INSERT
  - `get_versions(file_id)` -> SELECT WHERE file_id = ? ORDER BY version DESC

Update `sqlite/mod.rs`: add `pub mod kv; pub mod audit; pub mod provider_health; pub mod file_metadata;`

Add unit tests for SqliteKvStore (most important since it implements a core trait):
- Test set/get roundtrip with JSON object value
- Test set/get with JSON array value
- Test delete removes entry
- Test list_keys returns sorted keys
- Test get returns None for missing key
  </action>
  <verify>`cargo test -p boternity-infra` passes. KV store roundtrip tests green.</verify>
  <done>All four SQLite repository implementations complete with CRUD operations. KV store implements core KvStore trait.</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- `cargo test -p boternity-infra` passes
- SQLite tables created on startup
- KV store handles JSON objects, arrays, and nested structures
- Audit log records actions with proper timestamps
</verification>

<success_criteria>
All Phase 3 SQLite tables exist with proper schema. KV store implements KvStore trait with full CRUD. Audit log, provider health, and file metadata stores operational.
</success_criteria>

<output>
After completion, create `.planning/phases/03-multi-provider-memory/03-05-SUMMARY.md`
</output>
