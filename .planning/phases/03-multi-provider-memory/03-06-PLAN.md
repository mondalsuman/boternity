---
phase: 03-multi-provider-memory
plan: 06
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - crates/boternity-infra/src/llm/openai_compat/mod.rs
  - crates/boternity-infra/src/llm/claude_sub/mod.rs
  - crates/boternity-infra/src/llm/mod.rs
  - crates/boternity-core/src/llm/registry.rs
  - crates/boternity-api/src/state.rs
  - crates/boternity-api/src/cli/chat/loop_runner.rs
autonomous: true

must_haves:
  truths:
    - "Claude subscription provider exists behind experimental flag and warns about ToS"
    - "Provider registry holds all configured providers for lookup"
    - "FallbackChain is wired into the chat flow replacing single BoxLlmProvider"
    - "Failover events print to stderr during chat per user decision"
    - "Auto-switch-back to primary provider when it recovers"
    - "Connection test runs when a new provider is configured"
  artifacts:
    - path: "crates/boternity-infra/src/llm/claude_sub/mod.rs"
      provides: "ClaudeSubscriptionProvider (experimental)"
      contains: "ClaudeSubscriptionProvider"
    - path: "crates/boternity-api/src/state.rs"
      provides: "FallbackChain integrated into AppState"
      contains: "FallbackChain"
  key_links:
    - from: "crates/boternity-api/src/state.rs"
      to: "crates/boternity-core/src/llm/fallback.rs"
      via: "AppState holds FallbackChain"
      pattern: "FallbackChain"
    - from: "crates/boternity-api/src/cli/chat/loop_runner.rs"
      to: "crates/boternity-core/src/llm/fallback.rs"
      via: "Chat uses FallbackChain instead of single provider"
      pattern: "fallback"
---

<objective>
Wire the Claude subscription provider, provider registry, and fallback chain into the application.

Purpose: Connect the provider infrastructure to the actual chat flow so bots can use multiple providers with automatic failover. This completes the provider integration path: providers -> registry -> fallback chain -> chat.
Output: ClaudeSubscriptionProvider (experimental), provider registry, FallbackChain in AppState, failover stderr output in chat.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-multi-provider-memory/03-RESEARCH.md
@.planning/phases/03-multi-provider-memory/03-CONTEXT.md
@.planning/phases/03-multi-provider-memory/03-02-SUMMARY.md
@.planning/phases/03-multi-provider-memory/03-03-SUMMARY.md
@crates/boternity-api/src/state.rs
@crates/boternity-api/src/cli/chat/loop_runner.rs
@crates/boternity-core/src/llm/fallback.rs
@crates/boternity-core/src/llm/registry.rs
@crates/boternity-infra/src/llm/openai_compat/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Claude subscription provider and provider factory</name>
  <files>
    crates/boternity-infra/src/llm/claude_sub/mod.rs
    crates/boternity-infra/src/llm/mod.rs
  </files>
  <action>
Create `crates/boternity-infra/src/llm/claude_sub/mod.rs`:

1. `ClaudeSubscriptionProvider` -- a thin wrapper around `OpenAiCompatibleProvider`:
   - Use `OpenAiCompatibleProvider::claude_subscription(model)` internally
   - Add module-level doc comment: "EXPERIMENTAL: Claude.ai subscription provider. Requires claude-max-api-proxy running at localhost:3456. WARNING: Anthropic actively enforces against this usage as of January 2026. This may stop working at any time."
   - Implement LlmProvider by delegating to inner OpenAiCompatibleProvider
   - Override `name()` to return "claude_subscription"

2. Create a provider factory function in `llm/mod.rs`:
   `pub fn create_provider(config: &ProviderConfig, api_key: &str) -> Result<BoxLlmProvider, LlmError>`:
   - Match on config.provider_type:
     - ProviderType::Anthropic -> Use existing AnthropicProvider::new(api_key, &config.model)
     - ProviderType::Bedrock -> Use existing BedrockProvider (pass api_key as bearer token)
     - ProviderType::OpenAiCompatible -> Use OpenAiCompatibleProvider::new() with config.base_url.unwrap_or(default for name), api_key, model, capabilities
     - ProviderType::ClaudeSubscription -> Use ClaudeSubscriptionProvider if feature enabled, else return error "Claude subscription provider requires --experimental flag"
   - Wrap in BoxLlmProvider::new()

3. Connection test function `pub async fn test_provider_connection(provider: &BoxLlmProvider) -> Result<(), LlmError>`:
   - Per RESEARCH.md Pattern: send minimal CompletionRequest { model: empty string, messages: [user: "Hello"], max_tokens: 10, temperature: 0.0, stream: false }
   - Return Ok on success, Err on failure
   - Per user decision: "Always test connection when a new provider is configured"

Update `llm/mod.rs`: add `pub mod claude_sub;`
  </action>
  <verify>`cargo check -p boternity-infra` compiles. Provider factory creates all provider types.</verify>
  <done>Claude subscription provider exists (experimental). Provider factory creates BoxLlmProvider from ProviderConfig. Connection test function available.</done>
</task>

<task type="auto">
  <name>Task 2: Wire FallbackChain into AppState and chat loop</name>
  <files>
    crates/boternity-api/src/state.rs
    crates/boternity-api/src/cli/chat/loop_runner.rs
  </files>
  <action>
Update `crates/boternity-api/src/state.rs`:

1. Add to AppState:
   - `pub fallback_chain: Arc<tokio::sync::RwLock<FallbackChain>>` -- RwLock because health state is mutable
   - Import FallbackChain, ProviderRegistry from boternity-core

2. In `AppState::init()`:
   - Load provider configuration from bot's identity or global config (for now, create a default chain with just Anthropic as the single provider -- full multi-provider config comes from CLI in Plan 03-11)
   - Build default FallbackChain with single provider
   - Wrap in Arc<RwLock>
   - Add a helper method `pub async fn build_fallback_chain_for_bot(&self, bot_id: &Uuid) -> Result<FallbackChain, anyhow::Error>` that:
     - Loads bot config to check for per-bot provider overrides
     - Falls back to global default chain
     - Resolves API keys from secret service
     - Creates providers via `create_provider()`
     - Tests each provider connection (per user decision)
     - Returns configured FallbackChain

Update `crates/boternity-api/src/cli/chat/loop_runner.rs`:

1. Replace direct BoxLlmProvider usage with FallbackChain:
   - Instead of calling `provider.stream(request)`, call `fallback_chain.stream(request)`
   - For non-streaming: `fallback_chain.complete(request)`

2. Handle failover warnings:
   - After each complete() or before stream starts, check for failover_warning
   - If Some(warning): print to stderr in yellow/orange color using console crate: `eprintln!("[failover] {}", warning)` per user decision
   - This gives real-time visibility into provider switches

3. Auto-switch-back logic:
   - Before each message, check `fallback_chain.primary_available()` per user decision
   - If primary was previously down but now available (circuit half-open), the fallback chain naturally routes there
   - No extra code needed -- the circuit breaker handles this

4. Handle "all providers down" error:
   - When FallbackChain returns the "all providers unavailable" error, display it clearly to user
   - Include suggestion: "Run `bnity provider status` for details" per user decision

Keep backward compatibility: if no fallback chain configured (single provider), behavior is identical to Phase 2.
  </action>
  <verify>`cargo check --workspace` compiles. `cargo test --workspace` passes. Chat still works with single Anthropic provider (backward compatible).</verify>
  <done>FallbackChain wired into AppState and chat loop. Failover warnings print to stderr. Auto-switch-back to primary when recovered. Clear error when all providers down.</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- `cargo test --workspace` passes
- Single-provider chat (Anthropic only) still works identically to Phase 2
- FallbackChain correctly wraps provider(s) in AppState
- Failover warnings would appear on stderr (tested via unit test with mock)
</verification>

<success_criteria>
Claude subscription provider exists behind experimental flag. Provider factory creates any provider type from config. FallbackChain is integrated into the chat flow with failover stderr output and auto-switch-back behavior. Backward compatible with single-provider setup.
</success_criteria>

<output>
After completion, create `.planning/phases/03-multi-provider-memory/03-06-SUMMARY.md`
</output>
