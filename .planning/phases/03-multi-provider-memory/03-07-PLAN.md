---
phase: 03-multi-provider-memory
plan: 07
type: execute
wave: 3
depends_on: ["03-04", "03-05"]
files_modified:
  - crates/boternity-infra/src/vector/memory.rs
  - crates/boternity-infra/src/vector/mod.rs
autonomous: true

must_haves:
  truths:
    - "LanceVectorMemoryStore implements VectorMemoryStore trait"
    - "Vector search returns ranked results with cosine distance and relevance scores"
    - "Semantic dedup detects near-duplicate memories before storage"
    - "Time decay scoring combines similarity, age, access count, and importance"
    - "Embedding model mismatch detection returns entries needing re-embedding"
    - "Per-bot tables provide memory isolation between bots"
  artifacts:
    - path: "crates/boternity-infra/src/vector/memory.rs"
      provides: "LanceVectorMemoryStore implementing VectorMemoryStore"
      contains: "impl VectorMemoryStore for LanceVectorMemoryStore"
  key_links:
    - from: "crates/boternity-infra/src/vector/memory.rs"
      to: "crates/boternity-core/src/memory/vector.rs"
      via: "implements VectorMemoryStore trait"
      pattern: "impl VectorMemoryStore for LanceVectorMemoryStore"
    - from: "crates/boternity-infra/src/vector/memory.rs"
      to: "crates/boternity-infra/src/vector/lance.rs"
      via: "uses LanceVectorStore for table management"
      pattern: "LanceVectorStore"
    - from: "crates/boternity-infra/src/vector/memory.rs"
      to: "crates/boternity-infra/src/vector/schema.rs"
      via: "uses bot_memory_schema for table creation"
      pattern: "bot_memory_schema"
---

<objective>
Implement the LanceDB-backed vector memory store for per-bot long-term memory.

Purpose: Enable semantic search over bot memories using vector embeddings (MEMO-02). Each bot gets an isolated LanceDB table. Memories are scored using a combination of cosine similarity, time decay, importance, and access frequency.
Output: LanceVectorMemoryStore implementing VectorMemoryStore trait with all CRUD operations, search with ranking, semantic dedup, and embedding model tracking.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-multi-provider-memory/03-RESEARCH.md
@.planning/phases/03-multi-provider-memory/03-CONTEXT.md
@.planning/phases/03-multi-provider-memory/03-04-SUMMARY.md
@.planning/phases/03-multi-provider-memory/03-05-SUMMARY.md
@crates/boternity-core/src/memory/vector.rs
@crates/boternity-infra/src/vector/lance.rs
@crates/boternity-infra/src/vector/schema.rs
@crates/boternity-types/src/memory.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement LanceVectorMemoryStore with search and CRUD</name>
  <files>
    crates/boternity-infra/src/vector/memory.rs
    crates/boternity-infra/src/vector/mod.rs
  </files>
  <action>
Create `crates/boternity-infra/src/vector/memory.rs`:

1. `LanceVectorMemoryStore` struct:
   - `store: Arc<LanceVectorStore>`

2. `LanceVectorMemoryStore::new(store: Arc<LanceVectorStore>) -> Self`

3. Helper: `fn compute_relevance_score(cosine_distance: f32, importance: u8, created_at: DateTime<Utc>, last_accessed_at: Option<DateTime<Utc>>, access_count: u32) -> f32`:
   - Per RESEARCH.md Pattern 6:
   - `similarity = 1.0 - (cosine_distance / 2.0)` (convert distance [0,2] to similarity [0,1])
   - Time decay with 30-day half-life: `reference_time = last_accessed_at.unwrap_or(created_at)`, `days_old = now - reference_time`, `time_factor = 0.5^(days_old / 30.0)`
   - Reinforcement: `1.0 + ln(1 + access_count) * 0.1`
   - Importance: `0.6 + (importance - 1) * 0.1` (maps 1-5 to 0.6-1.0)
   - Final: `similarity * time_factor * reinforcement * importance_factor`

4. Helper: `fn record_batch_to_entries(batches: Vec<RecordBatch>) -> Vec<(VectorMemoryEntry, f32)>`:
   - Parse Arrow RecordBatch columns back to VectorMemoryEntry + distance
   - LanceDB includes a `_distance` column in query results
   - Map each row: extract id, bot_id, fact, category, importance, session_id, created_at, last_accessed_at, access_count, embedding_model from their respective columns
   - Parse category string back to MemoryCategory

5. Implement `VectorMemoryStore` for `LanceVectorMemoryStore`:

   - `search(bot_id, query_embedding, limit, min_similarity)`:
     - Get/create table: `self.store.ensure_table(bot_table_name(bot_id), bot_memory_schema())`
     - Query: `table.query().nearest_to(query_embedding)?.distance_type(DistanceType::Cosine).limit(limit * 2).execute().await?` (fetch 2x limit to allow filtering)
     - Convert results via `record_batch_to_entries()`
     - Filter by min_similarity: `1.0 - (distance / 2.0) >= min_similarity` (per RESEARCH.md: recommend 0.4 threshold, meaning max_cosine_distance 1.2)
     - Compute relevance_score for each entry
     - Sort by relevance_score DESC, take top `limit`
     - Update last_accessed_at and access_count for returned entries (batch update)
     - Return Vec<RankedMemory>

   - `add(entry, embedding)`:
     - Get/create table
     - Build RecordBatch from VectorMemoryEntry + embedding using Arrow arrays:
       - StringArray for text fields, Int32Array for numeric, FixedSizeListArray for vector
     - `table.add(Box::new(RecordBatchIterator::new(vec![Ok(batch)], schema))).execute().await`

   - `delete(bot_id, memory_id)`:
     - Get table
     - `table.delete(&format!("id = '{}'", memory_id)).await`

   - `delete_all(bot_id)`:
     - Count rows first, then `self.store.drop_table(bot_table_name(bot_id))`
     - Return count

   - `count(bot_id)`:
     - Get table, `table.count_rows(None).await`

   - `check_duplicate(bot_id, embedding, threshold)`:
     - Per RESEARCH.md Pattern 7
     - Query: `table.query().nearest_to(embedding)?.distance_type(DistanceType::Cosine).limit(1).execute().await`
     - If closest result has distance < threshold (recommend 0.15 = near-duplicate): return Some(entry)
     - Else: return None

   - `get_all_for_reembedding(bot_id, current_model)`:
     - Query: `table.query().only_if(&format!("embedding_model != '{}'", current_model)).execute().await`
     - Parse and return entries

   - `update_embedding(memory_id, new_embedding, model_name)`:
     - Delete old record, add new record with updated embedding and embedding_model
     - (LanceDB doesn't support in-place updates of vector columns -- delete+insert is the pattern)

Update `vector/mod.rs`: add `pub mod memory;`

Add integration test:
- Create LanceVectorMemoryStore with temp directory
- Add a memory entry with embedding
- Search with same embedding -> returns it with high similarity
- Add near-duplicate -> check_duplicate returns existing
- Delete -> search returns empty
  </action>
  <verify>`cargo test -p boternity-infra -- vector::memory` passes. Search returns ranked results. Dedup detects near-duplicates.</verify>
  <done>LanceVectorMemoryStore implements full VectorMemoryStore trait. Search combines cosine similarity with time decay scoring. Semantic dedup prevents near-duplicate storage. Embedding model tracking enables re-embedding on model change.</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- `cargo test -p boternity-infra -- vector` passes
- Search returns results ranked by relevance (similarity * time decay * importance)
- Near-duplicate detection works (cosine distance < 0.15 threshold)
- Model mismatch detection returns entries needing re-embedding
</verification>

<success_criteria>
Per-bot vector memory with ranked search, time decay, semantic dedup, and embedding model tracking is operational. Each bot has an isolated LanceDB table.
</success_criteria>

<output>
After completion, create `.planning/phases/03-multi-provider-memory/03-07-SUMMARY.md`
</output>
