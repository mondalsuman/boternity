---
phase: 03-multi-provider-memory
plan: 09
type: execute
wave: 4
depends_on: ["03-07"]
files_modified:
  - crates/boternity-infra/src/vector/shared.rs
  - crates/boternity-infra/src/vector/mod.rs
autonomous: true

must_haves:
  truths:
    - "SharedMemoryStore uses a single global LanceDB table with trust-level filtering"
    - "Trust filter correctly restricts access: public = all, trusted = explicit trust list, private = author only"
    - "Provenance tracks author bot name and includes 'Written by BotX' annotation"
    - "SHA-256 tamper detection hash stored on every write"
    - "Per-bot contribution cap enforced (default 500)"
    - "Author can revoke previously shared memories"
    - "Merged queries return both private and shared memories ranked by relevance"
  artifacts:
    - path: "crates/boternity-infra/src/vector/shared.rs"
      provides: "LanceSharedMemoryStore implementing SharedMemoryStore"
      contains: "impl SharedMemoryStore for LanceSharedMemoryStore"
  key_links:
    - from: "crates/boternity-infra/src/vector/shared.rs"
      to: "crates/boternity-core/src/memory/shared.rs"
      via: "implements SharedMemoryStore trait"
      pattern: "impl SharedMemoryStore for LanceSharedMemoryStore"
    - from: "crates/boternity-infra/src/vector/shared.rs"
      to: "crates/boternity-infra/src/vector/lance.rs"
      via: "uses LanceVectorStore for shared_memory table"
      pattern: "shared_table_name"
---

<objective>
Implement shared memory with trust-level partitioning and provenance tracking.

Purpose: Enable cross-bot knowledge sharing with security guarantees (MEMO-03, MEMO-04). Bots can share memories at three trust levels (Public/Trusted/Private) with full provenance tracking and tamper detection.
Output: LanceSharedMemoryStore implementing SharedMemoryStore trait with trust filtering, SHA-256 integrity, per-bot caps, and merged query support.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-multi-provider-memory/03-RESEARCH.md
@.planning/phases/03-multi-provider-memory/03-CONTEXT.md
@.planning/phases/03-multi-provider-memory/03-07-SUMMARY.md
@crates/boternity-core/src/memory/shared.rs
@crates/boternity-infra/src/vector/lance.rs
@crates/boternity-infra/src/vector/schema.rs
@crates/boternity-types/src/memory.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement LanceSharedMemoryStore with trust partitioning</name>
  <files>
    crates/boternity-infra/src/vector/shared.rs
    crates/boternity-infra/src/vector/mod.rs
  </files>
  <action>
Create `crates/boternity-infra/src/vector/shared.rs`:

1. `LanceSharedMemoryStore` struct:
   - `store: Arc<LanceVectorStore>`
   - `max_per_bot: u64` (default 500, per user decision: "Configurable cap on shared memory contributions per bot")
   - `write_serializer: tokio::sync::Mutex<()>` -- serialize writes to prevent concurrent conflicts per RESEARCH.md Pitfall 6

2. Helper: `fn compute_write_hash(entry: &SharedMemoryEntry) -> String`:
   - SHA-256 hash of: `format!("{}:{}:{}:{}", entry.id, entry.fact, entry.author_bot_id, entry.created_at)`
   - Use sha2 crate (already in workspace)
   - Return hex-encoded hash string

3. Helper: `fn build_trust_filter(reading_bot_id: &Uuid, trusted_bot_ids: &[Uuid]) -> String`:
   - Per RESEARCH.md Pattern 8:
   - `"trust_level = 'public' OR author_bot_id = '{reading_bot_id}' OR (trust_level = 'trusted' AND author_bot_id IN ({trusted_list}))"`
   - Trusted_list is comma-separated quoted UUIDs

4. Implement `SharedMemoryStore` for `LanceSharedMemoryStore`:

   - `add(entry, embedding)`:
     - Check per-bot cap: `count_by_author(entry.author_bot_id)`. If >= max_per_bot, return error.
     - Compute write_hash and set on entry
     - Acquire write_serializer lock (per RESEARCH.md Pitfall 6)
     - Get/create shared_memory table
     - Build RecordBatch from SharedMemoryEntry + embedding
     - Insert into table

   - `search(reading_bot_id, trusted_bot_ids, query_embedding, limit, min_similarity)`:
     - Get shared_memory table
     - Build trust filter via `build_trust_filter()`
     - Query: `table.query().nearest_to(query_embedding)?.distance_type(DistanceType::Cosine).only_if(&trust_filter).limit(limit).execute().await`
     - Parse results, filter by min_similarity
     - Build RankedMemory with provenance: format!("Written by {}", entry.author_bot_name) per user decision
     - Return ranked results

   - `delete(memory_id, author_bot_id)`:
     - Only author can delete: query first to verify author_bot_id matches
     - `table.delete(&format!("id = '{}' AND author_bot_id = '{}'", memory_id, author_bot_id)).await`

   - `share(memory_id, trust_level)`:
     - Delete old record, re-insert with updated trust_level
     - (LanceDB doesn't support in-place updates of non-vector fields cleanly -- delete+insert)

   - `revoke(memory_id, author_bot_id)`:
     - Same as share but sets trust_level back to Private
     - Verify author matches

   - `count_by_author(author_bot_id)`:
     - Query: `table.query().only_if(&format!("author_bot_id = '{}'", author_bot_id)).execute().await`
     - Count results

   - `verify_integrity(memory_id)`:
     - Load entry from table
     - Recompute hash, compare to stored write_hash
     - Return true if match, false if tampered

5. Add a public method (not on the trait): `pub async fn merged_search(bot_memory: &LanceVectorMemoryStore, shared: &LanceSharedMemoryStore, bot_id: &Uuid, trusted_bot_ids: &[Uuid], query_embedding: &[f32], limit: usize, min_similarity: f32) -> Result<Vec<RankedMemory>, ...>`:
   - Per user decision: "Merged query results -- a single query returns both private and shared memories, ranked by relevance"
   - Query both stores in parallel via `tokio::join!`
   - Merge results, re-rank by relevance_score
   - Take top `limit`
   - Annotate shared memories with provenance

Update `vector/mod.rs`: add `pub mod shared;`

Add integration test:
- Create shared memory store
- Bot A adds a public memory -> Bot B can search and find it
- Bot A adds a trusted memory -> Bot B (not in trust list) cannot find it
- Bot A adds a private memory -> Bot B cannot find it
- Verify write_hash integrity check passes on clean data
  </action>
  <verify>`cargo test -p boternity-infra -- vector::shared` passes. Trust filtering works correctly for all three levels.</verify>
  <done>LanceSharedMemoryStore implements SharedMemoryStore with trust-level filtering, provenance tracking, SHA-256 tamper detection, per-bot caps, write serialization, and merged queries.</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- `cargo test -p boternity-infra -- vector::shared` passes
- Public memories accessible by all bots
- Trusted memories only accessible by trust-listed bots
- Private memories only accessible by author
- Write hash validates integrity
- Per-bot cap prevents domination
</verification>

<success_criteria>
Shared memory works with three trust levels. Provenance always tracks author. SHA-256 tamper detection on writes. Per-bot contribution cap enforced. Merged queries combine private and shared results ranked by relevance.
</success_criteria>

<output>
After completion, create `.planning/phases/03-multi-provider-memory/03-09-SUMMARY.md`
</output>
