---
phase: 03-multi-provider-memory
plan: 13
type: execute
wave: 5
depends_on: ["03-10", "03-05"]
files_modified:
  - crates/boternity-api/src/cli/storage.rs
  - crates/boternity-api/src/cli/kv.rs
  - crates/boternity-api/src/cli/mod.rs
  - crates/boternity-api/src/state.rs
autonomous: true

must_haves:
  truths:
    - "bnity storage upload saves file and auto-indexes text files"
    - "bnity storage download retrieves file content"
    - "bnity storage list shows all files with metadata"
    - "bnity storage info shows file details including version history"
    - "bnity storage delete removes file, versions, and index"
    - "bnity kv set/get/delete/list manages key-value pairs"
    - "KV values support arbitrary JSON"
    - "AppState wires all Phase 3 services (vector store, embedder, shared memory, file store, KV)"
  artifacts:
    - path: "crates/boternity-api/src/cli/storage.rs"
      provides: "Storage CLI subcommands (upload, download, list, delete, info)"
      contains: "StorageCommand"
    - path: "crates/boternity-api/src/cli/kv.rs"
      provides: "KV store CLI subcommands (set, get, delete, list)"
      contains: "KvCommand"
    - path: "crates/boternity-api/src/state.rs"
      provides: "AppState with all Phase 3 services wired"
      contains: "vector_store"
  key_links:
    - from: "crates/boternity-api/src/cli/storage.rs"
      to: "crates/boternity-infra/src/storage/filesystem.rs"
      via: "uses LocalFileStore for file operations"
      pattern: "file_store"
    - from: "crates/boternity-api/src/cli/storage.rs"
      to: "crates/boternity-infra/src/storage/indexer.rs"
      via: "auto-indexes text files after upload"
      pattern: "indexer.*index_file"
    - from: "crates/boternity-api/src/cli/kv.rs"
      to: "crates/boternity-infra/src/sqlite/kv.rs"
      via: "uses SqliteKvStore for CRUD"
      pattern: "kv_store"
    - from: "crates/boternity-api/src/state.rs"
      to: "crates/boternity-infra/src/vector/lance.rs"
      via: "initializes LanceVectorStore"
      pattern: "LanceVectorStore"
---

<objective>
Build the storage and KV CLI commands and wire all Phase 3 services into AppState.

Purpose: Users can upload files, manage per-bot storage, and use the key-value store via CLI (MEMO-06). This plan also completes the AppState wiring for all Phase 3 infrastructure services.
Output: Storage CLI (upload/download/list/delete/info), KV CLI (set/get/delete/list), fully wired AppState.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-multi-provider-memory/03-RESEARCH.md
@.planning/phases/03-multi-provider-memory/03-CONTEXT.md
@.planning/phases/03-multi-provider-memory/03-10-SUMMARY.md
@.planning/phases/03-multi-provider-memory/03-05-SUMMARY.md
@crates/boternity-api/src/state.rs
@crates/boternity-api/src/cli/mod.rs
@crates/boternity-infra/src/storage/filesystem.rs
@crates/boternity-infra/src/sqlite/kv.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire all Phase 3 services into AppState</name>
  <files>
    crates/boternity-api/src/state.rs
  </files>
  <action>
Update AppState to initialize and hold all Phase 3 infrastructure services:

1. Add new fields to AppState:
   - `pub vector_store: Arc<LanceVectorStore>`
   - `pub embedder: Arc<FastEmbedEmbedder>`
   - `pub vector_memory: Arc<LanceVectorMemoryStore>`
   - `pub shared_memory: Arc<LanceSharedMemoryStore>`
   - `pub file_store: Arc<LocalFileStore>`
   - `pub file_indexer: Arc<FileIndexer>`
   - `pub kv_store: Arc<SqliteKvStore>`
   - `pub audit_log: Arc<SqliteAuditLog>`
   - `pub provider_health_store: Arc<SqliteProviderHealthStore>`

2. In `AppState::init()`:
   - Initialize LanceVectorStore: `LanceVectorStore::new(data_dir.join("vector_store")).await?`
   - Initialize FastEmbedEmbedder: `FastEmbedEmbedder::new()?`
   - Initialize LanceVectorMemoryStore: `LanceVectorMemoryStore::new(Arc::clone(&vector_store))`
   - Initialize LanceSharedMemoryStore: `LanceSharedMemoryStore::new(Arc::clone(&vector_store), 500)` (500 = default per-bot cap)
   - Initialize SqliteFileMetadataStore: `SqliteFileMetadataStore::new(db_pool.clone())`
   - Initialize LocalFileStore: `LocalFileStore::new(data_dir.join("bots"), file_metadata_store)`
   - Initialize FileIndexer: `FileIndexer::new(Arc::clone(&vector_store), Arc::clone(&embedder))`
   - Initialize SqliteKvStore: `SqliteKvStore::new(db_pool.clone())`
   - Initialize SqliteAuditLog: `SqliteAuditLog::new(db_pool.clone())`
   - Initialize SqliteProviderHealthStore: `SqliteProviderHealthStore::new(db_pool.clone())`
   - Wrap all in Arc

3. Auto re-embed check on startup:
   - Per discretion decision: "Synchronous on startup if model changed"
   - After initializing embedder and vector_memory:
     - This is a global check, so skip for now (individual bot re-embed happens on first chat)
     - Log a tracing::info noting the embedding model in use

Note: FastEmbedEmbedder::new() downloads the model on first run (~23MB). This may take a few seconds. Log progress.
  </action>
  <verify>`cargo check --workspace` compiles. `cargo run -- check` (or any CLI command) initializes all services without error.</verify>
  <done>AppState wires all Phase 3 services: vector store, embedder, vector memory, shared memory, file store, file indexer, KV store, audit log, provider health store.</done>
</task>

<task type="auto">
  <name>Task 2: Implement storage and KV CLI commands</name>
  <files>
    crates/boternity-api/src/cli/storage.rs
    crates/boternity-api/src/cli/kv.rs
    crates/boternity-api/src/cli/mod.rs
  </files>
  <action>
Create `crates/boternity-api/src/cli/storage.rs`:

1. `StorageCommand` enum:
   ```
   #[derive(Subcommand)]
   enum StorageCommand {
       /// Upload a file to a bot's storage
       Upload {
           #[arg(long)]
           bot: String,
           /// Path to file on local filesystem
           path: String,
           /// Optional rename (default: use original filename)
           #[arg(long)]
           name: Option<String>,
       },
       /// Download a file from a bot's storage
       Download {
           #[arg(long)]
           bot: String,
           /// Filename in bot's storage
           filename: String,
           /// Output path (default: current directory)
           #[arg(long)]
           output: Option<String>,
       },
       /// List all files in a bot's storage
       List {
           #[arg(long)]
           bot: String,
       },
       /// Show detailed info about a file
       Info {
           #[arg(long)]
           bot: String,
           filename: String,
       },
       /// Delete a file from a bot's storage
       Delete {
           #[arg(long)]
           bot: String,
           filename: String,
       },
   }
   ```

2. Handler:
   - **Upload**:
     - Read file from disk path
     - Check size <= 50MB
     - Call file_store.save_file(bot_id, filename, data)
     - Per user decision: "Auto-index text files: chunk and embed for semantic search"
     - If text file: call file_indexer.index_file(bot_id, file_id, filename, content)
     - Update is_indexed flag in metadata
     - Print: "Uploaded {filename} ({size}) -- {N chunks indexed}" or "Uploaded {filename} ({size})"

   - **Download**:
     - Call file_store.get_file(bot_id, filename)
     - Write to output path
     - Print: "Downloaded {filename} to {output_path}"

   - **List**:
     - Call file_store.list_files(bot_id)
     - Display table: | Filename | Size | Version | Indexed | Updated |
     - Size formatted: "1.2 MB", "456 KB"

   - **Info**:
     - Call file_store.get_file_info(bot_id, filename)
     - Call file_store.get_versions(file_id)
     - Display: filename, MIME type, size, version, is_indexed, created, updated
     - Version history: | Version | Size | Created |

   - **Delete**:
     - Call file_indexer.deindex_file(bot_id, file_id) first (remove chunks)
     - Call file_store.delete_file(bot_id, filename)
     - Print confirmation

Create `crates/boternity-api/src/cli/kv.rs`:

1. `KvCommand` enum:
   ```
   #[derive(Subcommand)]
   enum KvCommand {
       /// Set a key-value pair
       Set {
           #[arg(long)]
           bot: String,
           key: String,
           /// JSON value (objects, arrays, strings, numbers)
           value: String,
       },
       /// Get the value for a key
       Get {
           #[arg(long)]
           bot: String,
           key: String,
       },
       /// Delete a key
       Delete {
           #[arg(long)]
           bot: String,
           key: String,
       },
       /// List all keys for a bot
       List {
           #[arg(long)]
           bot: String,
       },
   }
   ```

2. Handler:
   - **Set**: parse value as serde_json::Value, call kv_store.set(). Print "Set {key}"
   - **Get**: call kv_store.get(). Pretty-print JSON to stdout. Print "Key not found" if None.
   - **Delete**: call kv_store.delete(). Print "Deleted {key}"
   - **List**: call kv_store.list_keys(). Print keys, one per line.

Update `cli/mod.rs`:
- Add `Storage(StorageCommand)` and `Kv(KvCommand)` variants
- Route to handlers
  </action>
  <verify>`cargo check --workspace` compiles. `bnity storage list --bot test` runs. `bnity kv set --bot test mykey '{"foo": "bar"}'` stores value.</verify>
  <done>Storage CLI supports upload (with auto-indexing), download, list, info (with version history), and delete. KV CLI supports set/get/delete/list with arbitrary JSON values.</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- `cargo test --workspace` passes
- AppState initializes all Phase 3 services
- `bnity storage upload --bot test /path/to/file.txt` uploads and indexes
- `bnity storage list --bot test` shows files
- `bnity kv set --bot test mykey '{"value": 42}'` stores JSON
- `bnity kv get --bot test mykey` retrieves and displays JSON
</verification>

<success_criteria>
All Phase 3 services wired in AppState. Storage CLI with full CRUD and auto-indexing. KV CLI with JSON value support. File upload auto-indexes text files for semantic search.
</success_criteria>

<output>
After completion, create `.planning/phases/03-multi-provider-memory/03-13-SUMMARY.md`
</output>
