---
phase: 04-web-ui-core-fleet-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/boternity-api/src/http/handlers/chat.rs
  - crates/boternity-api/src/http/handlers/session.rs
  - crates/boternity-api/src/http/handlers/identity.rs
  - crates/boternity-api/src/http/handlers/stats.rs
  - crates/boternity-api/src/http/handlers/mod.rs
  - crates/boternity-api/src/http/router.rs
autonomous: true

must_haves:
  truths:
    - "POST /api/v1/bots/{id}/chat/stream returns SSE events with text_delta, usage, done, and error event types"
    - "GET /api/v1/bots/{id}/sessions returns list of chat sessions for a bot"
    - "GET /api/v1/sessions/{id}/messages returns messages for a session"
    - "DELETE /api/v1/sessions/{id} deletes a session"
    - "POST /api/v1/sessions/{id}/clear clears messages but keeps session"
    - "GET/PUT /api/v1/bots/{id}/identity reads and writes IDENTITY.md"
    - "GET/PUT /api/v1/bots/{id}/user reads and writes USER.md"
    - "GET /api/v1/stats returns aggregate dashboard statistics"
  artifacts:
    - path: "crates/boternity-api/src/http/handlers/chat.rs"
      provides: "SSE streaming chat endpoint"
      exports: ["stream_chat"]
    - path: "crates/boternity-api/src/http/handlers/session.rs"
      provides: "Session CRUD HTTP handlers"
      exports: ["list_sessions", "get_session", "get_messages", "delete_session", "clear_session"]
    - path: "crates/boternity-api/src/http/handlers/identity.rs"
      provides: "Identity and User file endpoints"
      exports: ["get_identity", "update_identity", "get_user_context", "update_user_context"]
    - path: "crates/boternity-api/src/http/handlers/stats.rs"
      provides: "Dashboard stats endpoint"
      exports: ["get_stats"]
  key_links:
    - from: "crates/boternity-api/src/http/handlers/chat.rs"
      to: "crates/boternity-core/src/chat/service.rs"
      via: "AppState.chat_service"
      pattern: "state\\.chat_service"
    - from: "crates/boternity-api/src/http/handlers/chat.rs"
      to: "crates/boternity-api/src/state.rs"
      via: "build_fallback_chain"
      pattern: "build_fallback_chain"
    - from: "crates/boternity-api/src/http/router.rs"
      to: "crates/boternity-api/src/http/handlers/"
      via: "route registration"
      pattern: "handlers::(chat|session|identity|stats)"
---

<objective>
Add all missing backend API endpoints that the web frontend requires: SSE streaming chat, session CRUD, identity/user file management, and dashboard statistics.

Purpose: The frontend cannot function without these endpoints. The existing backend has bot CRUD and soul versioning, but is missing chat/session HTTP handlers, streaming, and several file endpoints. This must be done first.
Output: All REST endpoints registered in the Axum router, tested via curl.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-web-ui-core-fleet-dashboard/04-RESEARCH.md

@crates/boternity-api/src/http/router.rs
@crates/boternity-api/src/http/handlers/mod.rs
@crates/boternity-api/src/http/handlers/bot.rs
@crates/boternity-api/src/http/handlers/soul.rs
@crates/boternity-api/src/http/response.rs
@crates/boternity-api/src/http/error.rs
@crates/boternity-api/src/state.rs
@crates/boternity-core/src/chat/service.rs
@crates/boternity-api/src/cli/chat/loop_runner.rs
@crates/boternity-infra/src/filesystem/mod.rs
@crates/boternity-infra/src/filesystem/identity.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: SSE streaming chat + session CRUD endpoints</name>
  <files>
    crates/boternity-api/src/http/handlers/chat.rs
    crates/boternity-api/src/http/handlers/session.rs
    crates/boternity-api/src/http/handlers/mod.rs
    crates/boternity-api/src/http/router.rs
  </files>
  <action>
Create the SSE streaming chat endpoint and session management handlers.

**chat.rs — `stream_chat` handler:**
- `POST /api/v1/bots/{id}/chat/stream` with body `{ session_id?: String, message: String }`
- Follow the exact pattern from `loop_runner.rs`: resolve bot -> read identity/soul/user files -> parse identity frontmatter -> build fallback chain -> build AgentContext -> build CompletionRequest -> stream via FallbackChain
- Use `axum::response::sse::{Event, Sse}` for SSE response with keep-alive (15s interval)
- If `session_id` is None, create a new session via `chat_service.create_session()`
- Emit an initial `event: session` with `data: {"session_id": "..."}` so the frontend knows which session was created
- Forward LLM stream events as SSE: `event: text_delta` with `data: {"text": "..."}`, `event: usage` with usage JSON, `event: done` with `data: {}`
- On error, emit `event: error` with `data: {"message": "..."}` then break
- After stream completes: save user message via `chat_service.save_user_message()`, save assistant message via `chat_service.save_assistant_message()` with accumulated content, token counts, and timing
- Use `async_stream::stream!` for the SSE stream (already a dependency via tokio-stream)
- The stream must be `Send` — avoid holding non-Send types across await points
- Add `futures-util` to boternity-api Cargo.toml if not present (needed for StreamExt on LLM stream)

**session.rs — session management handlers:**
- `GET /api/v1/bots/{id}/sessions` — wraps `chat_service.list_sessions(bot_id, limit, offset)`, query params for limit/offset
- `GET /api/v1/sessions/{id}` — wraps `chat_service.get_session(id)`
- `GET /api/v1/sessions/{id}/messages` — wraps `chat_service.get_messages(id, limit, offset)`
- `DELETE /api/v1/sessions/{id}` — wraps `chat_service.chat_repo().delete_session(id)` (check if method exists on ChatRepository trait; if not, add it)
- `POST /api/v1/sessions/{id}/clear` — delete all messages for session but keep the session record (may need a new method on ChatRepository)
- All responses wrapped in the existing `ApiResponse<T>` envelope from `response.rs`
- Parse path params as `Uuid` with proper error handling (return 400 on invalid UUID)

**mod.rs — register new modules:**
- Add `pub mod chat;` and `pub mod session;`

**router.rs — register new routes:**
- Add all chat and session routes under `/api/v1/`
- Group logically: chat streaming under bots, session management as top-level

**ChatRepository additions (if needed):**
- If `delete_session` or `clear_messages` don't exist on the ChatRepository trait, add them:
  - `delete_session(session_id: &Uuid)` — DELETE FROM chat_sessions WHERE id = ?
  - `clear_messages(session_id: &Uuid)` — DELETE FROM chat_messages WHERE session_id = ? and reset message_count to 0
- Implement in SqliteChatRepository
  </action>
  <verify>
Run `cargo build -p boternity-api` to confirm compilation. Then start the server and test:
- `curl -X POST http://localhost:3000/api/v1/bots/{slug}/chat/stream -H 'Content-Type: application/json' -d '{"message":"hello"}' -N` should return SSE events
- `curl http://localhost:3000/api/v1/bots/{slug}/sessions` should return session list
- `cargo test -p boternity-api` passes
  </verify>
  <done>
SSE streaming endpoint returns text_delta events. Session CRUD endpoints return proper API envelope responses. All routes registered in router.
  </done>
</task>

<task type="auto">
  <name>Task 2: Identity/User file endpoints + dashboard stats</name>
  <files>
    crates/boternity-api/src/http/handlers/identity.rs
    crates/boternity-api/src/http/handlers/stats.rs
    crates/boternity-api/src/http/handlers/mod.rs
    crates/boternity-api/src/http/router.rs
  </files>
  <action>
Create endpoints for IDENTITY.md and USER.md file management, and a dashboard stats aggregation endpoint.

**identity.rs — identity and user file handlers:**
- `GET /api/v1/bots/{id}/identity` — Read IDENTITY.md file using `LocalFileSystem::identity_path()`. Parse frontmatter via `parse_identity_frontmatter()`. Return JSON: `{ raw: string, parsed?: { model: string, temperature: number, max_tokens: number } }`. Return empty raw and null parsed if file doesn't exist.
- `PUT /api/v1/bots/{id}/identity` — Write IDENTITY.md content. Body: `{ content: string }`. Write to disk via `tokio::fs::write()`. Return the updated parsed result.
- `GET /api/v1/bots/{id}/user` — Read USER.md file using `LocalFileSystem::user_path()`. Return JSON: `{ content: string }`. Return empty string if file doesn't exist.
- `PUT /api/v1/bots/{id}/user` — Write USER.md content. Body: `{ content: string }`. Write to disk.
- All handlers resolve bot by ID or slug first (reuse the pattern from bot.rs handlers)
- Wrap all responses in `ApiResponse<T>` envelope

**stats.rs — dashboard statistics:**
- `GET /api/v1/stats` — Aggregate query returning:
  ```json
  {
    "total_bots": 5,
    "active_bots": 3,
    "disabled_bots": 1,
    "archived_bots": 1,
    "total_sessions": 42,
    "active_sessions": 2,
    "total_messages": 1337
  }
  ```
- Query bots via `bot_service` list with status filter (or direct SQL count queries for efficiency)
- Query sessions via `chat_service.chat_repo()` (may need a count method, or use list with count)
- If efficient count queries don't exist on the repositories, add simple COUNT(*) SQL queries to SqliteBotRepository and SqliteChatRepository
- Wrap in `ApiResponse<T>` envelope

**router.rs — register routes:**
- Add identity/user routes: `/bots/{id}/identity`, `/bots/{id}/user`
- Add stats route: `/stats`

**mod.rs — register modules:**
- Add `pub mod identity;` and `pub mod stats;`
  </action>
  <verify>
Run `cargo build -p boternity-api` to confirm compilation. Test:
- `curl http://localhost:3000/api/v1/bots/{slug}/identity` should return identity content
- `curl http://localhost:3000/api/v1/stats` should return aggregate stats JSON
- `cargo test -p boternity-api` passes
  </verify>
  <done>
Identity/User file endpoints read and write correctly. Stats endpoint returns aggregate counts. All new endpoints registered in the router and return ApiResponse envelopes.
  </done>
</task>

<task type="auto">
  <name>Task 3: SPA static file serving for production</name>
  <files>
    crates/boternity-api/src/http/router.rs
    crates/boternity-api/Cargo.toml
  </files>
  <action>
Configure Axum to serve the built React SPA from `apps/web/dist/` in production, with SPA fallback routing.

**router.rs changes:**
- Add conditional static file serving: if `apps/web/dist/` exists (or a configurable path), serve it
- Use `tower_http::services::ServeDir` with `.fallback(ServeFile::new("dist/index.html"))` for SPA client-side routing support
- The SPA routes are served at `/` (root), while API routes remain at `/api/v1/`
- Fallback must NOT intercept `/api/` or `/health` routes — only unknown routes that should be handled by the client-side router
- Add the static file serving AFTER the API routes in the router, so API routes take priority
- Use `tower_http::services::{ServeDir, ServeFile}` (already available via tower-http dependency)
- Make the static file path configurable via environment variable `BOTERNITY_WEB_DIR` with default `apps/web/dist`
- Only enable static serving if the directory exists (graceful degradation — API still works without the web build)

**Cargo.toml:**
- Ensure tower-http has the `fs` feature enabled (for ServeDir/ServeFile). Check current features and add if missing.

The pattern:
```rust
// After API routes, add SPA serving
let web_dir = std::env::var("BOTERNITY_WEB_DIR")
    .unwrap_or_else(|_| "apps/web/dist".to_string());
if std::path::Path::new(&web_dir).exists() {
    let serve_dir = ServeDir::new(&web_dir)
        .fallback(ServeFile::new(format!("{}/index.html", web_dir)));
    router = router.fallback_service(serve_dir);
}
```
  </action>
  <verify>
Run `cargo build -p boternity-api` to confirm compilation. The SPA serving is conditional — it won't break anything if `apps/web/dist/` doesn't exist yet. Verify API routes still work: `curl http://localhost:3000/api/v1/bots` returns JSON, not HTML.
  </verify>
  <done>
Production SPA serving configured. API routes take priority over static files. SPA fallback routes unknown paths to index.html for client-side routing. Graceful degradation when web build doesn't exist.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p boternity-api` compiles without errors
2. `cargo test -p boternity-api` passes
3. All new endpoints return proper ApiResponse envelopes
4. SSE endpoint streams events correctly (test with curl -N)
5. SPA fallback doesn't intercept API routes
</verification>

<success_criteria>
- All 8 missing endpoints from the research document are implemented and registered
- SSE streaming follows the same LLM interaction pattern as loop_runner.rs
- Session CRUD wraps existing ChatService methods
- Stats endpoint returns aggregate counts
- SPA serving configured for production deployment
</success_criteria>

<output>
After completion, create `.planning/phases/04-web-ui-core-fleet-dashboard/04-01-SUMMARY.md`
</output>
