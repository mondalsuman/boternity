---
phase: 04-web-ui-core-fleet-dashboard
plan: 04
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - apps/web/src/routes/chat/index.tsx
  - apps/web/src/routes/chat/$sessionId.tsx
  - apps/web/src/components/chat/session-sidebar.tsx
  - apps/web/src/components/chat/message-list.tsx
  - apps/web/src/components/chat/message-bubble.tsx
  - apps/web/src/components/chat/chat-input.tsx
  - apps/web/src/components/chat/streaming-indicator.tsx
  - apps/web/src/components/chat/chat-header.tsx
  - apps/web/src/components/chat/chat-empty-state.tsx
  - apps/web/src/hooks/use-sse-chat.ts
  - apps/web/src/hooks/use-chat-queries.ts
  - apps/web/src/stores/chat-store.ts
autonomous: true

must_haves:
  truths:
    - "User can start a new chat with any bot and see streaming token-by-token responses"
    - "Session sidebar shows all sessions grouped under bot name headers"
    - "User can have multiple parallel sessions including multiple with the same bot"
    - "User can type messages in an auto-expanding textarea and send with Enter"
    - "Streaming shows 'Bot is thinking...' indicator then tokens appear live"
    - "User can stop generation mid-stream with a Stop button"
    - "User can delete a session or clear its messages"
    - "Chat header shows bot name, emoji, and model badge"
  artifacts:
    - path: "apps/web/src/hooks/use-sse-chat.ts"
      provides: "SSE streaming hook via fetch + ReadableStream"
      exports: ["useSSEChat"]
    - path: "apps/web/src/components/chat/session-sidebar.tsx"
      provides: "Session list grouped by bot"
      contains: "grouped"
    - path: "apps/web/src/components/chat/message-list.tsx"
      provides: "Scrollable message list with streaming message"
      contains: "StreamingMessage"
    - path: "apps/web/src/stores/chat-store.ts"
      provides: "Chat UI state (active sessions, streaming buffers)"
      exports: ["useChatStore"]
  key_links:
    - from: "apps/web/src/hooks/use-sse-chat.ts"
      to: "/api/v1/bots/{id}/chat/stream"
      via: "POST fetch with ReadableStream"
      pattern: "chat/stream"
    - from: "apps/web/src/components/chat/session-sidebar.tsx"
      to: "/api/v1/bots/{id}/sessions"
      via: "useChatSessions hook"
      pattern: "useChatSessions"
    - from: "apps/web/src/components/chat/message-list.tsx"
      to: "/api/v1/sessions/{id}/messages"
      via: "useMessages hook"
      pattern: "useMessages"
---

<objective>
Build the core chat interface with SSE streaming, session management, and message display.

Purpose: Chat is the primary interaction — users chat with bots and see streaming responses. This covers requirements CHAT-01 (streaming chat), CHAT-02 (multiple bots simultaneously), CHAT-03 (multiple sessions with same bot), and WEBU-02 (chat interface).
Output: A functional chat interface at `/chat` with real streaming from the backend.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-web-ui-core-fleet-dashboard/04-RESEARCH.md
@.planning/phases/04-web-ui-core-fleet-dashboard/04-CONTEXT.md
@.planning/phases/04-web-ui-core-fleet-dashboard/04-01-SUMMARY.md
@.planning/phases/04-web-ui-core-fleet-dashboard/04-02-SUMMARY.md

@apps/web/src/lib/api-client.ts
@apps/web/src/types/chat.ts
@apps/web/src/types/bot.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: SSE streaming hook + chat store + session sidebar</name>
  <files>
    apps/web/src/hooks/use-sse-chat.ts
    apps/web/src/hooks/use-chat-queries.ts
    apps/web/src/stores/chat-store.ts
    apps/web/src/components/chat/session-sidebar.tsx
    apps/web/src/components/chat/chat-empty-state.tsx
    apps/web/src/routes/chat/index.tsx
  </files>
  <action>
**use-sse-chat.ts — SSE streaming hook (CRITICAL, get this right):**

Follow the exact pattern from the research document. Use `fetch()` + `ReadableStream` (NOT EventSource — we need POST with body).

```typescript
export function useSSEChat() {
  const [isStreaming, setIsStreaming] = useState(false);
  const [streamedContent, setStreamedContent] = useState('');
  const [activeSessionId, setActiveSessionId] = useState<string | null>(null);
  const abortRef = useRef<AbortController | null>(null);

  const sendMessage = useCallback(async (botId: string, message: string, sessionId?: string) => {
    setIsStreaming(true);
    setStreamedContent('');
    abortRef.current = new AbortController();

    const res = await fetch(`/api/v1/bots/${botId}/chat/stream`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ session_id: sessionId, message }),
      signal: abortRef.current.signal,
    });

    const reader = res.body!.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });

      const lines = buffer.split('\n');
      buffer = lines.pop()!;
      for (const line of lines) {
        if (line.startsWith('event: ')) { /* track event type */ }
        if (line.startsWith('data: ')) {
          const event = JSON.parse(line.slice(6));
          if (event type is session) setActiveSessionId(event.session_id);
          if (event type is text_delta) setStreamedContent(prev => prev + event.text);  // CRITICAL: functional updater to avoid stale closure
          if (event type is done) break;
          if (event type is error) throw new Error(event.message);
        }
      }
    }
    // finally: setIsStreaming(false)
  }, []);

  const stopGeneration = useCallback(() => {
    abortRef.current?.abort();
    setIsStreaming(false);
  }, []);

  // Cleanup on unmount
  useEffect(() => () => abortRef.current?.abort(), []);

  return { sendMessage, stopGeneration, streamedContent, isStreaming, activeSessionId };
}
```

Key implementation details:
- Parse SSE format: lines starting with `event: ` set the event type, `data: ` lines have JSON payload
- MUST use functional updater `setStreamedContent(prev => prev + event.text)` to avoid stale closure (Pitfall 5)
- AbortController for stop generation and cleanup on unmount (Pitfall 2)
- Return `activeSessionId` so the component knows which session the server created
- Wrap in try/catch, ignore AbortError, rethrow others

**use-chat-queries.ts — Session and message query hooks:**
- `useBotSessions(botId)` — `queryKey: ['sessions', botId]`, calls `GET /bots/{botId}/sessions`, `staleTime: 5_000`
- `useAllSessions()` — fetch sessions for all bots (call `/bots` first, then `/bots/{id}/sessions` for each). Use `useQueries` for parallel fetching. Group by bot.
- `useMessages(sessionId)` — `queryKey: ['messages', sessionId]`, calls `GET /sessions/{sessionId}/messages`, `staleTime: 0` (always fresh during chat)
- `useDeleteSession()` — mutation calling `DELETE /sessions/{id}`, invalidates `['sessions']`, shows toast
- `useClearSession()` — mutation calling `POST /sessions/{id}/clear`, invalidates `['messages', sessionId]`, shows toast

**chat-store.ts — Chat UI state (Zustand):**
- `activeBotId: string | null` — which bot is active in chat
- `activeSessionId: string | null` — which session is displayed
- `setActiveBot(botId)` and `setActiveSession(sessionId)` actions
- NOT for server data — sessions and messages live in TanStack Query

**session-sidebar.tsx — Session list (per user decision: "like Slack channels, grouped under bot name headers"):**
- Fetch all sessions using `useAllSessions()` or a simpler approach: load all bots, then for each bot load sessions
- Group sessions under bot name headers (bold bot name + emoji, sessions listed below)
- Each session item shows: session title (or "Untitled" if null), relative timestamp, message count badge
- Clicking a session sets it as active and navigates to `/chat/${sessionId}`
- "New chat" button for same bot: under each bot header, a small "+" icon that creates a new session for that bot
- "+" button at the top to pick a different bot (opens a small dialog/popover with bot list)
- Delete session: right-click or swipe (on mobile) or small X icon on hover
- Clear session: in a context menu or long-press
- Use shadcn ScrollArea for scrollable list
- Use shadcn Sheet on mobile (already handled by the sidebar)
- Show loading skeletons (5 items) while fetching

**chat-empty-state.tsx — Empty chat state (per user decision: "grid of available bots to start chatting with"):**
- Shown when no session is selected
- Display a grid of available bots (fetch from /bots API)
- Each bot shown as a card with emoji, name, and "Chat" button
- Clicking starts a new session with that bot
- Text: "Start a conversation" heading above the grid

**routes/chat/index.tsx — Chat hub layout:**
- Two-panel layout: session sidebar (left, ~280px) + main chat area (right, flex-1)
- Use shadcn `ResizablePanel` if available, or simple flex layout
- If no session selected: show chat-empty-state
- If session selected: render message list + input (from next task, placeholder for now)
- Load active session from URL param or chat store
  </action>
  <verify>
1. Session sidebar loads and groups sessions by bot
2. Clicking a session navigates and shows it as active
3. "+" creates new session with a bot
4. Empty state shows bot grid when no sessions
5. SSE hook connects to backend and receives streaming events (test by sending a message)
6. Stop generation aborts the stream
  </verify>
  <done>
SSE streaming hook works end-to-end with the backend. Session sidebar groups sessions by bot name. Chat hub has two-panel layout. Empty state shows bot grid. New session creation works.
  </done>
</task>

<task type="auto">
  <name>Task 2: Message display, chat input, streaming indicator, chat header</name>
  <files>
    apps/web/src/components/chat/message-list.tsx
    apps/web/src/components/chat/message-bubble.tsx
    apps/web/src/components/chat/chat-input.tsx
    apps/web/src/components/chat/streaming-indicator.tsx
    apps/web/src/components/chat/chat-header.tsx
    apps/web/src/routes/chat/$sessionId.tsx
  </files>
  <action>
**message-bubble.tsx — Individual message component:**
- User messages: right-aligned, primary background color, white text
- Assistant messages: left-aligned, muted background, with bot emoji avatar
- Show relative timestamp (via `formatDistanceToNow`) in small text below message — per user decision: "Relative timestamps on messages ('2m ago', 'yesterday')"
- Plain text rendering for now (markdown rendering comes in Plan 05)
- `React.memo` wrapped to prevent unnecessary re-renders during streaming

**message-list.tsx — Scrollable message list:**
- Loads messages from `useMessages(sessionId)` query
- Renders list of `<MessageBubble>` components
- Auto-scrolls to bottom when new messages arrive (useEffect + ref.scrollIntoView)
- At the bottom: if streaming, render a special `<StreamingMessage>` component that displays the in-progress response
- `<StreamingMessage>` is its OWN component with its OWN state (receives `streamedContent` prop) — this prevents the entire message list from re-rendering on each token delta (Pitfall 4)
- Show loading skeletons (3 message-shaped skeletons) while messages load
- Empty state for new session: "Send a message to get started"

**streaming-indicator.tsx — "Bot is thinking..." indicator (per user decision):**
- Shows briefly before first token arrives (when `isStreaming` is true but `streamedContent` is empty)
- Animated dots or pulse effect: "Bot is thinking..."
- Disappears once first token arrives and StreamingMessage takes over
- Use simple CSS animation (no framer-motion needed)

**chat-input.tsx — Message input (per user decision):**
- Auto-expanding textarea: starts as single line, grows up to ~6 lines as user types, then scrolls (per user decision)
- Implement via textarea with dynamic height: set `rows` based on content line count, max-height clamp
- Send on Enter (not Shift+Enter which adds newline) — common chat UX
- "Stop generating" button: replaces Send button during streaming (per user decision). Button shows square icon (Stop) instead of arrow (Send). Calls `stopGeneration()` from useSSEChat.
- Disabled state while streaming (textarea disabled, stop button shown)
- Send button disabled when textarea is empty
- Use shadcn Textarea (if it exists) or plain textarea with Tailwind classes

**chat-header.tsx — Chat session header (per user decision):**
- Shows bot name, emoji avatar, and model badge (e.g., "Claude Sonnet") — per user decision
- Use shadcn Badge for model name
- Delete session button: trash icon, opens confirmation dialog
- Clear session button: eraser icon, clears messages but keeps session
- Layout: flex row with bot info left, action buttons right

**routes/chat/$sessionId.tsx — Session view:**
- Load session data from `useMessages(sessionId)` and bot data
- Layout: chat header at top, message list in scrollable middle, chat input fixed at bottom
- Wire up useSSEChat hook:
  - On send: call `sendMessage(botId, message, sessionId)`
  - On stream complete: invalidate messages query to refresh from server (the saved messages)
  - Pass `streamedContent` and `isStreaming` to message list
  - Pass `stopGeneration` to chat input
- After streaming completes and message is saved server-side, clear `streamedContent` and re-fetch messages query so the streamed content becomes a proper message in the list
  </action>
  <verify>
1. Navigate to a chat session — messages load and display
2. Type a message and press Enter — message appears, "Bot is thinking..." shows, then tokens stream in
3. Textarea auto-expands as you type multiple lines
4. Stop button appears during streaming and works
5. After streaming completes, the streamed content becomes a proper message
6. Chat header shows bot name, emoji, model badge
7. Delete and clear session actions work
  </verify>
  <done>
Complete chat interface: messages display with timestamps, auto-expanding input sends messages, streaming shows thinking indicator then live tokens, stop button works, chat header shows bot info. Full send-stream-save lifecycle works end-to-end.
  </done>
</task>

</tasks>

<verification>
1. Full chat flow: open chat -> select bot -> send message -> see streaming response -> response saved
2. Multiple sessions: can open tabs/sessions with different bots simultaneously
3. Same bot: can create multiple sessions with the same bot
4. Session sidebar groups correctly by bot name
5. Streaming is smooth without visible jank
6. Stop generation works mid-stream
7. Delete/clear session work correctly
</verification>

<success_criteria>
- Chat interface matches all user decisions: Slack-style sidebar, auto-expanding textarea, "thinking" indicator, stop button, relative timestamps, delete/clear sessions, bot name + emoji + model in header
- SSE streaming works end-to-end with real backend
- Multiple parallel sessions supported (CHAT-02, CHAT-03)
- No stale closure bugs in streaming
- Streaming component isolated to prevent list re-renders
</success_criteria>

<output>
After completion, create `.planning/phases/04-web-ui-core-fleet-dashboard/04-04-SUMMARY.md`
</output>
