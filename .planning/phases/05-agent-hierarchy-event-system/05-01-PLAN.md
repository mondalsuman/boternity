---
phase: 05-agent-hierarchy-event-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/boternity-types/Cargo.toml
  - crates/boternity-types/src/event.rs
  - crates/boternity-types/src/config.rs
  - crates/boternity-types/src/agent.rs
  - crates/boternity-types/src/lib.rs
  - crates/boternity-types/src/memory.rs
  - crates/boternity-core/Cargo.toml
  - crates/boternity-api/Cargo.toml
  - crates/boternity-infra/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "AgentEvent enum covers all event types needed for agent lifecycle, budget, and safety"
    - "SubAgentRequest and SubAgentResult types model spawn instructions and outcomes"
    - "GlobalConfig struct can deserialize config.toml with default_request_budget"
    - "MemoryEntry has source_agent_id field for sub-agent memory tagging"
    - "New workspace dependencies (dashmap, toml, tokio-util, axum ws) compile successfully"
  artifacts:
    - path: "crates/boternity-types/src/event.rs"
      provides: "AgentEvent enum with all event bus event types"
      contains: "pub enum AgentEvent"
    - path: "crates/boternity-types/src/config.rs"
      provides: "GlobalConfig, RequestBudgetConfig, ProviderPricing types"
      contains: "pub struct GlobalConfig"
    - path: "crates/boternity-types/src/agent.rs"
      provides: "SubAgentRequest, SubAgentResult, SpawnMode, AgentStatus, AgentNode types"
      contains: "pub enum SpawnMode"
  key_links:
    - from: "crates/boternity-types/src/event.rs"
      to: "uuid::Uuid"
      via: "agent_id fields on all event variants"
      pattern: "agent_id: Uuid"
    - from: "Cargo.toml"
      to: "crates/boternity-core/Cargo.toml"
      via: "workspace dependency declarations"
      pattern: "tokio-util"
---

<objective>
Define all domain types for the agent hierarchy, event bus, and config system, plus add new workspace dependencies.

Purpose: Establish the type foundation that all subsequent plans build on. Types are the API contract between components.
Output: New event.rs and config.rs modules in boternity-types, extended agent.rs and memory.rs, updated Cargo.toml files with new dependencies.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-agent-hierarchy-event-system/05-RESEARCH.md
@crates/boternity-types/src/agent.rs
@crates/boternity-types/src/memory.rs
@crates/boternity-types/src/llm.rs
@crates/boternity-types/src/lib.rs
@crates/boternity-types/Cargo.toml
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add workspace dependencies and update crate Cargo.toml files</name>
  <files>
    Cargo.toml
    crates/boternity-core/Cargo.toml
    crates/boternity-api/Cargo.toml
    crates/boternity-infra/Cargo.toml
  </files>
  <action>
Add new workspace-level dependencies to root Cargo.toml:
- `dashmap = { version = "6.1", features = ["serde"] }` -- concurrent shared workspace
- `toml = "0.8"` -- config.toml parsing
- `tokio-util = { version = "0.7", features = ["sync"] }` -- CancellationToken

Update axum workspace dependency to add "ws" feature:
- `axum = { version = "0.8", features = ["macros", "ws"] }` -- WebSocket support

Add to crates/boternity-core/Cargo.toml dependencies:
- `tokio-util = { workspace = true }` -- for CancellationToken
- `dashmap = { workspace = true }` -- for SharedWorkspace

Add to crates/boternity-api/Cargo.toml dependencies:
- `tokio-util = { workspace = true }` -- for CancellationToken (cancel commands)

Add to crates/boternity-infra/Cargo.toml dependencies:
- `toml = { workspace = true }` -- for config.toml parsing

Do NOT modify any existing dependency versions or features that are already there.
  </action>
  <verify>Run `cargo check --workspace` to confirm all dependencies resolve and the workspace compiles.</verify>
  <done>All new dependencies declared in workspace Cargo.toml and referenced in crate-level Cargo.toml files. `cargo check` passes.</done>
</task>

<task type="auto">
  <name>Task 2: Create event.rs, config.rs, extend agent.rs and memory.rs</name>
  <files>
    crates/boternity-types/src/event.rs
    crates/boternity-types/src/config.rs
    crates/boternity-types/src/agent.rs
    crates/boternity-types/src/memory.rs
    crates/boternity-types/src/lib.rs
  </files>
  <action>
**Create `crates/boternity-types/src/event.rs`:**

Define `AgentEvent` enum with serde tagged union (`#[serde(tag = "type", rename_all = "snake_case")]`):
- `AgentSpawned { agent_id: Uuid, parent_id: Option<Uuid>, task_description: String, depth: u8, index: usize, total: usize }` -- index/total for "agent 2 of 3" display
- `AgentTextDelta { agent_id: Uuid, text: String }` -- streaming token from sub-agent
- `AgentCompleted { agent_id: Uuid, result_summary: String, tokens_used: u32, duration_ms: u64 }` -- sub-agent finished
- `AgentFailed { agent_id: Uuid, error: String, will_retry: bool }` -- sub-agent error
- `AgentCancelled { agent_id: Uuid, reason: String }` -- sub-agent cancelled
- `BudgetUpdate { request_id: Uuid, tokens_used: u32, budget_total: u32, percentage: f32 }` -- periodic budget update
- `BudgetWarning { request_id: Uuid, tokens_used: u32, budget_total: u32 }` -- 80% threshold crossed
- `BudgetExhausted { request_id: Uuid, tokens_used: u32, budget_total: u32, completed_agents: Vec<Uuid>, incomplete_agents: Vec<Uuid> }` -- budget exceeded
- `DepthLimitReached { agent_id: Uuid, attempted_depth: u8, max_depth: u8 }` -- 4th level rejected
- `CycleDetected { agent_id: Uuid, cycle_description: String }` -- infinite loop detected
- `SynthesisStarted { request_id: Uuid }` -- root agent starting synthesis response
- `MemoryCreated { agent_id: Uuid, fact: String }` -- sub-agent created a memory
- `ProviderFailover { from_provider: String, to_provider: String, reason: String }` -- provider switched

All variants must derive Debug, Clone, Serialize, Deserialize. The enum itself must be Clone + Send + Sync (for broadcast channel).

Add `impl AgentEvent` with `pub fn agent_id(&self) -> Option<Uuid>` helper that returns the agent_id from variants that have one.

**Create `crates/boternity-types/src/config.rs`:**

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GlobalConfig {
    #[serde(default = "default_request_budget")]
    pub default_request_budget: u32,
    #[serde(default)]
    pub provider_pricing: Vec<ProviderPricing>,
}

fn default_request_budget() -> u32 { 500_000 }

impl Default for GlobalConfig {
    fn default() -> Self {
        Self {
            default_request_budget: default_request_budget(),
            provider_pricing: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProviderPricing {
    pub provider_name: String,
    pub model_pattern: String,
    pub input_cost_per_million: f64,
    pub output_cost_per_million: f64,
}
```

**Extend `crates/boternity-types/src/agent.rs`:**

Add after existing `AgentConfig`:

```rust
/// Mode for spawning sub-agents.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SpawnMode {
    Sequential,
    Parallel,
}

/// Parsed spawn instruction from LLM response.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SpawnInstruction {
    pub mode: SpawnMode,
    pub tasks: Vec<String>,
}

/// Status of a sub-agent during execution.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum AgentStatus {
    Pending,
    Running,
    Completed,
    Failed,
    Cancelled,
}

/// Result of a sub-agent execution.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubAgentResult {
    pub agent_id: Uuid,
    pub task: String,
    pub status: AgentStatus,
    pub response: Option<String>,
    pub error: Option<String>,
    pub tokens_used: u32,
    pub duration_ms: u64,
}

/// Node in the agent execution tree (for UI rendering).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentNode {
    pub agent_id: Uuid,
    pub parent_id: Option<Uuid>,
    pub task: String,
    pub depth: u8,
    pub status: AgentStatus,
    pub tokens_used: u32,
    pub duration_ms: u64,
    pub children: Vec<AgentNode>,
}
```

**Extend `crates/boternity-types/src/memory.rs`:**

Add `pub source_agent_id: Option<Uuid>` field to the `MemoryEntry` struct. Place it after the existing `is_manual` field. This field tracks which sub-agent created the memory (None for root agent). This is backward-compatible since existing memories will have None.

**Update `crates/boternity-types/src/lib.rs`:**

Add `pub mod event;` and `pub mod config;` to the module declarations.

**Tests:** Add unit tests for:
- AgentEvent serde round-trip (serialize + deserialize for each variant)
- GlobalConfig default values
- SpawnMode/AgentStatus Display/FromStr if applicable
- SubAgentResult construction
  </action>
  <verify>Run `cargo test -p boternity-types` -- all tests pass. Run `cargo check --workspace` -- no compilation errors from the new types or the source_agent_id addition.</verify>
  <done>All Phase 5 domain types exist in boternity-types. AgentEvent has 13 variants. GlobalConfig supports config.toml. SubAgentResult models execution outcomes. MemoryEntry has source_agent_id for sub-agent memory tagging. Workspace compiles.</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` passes with all new deps and types
- `cargo test -p boternity-types` passes all new tests
- `crates/boternity-types/src/event.rs` exists with AgentEvent enum
- `crates/boternity-types/src/config.rs` exists with GlobalConfig struct
- agent.rs has SpawnMode, SpawnInstruction, AgentStatus, SubAgentResult, AgentNode
- memory.rs MemoryEntry has source_agent_id field
</verification>

<success_criteria>
All domain types for Phase 5 are defined and compile. No runtime behavior yet -- this is pure type definition work. The workspace builds cleanly with all new dependencies.
</success_criteria>

<output>
After completion, create `.planning/phases/05-agent-hierarchy-event-system/05-01-SUMMARY.md`
</output>
