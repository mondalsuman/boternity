---
phase: 05-agent-hierarchy-event-system
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - crates/boternity-core/src/agent/budget.rs
  - crates/boternity-core/src/agent/workspace.rs
  - crates/boternity-core/src/agent/cycle_detector.rs
  - crates/boternity-core/src/agent/request_context.rs
  - crates/boternity-core/src/event/bus.rs
  - crates/boternity-core/src/event/mod.rs
  - crates/boternity-core/src/agent/mod.rs
  - crates/boternity-core/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "RequestBudget tracks token usage atomically and detects 80% warning threshold crossing exactly once"
    - "SharedWorkspace allows concurrent get/set without holding locks across await points"
    - "CycleDetector identifies repeated task signatures within an agent tree"
    - "RequestContext bundles budget + workspace + cancellation into a single clonable struct"
    - "EventBus distributes events to all subscribers via broadcast channel"
  artifacts:
    - path: "crates/boternity-core/src/agent/budget.rs"
      provides: "RequestBudget with AtomicU32 token tracking"
      contains: "pub struct RequestBudget"
    - path: "crates/boternity-core/src/agent/workspace.rs"
      provides: "SharedWorkspace with DashMap"
      contains: "pub struct SharedWorkspace"
    - path: "crates/boternity-core/src/agent/cycle_detector.rs"
      provides: "CycleDetector with HashSet task signature tracking"
      contains: "pub struct CycleDetector"
    - path: "crates/boternity-core/src/agent/request_context.rs"
      provides: "RequestContext bundling budget + workspace + cancellation"
      contains: "pub struct RequestContext"
    - path: "crates/boternity-core/src/event/bus.rs"
      provides: "EventBus wrapping tokio::sync::broadcast"
      contains: "pub struct EventBus"
  key_links:
    - from: "crates/boternity-core/src/agent/request_context.rs"
      to: "crates/boternity-core/src/agent/budget.rs"
      via: "RequestContext.budget field"
      pattern: "pub budget: RequestBudget"
    - from: "crates/boternity-core/src/event/bus.rs"
      to: "crates/boternity-types/src/event.rs"
      via: "broadcast::Sender<AgentEvent>"
      pattern: "broadcast::Sender<AgentEvent>"
---

<objective>
Build the core primitives: RequestBudget, SharedWorkspace, CycleDetector, RequestContext, and EventBus.

Purpose: These are the shared-state building blocks that the AgentOrchestrator and all sub-agents depend on. They must be correct, thread-safe, and well-tested before orchestration logic is built on top.
Output: Five new modules in boternity-core with comprehensive unit tests.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-agent-hierarchy-event-system/05-RESEARCH.md
@.planning/phases/05-agent-hierarchy-event-system/05-01-SUMMARY.md
@crates/boternity-core/src/agent/mod.rs
@crates/boternity-core/src/lib.rs
@crates/boternity-core/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: RequestBudget, SharedWorkspace, and CycleDetector</name>
  <files>
    crates/boternity-core/src/agent/budget.rs
    crates/boternity-core/src/agent/workspace.rs
    crates/boternity-core/src/agent/cycle_detector.rs
  </files>
  <action>
**Create `crates/boternity-core/src/agent/budget.rs`:**

```rust
use std::sync::atomic::{AtomicU32, Ordering};
use std::sync::Arc;
```

`RequestBudget` struct:
- `total_budget: u32` -- the budget limit
- `tokens_used: Arc<AtomicU32>` -- shared atomic counter
- `warning_emitted: Arc<std::sync::atomic::AtomicBool>` -- ensures warning fires exactly once
- Derive Clone

Methods:
- `pub fn new(total_budget: u32) -> Self` -- initializes with zero used
- `pub fn add_tokens(&self, tokens: u32) -> BudgetStatus` -- atomically adds tokens, returns status
- `pub fn tokens_used(&self) -> u32` -- current usage
- `pub fn total_budget(&self) -> u32` -- the limit
- `pub fn remaining(&self) -> u32` -- saturating_sub
- `pub fn percentage(&self) -> f32` -- used/total * 100

`BudgetStatus` enum:
- `Ok` -- under 80%
- `Warning` -- just crossed 80% (returned exactly once via AtomicBool CAS)
- `Exhausted` -- at or over 100%

The `add_tokens` logic: use `fetch_add(tokens, SeqCst)`, then check:
1. If `new_total >= total_budget` -> `Exhausted`
2. If `prev < threshold && new_total >= threshold` AND `warning_emitted.compare_exchange(false, true, SeqCst, SeqCst).is_ok()` -> `Warning`
3. Otherwise -> `Ok`

Where `threshold = total_budget * 80 / 100`.

Tests:
- add_tokens returns Ok when under budget
- add_tokens returns Warning exactly once when crossing 80%
- add_tokens returns Exhausted when at/over budget
- Multiple parallel add_tokens never returns Warning twice (use tokio::spawn test)
- remaining() is correct
- percentage() is correct

**Create `crates/boternity-core/src/agent/workspace.rs`:**

```rust
use std::sync::Arc;
use dashmap::DashMap;
use serde_json::Value;
```

`SharedWorkspace` struct:
- `inner: Arc<DashMap<String, Value>>`
- Derive Clone

Methods:
- `pub fn new() -> Self`
- `pub fn get(&self, key: &str) -> Option<Value>` -- returns CLONED value (never holds Ref across .await)
- `pub fn set(&self, key: String, value: Value)` -- insert/overwrite
- `pub fn remove(&self, key: &str) -> Option<Value>` -- remove and return
- `pub fn contains(&self, key: &str) -> bool`
- `pub fn keys(&self) -> Vec<String>` -- snapshot of all keys
- `pub fn len(&self) -> usize`
- `pub fn is_empty(&self) -> bool`

IMPORTANT: The `get` method must clone the Value, not return a DashMap Ref. Holding a Ref across an await point would deadlock.

Tests:
- set/get round-trip
- remove returns value
- concurrent access from multiple threads doesn't panic

**Create `crates/boternity-core/src/agent/cycle_detector.rs`:**

```rust
use std::collections::HashSet;
use std::hash::{Hash, Hasher, DefaultHasher};
use std::sync::{Arc, Mutex};
```

`CycleDetector` struct:
- `seen_signatures: Arc<Mutex<HashSet<u64>>>` -- task hash set (Mutex is fine, held only briefly for insert/check)
- `max_similar_tasks: usize` -- threshold (default 3, configurable)
- Derive Clone

Methods:
- `pub fn new() -> Self` -- default max_similar_tasks = 3
- `pub fn with_threshold(max: usize) -> Self`
- `pub fn check_and_register(&self, task: &str, depth: u8) -> CycleCheckResult`

`CycleCheckResult` enum:
- `Ok` -- task is new, registered
- `CycleDetected { description: String }` -- too many similar tasks seen

The check logic: hash the task string (normalize: lowercase, trim), check if it's already in the set. If inserting, track how many times similar hashes have been seen. Also use a simple counter per-hash approach: `HashMap<u64, usize>` instead of just `HashSet`, incrementing on each insert. If count > max_similar_tasks, return CycleDetected.

Actually, simpler and more robust: use `Arc<Mutex<HashMap<u64, usize>>>` where the value is the count. On `check_and_register`:
1. Hash the normalized task
2. Lock, get entry, increment count
3. If count > max_similar_tasks -> CycleDetected
4. Otherwise -> Ok

Tests:
- First occurrence returns Ok
- Repeated identical tasks eventually trigger CycleDetected
- Different tasks don't interfere
- Normalized whitespace/case doesn't create false negatives
  </action>
  <verify>Run `cargo test -p boternity-core -- budget workspace cycle_detector` -- all tests pass. Run `cargo check -p boternity-core` -- compiles.</verify>
  <done>RequestBudget, SharedWorkspace, and CycleDetector are implemented with comprehensive unit tests. Budget warning fires exactly once. Workspace clones values to prevent lock-across-await. CycleDetector catches repeated tasks.</done>
</task>

<task type="auto">
  <name>Task 2: RequestContext and EventBus</name>
  <files>
    crates/boternity-core/src/agent/request_context.rs
    crates/boternity-core/src/event/bus.rs
    crates/boternity-core/src/event/mod.rs
    crates/boternity-core/src/agent/mod.rs
    crates/boternity-core/src/lib.rs
  </files>
  <action>
**Create `crates/boternity-core/src/agent/request_context.rs`:**

```rust
use uuid::Uuid;
use tokio_util::sync::CancellationToken;
use super::budget::RequestBudget;
use super::workspace::SharedWorkspace;
use super::cycle_detector::CycleDetector;
```

`RequestContext` struct (all fields pub, derive Clone):
- `request_id: Uuid`
- `budget: RequestBudget`
- `workspace: SharedWorkspace`
- `cancellation: CancellationToken`
- `cycle_detector: CycleDetector`
- `depth: u8` -- current depth (root = 0)

Methods:
- `pub fn new(request_id: Uuid, budget: RequestBudget) -> Self` -- creates root context (depth 0)
- `pub fn child(&self) -> Self` -- creates child context: shares budget (Arc clone), shares workspace (Arc clone), shares cycle_detector (Arc clone), gets `cancellation.child_token()`, increments depth by 1
- `pub fn is_cancelled(&self) -> bool` -- checks cancellation token
- `pub fn cancel(&self)` -- cancels this context's token (and all children)

Important: The `child()` method increments depth. The orchestrator checks `depth >= 3` before spawning. Root is depth 0, sub-agents are 1/2/3. At depth 3, sub-agents can execute but cannot spawn further children (would be depth 4).

Tests:
- new creates root at depth 0
- child increments depth
- child shares same budget (add tokens in child, see in parent)
- child shares same workspace (set in child, get in parent)
- cancelling parent cancels child
- cancelling child does NOT cancel parent

**Create `crates/boternity-core/src/event/` module:**

Create `crates/boternity-core/src/event/mod.rs`:
```rust
pub mod bus;
pub use bus::EventBus;
```

**Create `crates/boternity-core/src/event/bus.rs`:**

```rust
use tokio::sync::broadcast;
use boternity_types::event::AgentEvent;
```

`EventBus` struct:
- `sender: broadcast::Sender<AgentEvent>`
- Derive Clone (manual impl: clone the sender)

Methods:
- `pub fn new(capacity: usize) -> Self` -- creates channel with given capacity (default recommendation: 1024)
- `pub fn subscribe(&self) -> broadcast::Receiver<AgentEvent>` -- new subscriber
- `pub fn publish(&self, event: AgentEvent)` -- sends event, ignores "no receivers" error (let _ = sender.send())
- `pub fn sender(&self) -> &broadcast::Sender<AgentEvent>` -- for when direct sender access needed

Implement Clone manually since broadcast::Sender is Clone:
```rust
impl Clone for EventBus {
    fn clone(&self) -> Self {
        Self { sender: self.sender.clone() }
    }
}
```

Tests:
- publish + subscribe delivers event
- multiple subscribers each receive the event
- publish with no subscribers doesn't panic
- lagged receiver handles gracefully (subscribe, publish many, try recv)

**Update `crates/boternity-core/src/agent/mod.rs`:**

Add module declarations:
```rust
pub mod budget;
pub mod cycle_detector;
pub mod request_context;
pub mod workspace;
```

**Update `crates/boternity-core/src/lib.rs`:**

Add `pub mod event;` to module declarations.
  </action>
  <verify>Run `cargo test -p boternity-core -- request_context event bus` -- all tests pass. Run `cargo check --workspace` -- compiles cleanly.</verify>
  <done>RequestContext bundles budget+workspace+cancellation+cycle_detector with child() for sub-agent spawning. EventBus wraps broadcast channel for multi-consumer event distribution. All modules exported. Workspace compiles.</done>
</task>

</tasks>

<verification>
- `cargo test -p boternity-core` passes all new tests
- `cargo check --workspace` compiles
- EventBus can publish and receive AgentEvent instances
- RequestContext.child() shares budget and workspace but gets child cancellation token
- CycleDetector catches repeated tasks at configurable threshold
- RequestBudget.add_tokens() returns Warning exactly once at 80%
</verification>

<success_criteria>
All five core primitives (RequestBudget, SharedWorkspace, CycleDetector, RequestContext, EventBus) are implemented, tested, and exported. They form the shared-state foundation for the AgentOrchestrator.
</success_criteria>

<output>
After completion, create `.planning/phases/05-agent-hierarchy-event-system/05-02-SUMMARY.md`
</output>
