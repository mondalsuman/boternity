---
phase: 05-agent-hierarchy-event-system
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - crates/boternity-core/src/agent/spawner.rs
  - crates/boternity-core/src/agent/context.rs
  - crates/boternity-core/src/agent/prompt.rs
  - crates/boternity-core/src/agent/mod.rs
autonomous: true

must_haves:
  truths:
    - "LLM responses containing <spawn_agents> XML blocks are parsed into SpawnInstruction structs"
    - "AgentContext.child_for_task() creates a fresh context with empty conversation history but inherited personality"
    - "System prompt includes <agent_capabilities> section instructing the LLM how to spawn sub-agents"
    - "Text outside <spawn_agents> tags is preserved as the pre-spawn message"
  artifacts:
    - path: "crates/boternity-core/src/agent/spawner.rs"
      provides: "parse_spawn_instructions() and extract_text_before_spawn()"
      contains: "pub fn parse_spawn_instructions"
    - path: "crates/boternity-core/src/agent/context.rs"
      provides: "child_for_task() method on AgentContext"
      contains: "pub fn child_for_task"
    - path: "crates/boternity-core/src/agent/prompt.rs"
      provides: "<agent_capabilities> section in system prompt"
      contains: "agent_capabilities"
  key_links:
    - from: "crates/boternity-core/src/agent/spawner.rs"
      to: "crates/boternity-types/src/agent.rs"
      via: "returns SpawnInstruction type"
      pattern: "SpawnInstruction"
    - from: "crates/boternity-core/src/agent/context.rs"
      to: "crates/boternity-core/src/agent/prompt.rs"
      via: "child_for_task calls build with task-scoped prompt"
      pattern: "child_for_task"
---

<objective>
Build the spawn instruction parser and AgentContext extensions for sub-agent creation.

Purpose: The spawner parses LLM responses for sub-agent instructions. The context extension creates isolated child contexts. The prompt extension teaches the LLM how to request sub-agents. These three components connect the LLM's decision to spawn with the orchestrator's execution.
Output: New spawner.rs module, extended context.rs and prompt.rs.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-agent-hierarchy-event-system/05-RESEARCH.md
@.planning/phases/05-agent-hierarchy-event-system/05-01-SUMMARY.md
@crates/boternity-core/src/agent/context.rs
@crates/boternity-core/src/agent/prompt.rs
@crates/boternity-core/src/agent/engine.rs
@crates/boternity-core/src/agent/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Spawn instruction parser (spawner.rs)</name>
  <files>
    crates/boternity-core/src/agent/spawner.rs
    crates/boternity-core/src/agent/mod.rs
  </files>
  <action>
**Create `crates/boternity-core/src/agent/spawner.rs`:**

Two public functions:

1. `pub fn parse_spawn_instructions(response: &str) -> Option<SpawnInstruction>` -- parses `<spawn_agents>` XML block from LLM response

The XML format the LLM produces:
```xml
<spawn_agents mode="parallel">
  <agent task="Research the history of quantum computing" />
  <agent task="Summarize recent breakthroughs in quantum error correction" />
</spawn_agents>
```

Or sequential:
```xml
<spawn_agents mode="sequential">
  <agent task="First, gather the raw data" />
  <agent task="Then, analyze the patterns" />
</spawn_agents>
```

Parsing logic:
- Find `<spawn_agents` start tag
- Find `</spawn_agents>` end tag
- If not found, return None
- Extract mode attribute: if contains `mode="sequential"` -> Sequential, default -> Parallel
- Extract all `task="..."` attributes from `<agent` tags within the block
- Collect into SpawnInstruction { mode, tasks }
- If no tasks found, return None
- Handle edge cases: nested quotes in task text (use a proper attribute parser that finds `task="` then reads until next unescaped `"`)

2. `pub fn extract_text_before_spawn(response: &str) -> &str` -- returns text before the `<spawn_agents` tag, trimmed. This is the "pre-spawn message" the bot says before delegating (e.g., "I'll break this down into sub-tasks...").

**Update `crates/boternity-core/src/agent/mod.rs`:**

Add `pub mod spawner;`

**Tests (in spawner.rs):**
- parse_spawn_instructions with parallel mode, 3 tasks
- parse_spawn_instructions with sequential mode, 2 tasks
- parse_spawn_instructions with no spawn block returns None
- parse_spawn_instructions with empty agent list returns None
- parse_spawn_instructions default mode is Parallel when no mode attr
- extract_text_before_spawn returns trimmed text before block
- extract_text_before_spawn returns full text when no spawn block
- Task text with special characters (commas, colons, parentheses) is preserved
- Multiple spawn blocks: only first is parsed (single spawn per response)
  </action>
  <verify>Run `cargo test -p boternity-core -- spawner` -- all tests pass.</verify>
  <done>Spawn instruction parser correctly extracts SpawnInstruction from LLM responses. Handles both sequential and parallel modes. Edge cases covered.</done>
</task>

<task type="auto">
  <name>Task 2: AgentContext.child_for_task() and SystemPromptBuilder agent_capabilities</name>
  <files>
    crates/boternity-core/src/agent/context.rs
    crates/boternity-core/src/agent/prompt.rs
  </files>
  <action>
**Extend `crates/boternity-core/src/agent/context.rs`:**

Add a `child_for_task` method to `AgentContext`:

```rust
/// Create a child context for a sub-agent task.
///
/// Inherits the bot's personality (SOUL.md) and model config but gets:
/// - Fresh conversation history (empty)
/// - Fresh recalled memories (empty)
/// - A task-focused system prompt with the task injected
///
/// The sub-agent responds in character (inherits soul) but is focused
/// on a specific task. Per user decision: sub-agents inherit parent bot's
/// personality and always use the same model.
pub fn child_for_task(&self, task: &str, depth: u8) -> Self {
    // Build a task-scoped system prompt that includes the soul but
    // adds task instructions
    let system_prompt = SystemPromptBuilder::build_for_sub_agent(
        &self.agent_config,
        &self.soul_content,
        &self.identity_content,
        task,
        depth,
    );

    Self {
        agent_config: self.agent_config.clone(),
        soul_content: self.soul_content.clone(),
        identity_content: self.identity_content.clone(),
        user_content: String::new(), // Sub-agents don't get USER.md
        memories: Vec::new(),        // Sub-agents start fresh
        recalled_memories: Vec::new(),
        conversation_history: Vec::new(), // FRESH -- critical per research pitfall 2
        token_budget: self.token_budget.clone(),
        system_prompt,
        verbose: self.verbose,
    }
}
```

**Extend `crates/boternity-core/src/agent/prompt.rs`:**

Add two new methods to `SystemPromptBuilder`:

1. `pub fn build_with_capabilities(...)` -- same as existing `build()` but appends an `<agent_capabilities>` section. This is used for the ROOT agent (depth 0) to teach it how to spawn sub-agents.

The `<agent_capabilities>` section content:
```text
<agent_capabilities>
You can decompose complex tasks by spawning sub-agents. To do this, include a spawn block in your response:

For parallel execution (tasks run simultaneously):
<spawn_agents mode="parallel">
  <agent task="Description of sub-task 1" />
  <agent task="Description of sub-task 2" />
</spawn_agents>

For sequential execution (each task sees the previous result):
<spawn_agents mode="sequential">
  <agent task="First step description" />
  <agent task="Second step description" />
</spawn_agents>

Guidelines:
- Only spawn sub-agents when the task genuinely benefits from decomposition
- Each task description should be specific and self-contained
- Sub-agents inherit your personality and respond in character
- You may include text before the spawn block to explain your approach
- After sub-agents complete, you will receive their results and should synthesize a cohesive response
- Sub-agents can spawn their own sub-agents up to 3 levels deep
</agent_capabilities>
```

This section is appended AFTER the `<instructions>` section, only when the agent has capabilities enabled.

2. `pub fn build_for_sub_agent(config, soul, identity, task, depth) -> String` -- builds a focused system prompt for sub-agents:
- Includes `<soul>` section (sub-agents stay in character per user decision)
- Includes `<identity>` section
- Includes a `<task>` section with the specific task
- Includes `<sub_agent_instructions>` section: "You are executing a focused sub-task. Respond with your result directly. Be thorough but stay focused on the task."
- If depth < 3, also includes `<agent_capabilities>` section (recursive spawning allowed per user decision)
- Does NOT include user_context, session_memory, or long_term_memory (sub-agents get fresh context)

**Tests:**
- child_for_task has empty conversation history
- child_for_task inherits soul_content and agent_config
- child_for_task has task-focused system prompt containing <task>
- build_with_capabilities includes <agent_capabilities> section
- build_for_sub_agent includes soul but not user_context
- build_for_sub_agent at depth < 3 includes agent_capabilities
- build_for_sub_agent at depth 3 does NOT include agent_capabilities
  </action>
  <verify>Run `cargo test -p boternity-core -- context prompt spawner` -- all tests pass. Run `cargo check --workspace` -- compiles.</verify>
  <done>AgentContext.child_for_task() creates isolated sub-agent contexts with inherited personality. SystemPromptBuilder teaches the LLM to spawn sub-agents via XML and builds focused sub-agent prompts. Recursive spawning enabled for depth < 3.</done>
</task>

</tasks>

<verification>
- `cargo test -p boternity-core` passes all new and existing tests
- `cargo check --workspace` compiles
- parse_spawn_instructions correctly extracts parallel/sequential tasks from LLM output
- child_for_task produces isolated context with fresh history but same soul
- System prompt has <agent_capabilities> for root agents
- Sub-agent prompts have <task> section and respect depth limits for recursive spawning
</verification>

<success_criteria>
The spawn instruction parser, context creation, and prompt extensions are complete. An LLM response with `<spawn_agents>` tags can be parsed into a SpawnInstruction. A child AgentContext can be created for each task. The system prompt teaches the LLM the spawn protocol.
</success_criteria>

<output>
After completion, create `.planning/phases/05-agent-hierarchy-event-system/05-03-SUMMARY.md`
</output>
