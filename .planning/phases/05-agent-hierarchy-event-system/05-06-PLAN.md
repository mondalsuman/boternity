---
phase: 05-agent-hierarchy-event-system
plan: 06
type: execute
wave: 3
depends_on: ["05-02", "05-05"]
files_modified:
  - crates/boternity-api/src/http/handlers/ws.rs
  - crates/boternity-api/src/http/handlers/mod.rs
  - crates/boternity-api/src/http/router.rs
  - crates/boternity-api/src/state.rs
autonomous: true

must_haves:
  truths:
    - "WebSocket endpoint at /ws/events accepts connections and forwards AgentEvent from EventBus"
    - "WebSocket receives bidirectional commands: cancel_agent, budget_continue, budget_stop"
    - "EventBus is on AppState and shared between HTTP handlers and WebSocket"
    - "Lagged WebSocket receivers are handled gracefully (log and continue)"
  artifacts:
    - path: "crates/boternity-api/src/http/handlers/ws.rs"
      provides: "WebSocket upgrade handler + event forwarding + command receiving"
      contains: "pub async fn ws_handler"
    - path: "crates/boternity-api/src/state.rs"
      provides: "EventBus and GlobalConfig on AppState"
      contains: "event_bus"
  key_links:
    - from: "crates/boternity-api/src/http/handlers/ws.rs"
      to: "crates/boternity-core/src/event/bus.rs"
      via: "subscribes to EventBus from AppState"
      pattern: "event_bus\\.subscribe"
    - from: "crates/boternity-api/src/http/router.rs"
      to: "crates/boternity-api/src/http/handlers/ws.rs"
      via: "route /ws/events"
      pattern: "/ws/events"
    - from: "crates/boternity-api/src/state.rs"
      to: "crates/boternity-core/src/event/bus.rs"
      via: "EventBus field on AppState"
      pattern: "pub event_bus"
---

<objective>
Add WebSocket infrastructure for real-time agent events and bidirectional commands. Wire the EventBus into AppState.

Purpose: WebSocket is the transport for agent hierarchy events to the web UI. It also receives commands (cancel agent, budget continue/stop) from the frontend. The EventBus on AppState connects the orchestrator (which publishes events) to WebSocket (which forwards them).
Output: WebSocket handler, EventBus on AppState, /ws/events route.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-agent-hierarchy-event-system/05-RESEARCH.md
@.planning/phases/05-agent-hierarchy-event-system/05-01-SUMMARY.md
@.planning/phases/05-agent-hierarchy-event-system/05-02-SUMMARY.md
@.planning/phases/05-agent-hierarchy-event-system/05-05-SUMMARY.md
@crates/boternity-api/src/http/router.rs
@crates/boternity-api/src/http/handlers/mod.rs
@crates/boternity-api/src/state.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: WebSocket handler with event forwarding and command receiving</name>
  <files>
    crates/boternity-api/src/http/handlers/ws.rs
    crates/boternity-api/src/http/handlers/mod.rs
  </files>
  <action>
**Create `crates/boternity-api/src/http/handlers/ws.rs`:**

```rust
use axum::extract::ws::{Message, WebSocket, WebSocketUpgrade};
use axum::extract::State;
use axum::response::IntoResponse;
use futures_util::{SinkExt, StreamExt};
use tokio::sync::broadcast;
use uuid::Uuid;

use crate::state::AppState;
```

Define incoming command types:

```rust
#[derive(Debug, serde::Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
enum WsCommand {
    CancelAgent { agent_id: String },
    BudgetContinue { request_id: String },
    BudgetStop { request_id: String },
    Ping,
}
```

**`ws_handler` function:**
```rust
pub async fn ws_handler(
    ws: WebSocketUpgrade,
    State(state): State<AppState>,
) -> impl IntoResponse {
    ws.on_upgrade(move |socket| handle_ws_connection(socket, state))
}
```

**`handle_ws_connection` function:**

This is the core WebSocket connection handler. It uses `socket.split()` to create independent sender and receiver tasks:

1. **Send task** (event forwarding): Subscribes to EventBus, receives AgentEvents, serializes to JSON, sends as Text messages. Handle `RecvError::Lagged(n)` by logging a warning and continuing (per research pitfall 1). Handle `RecvError::Closed` by breaking.

2. **Receive task** (command processing): Reads incoming Text messages, parses as WsCommand, processes:
   - `CancelAgent { agent_id }`: Store the cancellation request. The actual cancellation is handled by the orchestrator via a shared cancellation registry (for now, publish a cancel event on the bus or store in a shared map). For the initial implementation, store cancel requests in a `DashMap<Uuid, CancellationToken>` on AppState (added in Task 2). Look up the agent_id, call `.cancel()` on its token.
   - `BudgetContinue { request_id }`: Send on the budget continue channel. For initial implementation, store `oneshot::Sender<bool>` in a shared map on AppState, keyed by request_id. Send `true`.
   - `BudgetStop { request_id }`: Same as above but send `false`.
   - `Ping`: respond with `{"type": "pong"}`
   - Unknown/malformed: log warning, ignore

3. Use `tokio::select!` on both tasks. When either ends, the connection is done. Clean up.

**Per research pitfall 4 (WebSocket Disconnect During Agent Execution):**
- On disconnect, DON'T immediately cancel agents -- the user might reconnect
- The orchestrator manages its own lifecycle. WebSocket is purely for UI updates.
- If the user wants to cancel, they explicitly send CancelAgent commands.

**Update `crates/boternity-api/src/http/handlers/mod.rs`:**
Add `pub mod ws;`
  </action>
  <verify>Run `cargo check -p boternity-api` -- compiles with the new ws handler.</verify>
  <done>WebSocket handler forwards EventBus events to connected clients and receives cancel/budget commands. Lagged receivers handled gracefully.</done>
</task>

<task type="auto">
  <name>Task 2: Wire EventBus and shared registries into AppState + add route</name>
  <files>
    crates/boternity-api/src/state.rs
    crates/boternity-api/src/http/router.rs
  </files>
  <action>
**Extend `crates/boternity-api/src/state.rs`:**

Add new imports:
```rust
use boternity_core::event::EventBus;
use boternity_types::config::GlobalConfig;
use dashmap::DashMap;
use tokio_util::sync::CancellationToken;
use tokio::sync::oneshot;
```

Add new fields to `AppState`:
```rust
// --- Phase 5 services ---
/// Event bus for agent lifecycle events (broadcast to WebSocket + CLI).
pub event_bus: EventBus,
/// Global configuration from ~/.boternity/config.toml.
pub global_config: GlobalConfig,
/// Active agent cancellation tokens, keyed by agent_id.
/// Inserted by orchestrator when spawning, removed on completion.
pub agent_cancellations: Arc<DashMap<Uuid, CancellationToken>>,
/// Budget pause channels, keyed by request_id.
/// Orchestrator inserts sender, WebSocket handler sends continue/stop decision.
pub budget_responses: Arc<DashMap<Uuid, oneshot::Sender<bool>>>,
```

In `AppState::init()`:
- Load global config: `let global_config = boternity_infra::config::load_global_config(&data_dir).await;`
- Create event bus: `let event_bus = EventBus::new(1024);`
- Create empty registries: `let agent_cancellations = Arc::new(DashMap::new());` and `let budget_responses = Arc::new(DashMap::new());`
- Add all to the returned Self

Note: boternity-api Cargo.toml already has `dashmap` via workspace. tokio-util is added in plan 01. Ensure both are imported.

**Extend `crates/boternity-api/src/http/router.rs`:**

Add the WebSocket route. It goes OUTSIDE the `/api/v1` nest since WebSocket is not a REST endpoint:

```rust
// Before the `let mut router = ...` line, or add it to the router:
.route("/ws/events", get(handlers::ws::ws_handler))
```

Place it alongside the `/health` route (outside /api/v1 nest). The WebSocket upgrade happens via HTTP GET with Upgrade header, so it uses `get()`.

**Update Cargo.toml if needed:** Ensure `dashmap` and `tokio-util` workspace deps are in boternity-api's Cargo.toml (should be added in plan 01).
  </action>
  <verify>Run `cargo check --workspace` -- compiles. Verify the /ws/events route is registered by inspecting router.rs.</verify>
  <done>EventBus on AppState enables event publishing from orchestrator and consumption by WebSocket. Agent cancellation registry enables per-agent cancel from web UI. Budget response channels enable pause/continue flow. /ws/events route registered.</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- WebSocket handler at /ws/events is registered in router
- AppState has event_bus, global_config, agent_cancellations, budget_responses fields
- WebSocket handler subscribes to EventBus and forwards events
- WebSocket handler processes CancelAgent, BudgetContinue, BudgetStop commands
- Lagged receivers logged and recovered gracefully
</verification>

<success_criteria>
WebSocket infrastructure is complete. A frontend client can connect to /ws/events and receive agent events in real-time. The client can send cancel and budget commands. The EventBus bridges the orchestrator (publisher) with all consumers (WebSocket, CLI).
</success_criteria>

<output>
After completion, create `.planning/phases/05-agent-hierarchy-event-system/05-06-SUMMARY.md`
</output>
