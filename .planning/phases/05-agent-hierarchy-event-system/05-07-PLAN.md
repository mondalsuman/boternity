---
phase: 05-agent-hierarchy-event-system
plan: 07
type: execute
wave: 4
depends_on: ["05-04", "05-05", "05-06"]
files_modified:
  - crates/boternity-api/src/cli/chat/tree_renderer.rs
  - crates/boternity-api/src/cli/chat/budget_display.rs
  - crates/boternity-api/src/cli/chat/loop_runner.rs
  - crates/boternity-api/src/cli/chat/mod.rs
  - crates/boternity-api/src/http/handlers/chat.rs
autonomous: true

must_haves:
  truths:
    - "CLI displays sub-agent output with tree indentation using Unicode box-drawing characters"
    - "CLI shows live running budget counter during sub-agent execution"
    - "CLI chat loop uses AgentOrchestrator when spawning is detected"
    - "HTTP SSE chat handler uses AgentOrchestrator and emits sub-agent events"
    - "Budget pause prompt works in CLI (stdin) and HTTP (WebSocket command)"
    - "--quiet flag suppresses sub-agent detail, showing only final synthesis"
    - "Ctrl+C cancels entire sub-agent tree in CLI"
    - "User can type 'cancel N' to stop individual sub-agent in CLI"
  artifacts:
    - path: "crates/boternity-api/src/cli/chat/tree_renderer.rs"
      provides: "CLI tree rendering with box-drawing chars and colored agent labels"
      contains: "pub fn render_agent_header"
    - path: "crates/boternity-api/src/cli/chat/budget_display.rs"
      provides: "Live budget counter and cost estimate formatting"
      contains: "pub fn render_budget_counter"
    - path: "crates/boternity-api/src/cli/chat/loop_runner.rs"
      provides: "Orchestrator-integrated chat loop with cancel and budget support"
      contains: "AgentOrchestrator"
    - path: "crates/boternity-api/src/http/handlers/chat.rs"
      provides: "SSE chat handler with orchestrator and sub-agent event streaming"
      contains: "AgentOrchestrator"
  key_links:
    - from: "crates/boternity-api/src/cli/chat/loop_runner.rs"
      to: "crates/boternity-core/src/agent/orchestrator.rs"
      via: "calls orchestrator.execute()"
      pattern: "orchestrator\\.execute"
    - from: "crates/boternity-api/src/http/handlers/chat.rs"
      to: "crates/boternity-core/src/agent/orchestrator.rs"
      via: "calls orchestrator.execute() and streams events"
      pattern: "orchestrator\\.execute"
    - from: "crates/boternity-api/src/cli/chat/tree_renderer.rs"
      to: "crates/boternity-types/src/event.rs"
      via: "renders AgentEvent variants as tree output"
      pattern: "AgentEvent"
---

<objective>
Integrate the AgentOrchestrator into both the CLI chat loop and the HTTP SSE chat handler. Build the CLI tree renderer and budget display.

Purpose: This connects the orchestrator to the actual user interfaces. The CLI gets tree-indented sub-agent output with live budget counters. The HTTP handler gets sub-agent events interleaved with SSE text deltas.
Output: Updated chat loop and SSE handler, new tree renderer and budget display modules.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-agent-hierarchy-event-system/05-RESEARCH.md
@.planning/phases/05-agent-hierarchy-event-system/05-01-SUMMARY.md
@.planning/phases/05-agent-hierarchy-event-system/05-02-SUMMARY.md
@.planning/phases/05-agent-hierarchy-event-system/05-03-SUMMARY.md
@.planning/phases/05-agent-hierarchy-event-system/05-04-SUMMARY.md
@.planning/phases/05-agent-hierarchy-event-system/05-05-SUMMARY.md
@.planning/phases/05-agent-hierarchy-event-system/05-06-SUMMARY.md
@crates/boternity-api/src/cli/chat/loop_runner.rs
@crates/boternity-api/src/cli/chat/renderer.rs
@crates/boternity-api/src/cli/chat/mod.rs
@crates/boternity-api/src/http/handlers/chat.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: CLI tree renderer and budget display</name>
  <files>
    crates/boternity-api/src/cli/chat/tree_renderer.rs
    crates/boternity-api/src/cli/chat/budget_display.rs
    crates/boternity-api/src/cli/chat/mod.rs
  </files>
  <action>
**Create `crates/boternity-api/src/cli/chat/tree_renderer.rs`:**

Per user decision: "CLI uses tree indentation for sub-agent output (e.g., tree characters with depth-based nesting)" and "Parallel sub-agents display as interleaved output in CLI, each line prefixed by its position in the tree."

Constants (Unicode box-drawing):
```rust
const BRANCH: &str = "\u{251C}\u{2500}\u{2500}"; // +--
const LAST:   &str = "\u{2514}\u{2500}\u{2500}"; // L--
const PIPE:   &str = "\u{2502}   ";               // |
const SPACE:  &str = "    ";
```

Functions:

1. `pub fn render_agent_header(depth: u8, index: usize, total: usize, task: &str) -> String`
   - Renders: `  +-- agent-1: Research quantum computing history...`
   - Indent based on depth (2 spaces per level)
   - Branch character: LAST if index == total - 1, BRANCH otherwise
   - Agent label in cyan via `console::style`
   - Task truncated to 60 chars with ellipsis

2. `pub fn render_agent_text_line(depth: u8, index: usize, total: usize, text: &str) -> String`
   - Renders continuation lines under an agent
   - Uses PIPE or SPACE for indent continuation
   - Text is NOT colored (just indented)

3. `pub fn render_agent_completion(depth: u8, index: usize, total: usize, tokens: u32, duration_ms: u64) -> String`
   - Renders: `  |   | 2,450 tokens . 3.2s`
   - Per user decision: "Collapsed sub-agent blocks always show tokens used and duration"
   - Tokens formatted with comma separators
   - Duration in seconds with 1 decimal

4. `pub fn render_depth_limit_warning(depth: u8, max: u8) -> String`
   - Renders warning in yellow: `  ! Depth limit reached (attempted depth {depth}, max {max})`

5. `pub fn render_cycle_warning(description: &str) -> String`
   - Renders warning in yellow: `  ! Cycle detected: {description}`

6. `pub fn format_tokens_human(n: u32) -> String`
   - 1234567 -> "1,234,567"
   - Uses manual comma insertion (no external dep)

**Create `crates/boternity-api/src/cli/chat/budget_display.rs`:**

Per user decision: "CLI shows a live running budget counter during sub-agent execution (e.g., [tokens: 12,450 / 500,000])" and "Completed requests show estimated cost alongside token count (e.g., ~$0.12 estimated)."

Functions:

1. `pub fn render_budget_counter(used: u32, total: u32) -> String`
   - Renders: `  [tokens: 12,450 / 500,000]`
   - Yellow when >= 80%, dim otherwise
   - Uses format_tokens_human from tree_renderer

2. `pub fn render_budget_warning_prompt() -> String`
   - Renders: `  ! Budget 80% used. Continue? (y/n)`
   - Yellow, bold

3. `pub fn render_budget_exhausted(used: u32, total: u32, completed: usize, incomplete: usize) -> String`
   - Renders warning about budget exhaustion with counts of completed/incomplete agents

4. `pub fn render_completion_stats(tokens_used: u32, budget_total: u32, cost_estimate: f64, duration_secs: f64) -> String`
   - Per user decision: "Completed requests show estimated cost alongside token count"
   - Renders: `  [tokens: 6,740 / 500,000 . ~$0.04 estimated . 8.1s]`
   - Per specific idea: "Cost estimates should be clearly labeled as estimates"

**Update `crates/boternity-api/src/cli/chat/mod.rs`:**
Add `pub mod tree_renderer;` and `pub mod budget_display;`

**Tests:**
- render_agent_header with depth 0, 1, 2
- render_agent_header last item uses LAST branch
- format_tokens_human with various magnitudes
- render_budget_counter colors change at 80%
- render_completion_stats includes cost estimate
  </action>
  <verify>Run `cargo test -p boternity-api -- tree_renderer budget_display` -- all tests pass.</verify>
  <done>CLI tree renderer produces Unicode box-drawing tree output with colored agent labels. Budget display shows live counter with cost estimates. Both modules tested.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate orchestrator into CLI loop and HTTP SSE handler</name>
  <files>
    crates/boternity-api/src/cli/chat/loop_runner.rs
    crates/boternity-api/src/http/handlers/chat.rs
  </files>
  <action>
**Extend `crates/boternity-api/src/cli/chat/loop_runner.rs`:**

The existing loop_runner uses FallbackChain to stream responses directly. The orchestrator wraps this: it does the initial LLM call, detects spawn instructions, manages sub-agents, and produces a final response.

Key changes to the main chat loop function:

1. **Create orchestrator and request context at loop start:**
   - Create `AgentOrchestrator::new()` with max_depth 3
   - Load global config from AppState
   - Resolve request budget per message: `boternity_infra::config::resolve_request_budget(&state.global_config, identity_fm.max_request_tokens)`
   - For each user message: create a new `RequestContext::new(Uuid::now_v7(), RequestBudget::new(budget))`

2. **Subscribe to EventBus for CLI rendering:**
   - `let mut event_rx = state.event_bus.subscribe();`
   - Spawn a rendering task that processes AgentEvents from the bus:
     - `AgentSpawned` -> print tree header via tree_renderer
     - `AgentTextDelta` -> print indented text
     - `AgentCompleted` -> print completion stats
     - `AgentFailed` -> print error
     - `AgentCancelled` -> print cancellation note
     - `BudgetUpdate` -> update budget counter display (overwrite line)
     - `BudgetWarning` -> print warning, prompt for continue/stop via stdin
     - `BudgetExhausted` -> print exhaustion message
     - `DepthLimitReached` -> print warning
     - `CycleDetected` -> print warning
   - Per user decision: "--quiet flag suppresses sub-agent detail, showing only the final synthesized response"
   - If quiet mode: skip all sub-agent rendering, only show final synthesis

3. **Budget pause prompt flow (CLI):**
   - When BudgetWarning is received: print the prompt
   - Read stdin for y/n (must be done in a separate task since the event loop is running)
   - Per research pitfall 6: "During sub-agent execution, spawn a separate tokio task reading stdin for cancel commands"
   - Send result on the budget continue channel

4. **Cancel support:**
   - Per user decision: "CLI: numbered agents in tree output, user types `cancel 2` to stop agent #2"
   - During execution, spawn an input task that reads for `cancel N` commands
   - Look up agent by number (index from AgentSpawned event), cancel its token
   - Per user decision: "Ctrl+C in CLI cancels the entire sub-agent tree"
   - Register Ctrl+C handler that cancels the root CancellationToken

5. **Two-path execution:**
   - For simple messages (no sub-agents): the orchestrator returns directly, render as before (streaming)
   - For complex messages (with sub-agents): the orchestrator handles the tree, events render in real-time, final synthesis is printed at the end

**Important:** The existing streaming flow (FallbackChain.select_stream -> consume events) must be preserved for simple single-agent responses. The orchestrator should be able to detect the simple path early and fall through to the existing code path for minimal overhead.

**Extend `crates/boternity-api/src/http/handlers/chat.rs`:**

The SSE handler needs to emit both regular text_delta events AND agent hierarchy events. The approach:

1. Use the orchestrator for the LLM call instead of direct FallbackChain streaming
2. Subscribe to EventBus at the start of the request
3. Use `tokio::select!` in the SSE stream to interleave:
   - Text deltas from the orchestrator (via the provider stream)
   - AgentEvents from the EventBus subscription

4. New SSE event types (in addition to existing session, text_delta, usage, done, error):
   - `agent_spawned` -> `{ agent_id, parent_id, task, depth, index, total }`
   - `agent_text_delta` -> `{ agent_id, text }`
   - `agent_completed` -> `{ agent_id, tokens_used, duration_ms }`
   - `agent_failed` -> `{ agent_id, error, will_retry }`
   - `agent_cancelled` -> `{ agent_id, reason }`
   - `budget_update` -> `{ tokens_used, budget_total, percentage }`
   - `budget_warning` -> `{ tokens_used, budget_total }`
   - `budget_exhausted` -> `{ tokens_used, budget_total }`
   - `depth_limit` -> `{ agent_id, attempted_depth, max_depth }`
   - `cycle_detected` -> `{ agent_id, description }`
   - `synthesis_started` -> `{}`

5. The budget pause flow for HTTP: When orchestrator hits 80%, it publishes BudgetWarning and waits on a oneshot channel. The SSE sends `budget_warning`. The frontend sends `budget_continue` or `budget_stop` via WebSocket. The WS handler delivers it via the shared budget_responses map.

**Implementation approach for the HTTP handler:** Since the orchestrator is async and the SSE stream is a generator, the cleanest approach is:
- Spawn the orchestrator in a background task
- The SSE stream reads from the EventBus subscriber + a result channel
- When orchestrator completes, it sends the final result on a channel
- The SSE stream emits events as they arrive and the final synthesis when complete

```rust
let (result_tx, mut result_rx) = tokio::sync::mpsc::channel(1);
let mut event_rx = state.event_bus.subscribe();

// Spawn orchestrator
let orchestrator_handle = tokio::spawn(async move {
    let result = orchestrator.execute(...).await;
    let _ = result_tx.send(result).await;
});

// SSE stream reads from both event_rx and result_rx
let sse_stream = async_stream::stream! {
    // ... emit session event
    loop {
        tokio::select! {
            event = event_rx.recv() => {
                // Forward agent events as SSE
            }
            result = result_rx.recv() => {
                // Emit final synthesis
                break;
            }
        }
    }
    // ... emit done
};
```
  </action>
  <verify>Run `cargo check --workspace` -- compiles. Run `cargo test -p boternity-api` -- existing tests still pass. The integration is verified by running the actual CLI (`cargo run -- chat <bot>`) in a later checkpoint.</verify>
  <done>CLI chat loop uses AgentOrchestrator with tree rendering, live budget counter, cancel support, and --quiet flag. HTTP SSE handler uses orchestrator with sub-agent events interleaved as SSE event types. Budget pause works via stdin (CLI) and WebSocket (HTTP).</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- `cargo test -p boternity-api` passes
- CLI tree_renderer and budget_display modules exist and are tested
- loop_runner.rs imports and uses AgentOrchestrator
- chat.rs SSE handler emits agent_spawned, agent_text_delta, agent_completed events
- Budget pause flow is wired for both CLI (stdin) and HTTP (WebSocket)
</verification>

<success_criteria>
Both CLI and HTTP interfaces are orchestrator-aware. The CLI shows sub-agent progress with tree indentation and live budget. The HTTP SSE handler streams agent events alongside text deltas. Budget pause/continue works end-to-end in both interfaces.
</success_criteria>

<output>
After completion, create `.planning/phases/05-agent-hierarchy-event-system/05-07-SUMMARY.md`
</output>
