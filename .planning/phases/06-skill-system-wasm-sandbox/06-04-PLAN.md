---
phase: 06-skill-system-wasm-sandbox
plan: 04
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - crates/boternity-core/src/skill/resolver.rs
  - crates/boternity-core/src/skill/inheritance.rs
  - crates/boternity-core/src/skill/mod.rs
autonomous: true

must_haves:
  truths:
    - "Skill dependencies are resolved in correct topological order"
    - "Circular dependencies are detected and produce clear error messages"
    - "Diamond dependency conflicts are detected before installation"
    - "Skill inheritance resolves up to 3 levels deep with multi-parent mixin composition"
    - "conflicts_with declarations are enforced across inheritance chains"
  artifacts:
    - path: "crates/boternity-core/src/skill/resolver.rs"
      provides: "Dependency resolution with cycle detection"
      contains: "resolve_dependencies"
    - path: "crates/boternity-core/src/skill/inheritance.rs"
      provides: "Mixin composition inheritance resolver"
      contains: "resolve_inheritance"
  key_links:
    - from: "crates/boternity-core/src/skill/resolver.rs"
      to: "petgraph"
      via: "DiGraph + toposort for dependency ordering"
      pattern: "toposort"
    - from: "crates/boternity-core/src/skill/inheritance.rs"
      to: "boternity_types::skill::SkillManifest"
      via: "parent traversal from manifest.metadata.parents"
      pattern: "metadata.*parents"
---

<objective>
Implement skill dependency resolution and inheritance composition.

Purpose: Skills declare dependencies on other skills and parent skills for inheritance. Before installation, dependencies must be resolved in order (with cycle detection). Before execution, inherited capabilities must be merged following the mixin/composition model. Both are graph problems that petgraph handles cleanly.

Output: Dependency resolver (petgraph-based DAG with toposort) and inheritance resolver (max 3 levels, multi-parent, last-wins ordering) in boternity-core.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-skill-system-wasm-sandbox/06-CONTEXT.md
@.planning/phases/06-skill-system-wasm-sandbox/06-RESEARCH.md
@crates/boternity-types/src/skill.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dependency resolver with cycle detection</name>
  <files>crates/boternity-core/src/skill/resolver.rs, crates/boternity-core/src/skill/mod.rs</files>
  <action>
Create `crates/boternity-core/src/skill/resolver.rs`:

Use petgraph to build a directed graph of skill dependencies and produce a topological install order.

**`resolve_dependencies(skill_name: &str, all_skills: &HashMap<String, SkillManifest>) -> anyhow::Result<Vec<String>>`**
- Build a DiGraph<String, ()> from skill dependency declarations
- For each skill, add edges from skill -> each dependency
- Run `toposort()` which errors on cycles
- On cycle error, extract the node name and return: "Circular dependency detected involving skill: {name}"
- Reverse the result (dependencies first, dependents last)
- Return the ordered install list

**`check_version_conflicts(install_list: &[String], all_skills: &HashMap<String, SkillManifest>) -> anyhow::Result<()>`**
- For each pair of skills in the install list, check if they share a dependency with incompatible version ranges
- If Skill A requires dep ^1.0 and Skill B requires dep ^2.0, return error: "Skill '{a}' requires {dep} {range_a}, but Skill '{b}' requires {dep} {range_b}. Cannot install both."
- Per user decision: "Dependency conflicts fail with clear explanation -- user resolves manually"
- Use `semver::VersionReq` for range parsing

**`check_conflicts_with(skill_name: &str, installed_skills: &[String], all_skills: &HashMap<String, SkillManifest>) -> anyhow::Result<()>`**
- Check if the skill being installed declares conflicts_with any already-installed skill
- Check reverse: if any installed skill declares conflicts_with the new skill
- Return error listing the conflict: "Skill '{new}' conflicts with installed skill '{existing}'"

Add `pub mod resolver;` to skill/mod.rs.

Unit tests:
- Simple A -> B -> C dependency chain resolves correctly (C, B, A)
- A -> B, A -> C (no deps between B and C) resolves with B and C before A
- Circular A -> B -> A detected with clear error
- Diamond: A -> C, B -> C resolves without error
- Version conflict detected between incompatible ranges
- conflicts_with prevents installation
  </action>
  <verify>Run `cargo test -p boternity-core -- skill::resolver` -- all tests pass.</verify>
  <done>Dependencies resolve in correct topological order. Cycles, version conflicts, and skill conflicts are detected and reported clearly.</done>
</task>

<task type="auto">
  <name>Task 2: Inheritance mixin composition resolver</name>
  <files>crates/boternity-core/src/skill/inheritance.rs, crates/boternity-core/src/skill/mod.rs</files>
  <action>
Create `crates/boternity-core/src/skill/inheritance.rs`:

Implements the mixin/composition model per user decisions:
- Child composes parent's capabilities ADDITIVELY (no overriding)
- Max 3 levels of inheritance depth (skill, parent, grandparent)
- Multiple parent composition allowed
- Last-wins ordering for capability conflicts when composing multiple parents
- Circular inheritance detected and prevented

**`resolve_inheritance(skill_name: &str, all_skills: &HashMap<String, SkillManifest>, depth: usize) -> anyhow::Result<ResolvedSkill>`**
Where `ResolvedSkill` is:
```rust
pub struct ResolvedSkill {
    pub name: String,
    pub capabilities: Vec<Capability>,
    pub parents: Vec<String>,  // resolved parent chain
    pub depth: usize,
}
```

Algorithm:
1. If depth > 3, return error: "Inheritance depth exceeded (max 3 levels) for skill: {name}"
2. Get manifest for skill_name
3. Start with the skill's own capabilities
4. For each parent in manifest.metadata.parents (if any):
   a. Recursively resolve_inheritance(parent, all_skills, depth + 1)
   b. Merge parent capabilities into the result (additive)
5. For capability conflicts across multiple parents: last parent in the list wins
6. Check for circular inheritance (use a HashSet of visited skill names passed through recursion)

**`check_circular_inheritance(skill_name: &str, all_skills: &HashMap<String, SkillManifest>) -> anyhow::Result<()>`**
- Walk the parent chain, detect cycles, return clear error: "Circular inheritance detected: {chain}"

**`resolve_conflicts_with_across_chain(skill_name: &str, all_skills: &HashMap<String, SkillManifest>) -> anyhow::Result<Vec<String>>`**
- Collect all conflicts_with declarations from the skill and all its parents
- Per user decision: "Explicit conflicts_with declarations enforced across inheritance chains"
- Return the full list of conflicting skill names

**`inspect_resolved_capabilities(skill_name: &str, all_skills: &HashMap<String, SkillManifest>) -> anyhow::Result<InspectedSkill>`**
Where `InspectedSkill` is:
```rust
pub struct InspectedSkill {
    pub name: String,
    pub own_capabilities: Vec<Capability>,
    pub inherited_capabilities: Vec<Capability>,
    pub combined_capabilities: Vec<Capability>,
    pub parent_chain: Vec<String>,
    pub conflicts_with: Vec<String>,
    pub depth: usize,
}
```
This powers `bnity skill inspect <name>` per user decision.

Add `pub mod inheritance;` to skill/mod.rs.

Unit tests:
- Single parent inheritance adds parent capabilities
- Multi-parent: last parent wins on conflict
- 3-level deep inheritance works
- 4-level deep inheritance returns error
- Circular inheritance detected
- conflicts_with collected across chain
- inspect shows combined capabilities
  </action>
  <verify>Run `cargo test -p boternity-core -- skill::inheritance` -- all tests pass.</verify>
  <done>Inheritance resolves up to 3 levels deep. Multi-parent mixin composition uses last-wins ordering. Circular inheritance and cross-chain conflicts are detected.</done>
</task>

</tasks>

<verification>
- `cargo test -p boternity-core -- skill::resolver` passes
- `cargo test -p boternity-core -- skill::inheritance` passes
- `cargo check --workspace` passes
</verification>

<success_criteria>
Dependency resolution produces correct topological install order. Cycles are caught. Version conflicts are reported. Inheritance resolves multi-parent capabilities with depth cap. conflicts_with enforced across chains.
</success_criteria>

<output>
After completion, create `.planning/phases/06-skill-system-wasm-sandbox/06-04-SUMMARY.md`
</output>
