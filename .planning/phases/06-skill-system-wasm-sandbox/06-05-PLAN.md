---
phase: 06-skill-system-wasm-sandbox
plan: 05
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - wit/boternity-skill.wit
  - crates/boternity-infra/src/skill/wasm_runtime.rs
  - crates/boternity-infra/src/skill/mod.rs
autonomous: true

must_haves:
  truths:
    - "WIT interface defines the contract between host (boternity) and guest (skill WASM component)"
    - "Wasmtime Engine is configured with fuel consumption, epoch interruption, and Component Model"
    - "Separate Engine configurations exist for verified vs untrusted trust tiers"
    - "WASM component can be loaded from bytes and validated"
  artifacts:
    - path: "wit/boternity-skill.wit"
      provides: "WIT interface definition for skill plugins"
      contains: "skill-plugin"
    - path: "crates/boternity-infra/src/skill/wasm_runtime.rs"
      provides: "Wasmtime Engine and component loading"
      contains: "WasmRuntime"
  key_links:
    - from: "crates/boternity-infra/src/skill/wasm_runtime.rs"
      to: "wit/boternity-skill.wit"
      via: "wasmtime::component::bindgen! macro"
      pattern: "bindgen!"
---

<objective>
Set up the Wasmtime WASM runtime and define the WIT skill interface.

Purpose: Tool-based skills run as WASM components. This plan creates the WIT contract that defines what host capabilities skills can access and what exports they must provide, plus the Wasmtime runtime configuration that enforces resource limits per trust tier. This is the WASM infrastructure that the executor (Plan 07) builds on.

Output: `wit/boternity-skill.wit` with the skill-plugin world, `WasmRuntime` in boternity-infra with Engine management and component loading.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-skill-system-wasm-sandbox/06-CONTEXT.md
@.planning/phases/06-skill-system-wasm-sandbox/06-RESEARCH.md
@crates/boternity-types/src/skill.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: WIT interface definition</name>
  <files>wit/boternity-skill.wit</files>
  <action>
Create the `wit/` directory at workspace root and write `wit/boternity-skill.wit`:

```wit
package boternity:skill;

interface host {
    /// Context about the current skill invocation
    record skill-context {
        bot-name: string,
        bot-slug: string,
        skill-name: string,
        invocation-id: string,
    }

    /// Get the current invocation context
    get-context: func() -> skill-context;

    /// Read-only bot memory access (gated by recall-memory capability)
    recall-memory: func(query: string, limit: u32) -> list<string>;

    /// HTTP GET request (gated by http-get capability)
    http-get: func(url: string) -> result<string, string>;

    /// HTTP POST request (gated by http-post capability)
    http-post: func(url: string, body: string) -> result<string, string>;

    /// Read a file (gated by read-file capability)
    read-file: func(path: string) -> result<string, string>;

    /// Write a file (gated by write-file capability)
    write-file: func(path: string, content: string) -> result<_, string>;

    /// Get a secret value (gated by get-secret capability, only declared secrets)
    get-secret: func(name: string) -> result<string, string>;

    /// Read an environment variable (gated by read-env capability)
    read-env: func(name: string) -> result<string, string>;

    /// Log a message from the skill (always available)
    log: func(level: string, message: string);
}

world skill-plugin {
    import host;

    /// Every skill must export its name
    export get-name: func() -> string;

    /// Every skill must export its description
    export get-description: func() -> string;

    /// Tool-based skill execution: takes JSON input, returns JSON output
    export execute: func(input: string) -> result<string, string>;
}
```

This follows the research Pattern 1 exactly. Each host function is gated by a capability check at the host side (implemented in Plan 07).
  </action>
  <verify>File exists at `wit/boternity-skill.wit` and contains `world skill-plugin`.</verify>
  <done>WIT interface is defined with all host capabilities and skill exports.</done>
</task>

<task type="auto">
  <name>Task 2: Wasmtime runtime configuration and component loading</name>
  <files>crates/boternity-infra/src/skill/wasm_runtime.rs, crates/boternity-infra/src/skill/mod.rs</files>
  <action>
Create `crates/boternity-infra/src/skill/wasm_runtime.rs`:

**WasmRuntime struct:**
```rust
pub struct WasmRuntime {
    /// Engine for verified registry skills (relaxed limits)
    verified_engine: Engine,
    /// Engine for untrusted registry skills (strict limits)
    untrusted_engine: Engine,
}
```

Per research anti-pattern: "Sharing Wasmtime Engine across trust tiers" -- use SEPARATE engines.

**Methods:**

1. `new() -> anyhow::Result<Self>` -- creates both engines with appropriate configs

2. `fn create_engine_config(trust_tier: TrustTier) -> Config`:
   - All engines: `async_support(true)`, `wasm_component_model(true)`, `consume_fuel(true)`, `epoch_interruption(true)`
   - Untrusted: `wasm_threads(false)`, `wasm_simd(false)` -- strict, disable optional features
   - Verified: `wasm_simd(true)`, `wasm_threads(false)` -- relaxed, allow SIMD for performance
   - Local: unreachable!() -- local skills don't use WASM

3. `engine_for_tier(&self, tier: &TrustTier) -> &Engine` -- returns the appropriate engine (panics for Local since local skills don't use WASM)

4. `load_component(&self, tier: &TrustTier, wasm_bytes: &[u8]) -> anyhow::Result<Component>` -- loads a WASM component from bytes using `Component::from_binary(engine, wasm_bytes)`. Validates it's a Component (not a core module).

5. `default_resource_limits(tier: &TrustTier) -> ResourceLimits` -- returns default ResourceLimits per tier:
   - Untrusted: 64MB memory, 1M fuel, 30s timeout
   - Verified: 256MB memory, 10M fuel, 60s timeout

**Use the `wasmtime::component::bindgen!` macro** to generate Rust bindings from the WIT file:
```rust
wasmtime::component::bindgen!({
    world: "skill-plugin",
    path: "../../wit/boternity-skill.wit",
    async: true,
});
```
Note: the path is relative from the crate root (crates/boternity-infra/) to the workspace wit/ directory. Adjust if needed.

This generates the `SkillPlugin` type and `Host` trait that Plan 07 implements.

Add `pub mod wasm_runtime;` to `crates/boternity-infra/src/skill/mod.rs`.

Unit tests:
- WasmRuntime::new() succeeds
- engine_for_tier returns different engines for Verified vs Untrusted
- default_resource_limits returns stricter limits for Untrusted
- Attempting engine_for_tier with Local panics (should_panic test)
  </action>
  <verify>Run `cargo test -p boternity-infra -- skill::wasm_runtime` -- all tests pass. Run `cargo check -p boternity-infra` to confirm bindgen! compiles.</verify>
  <done>Wasmtime runtime is configured with separate engines per trust tier. WIT bindings are generated. Components can be loaded and validated.</done>
</task>

</tasks>

<verification>
- `wit/boternity-skill.wit` exists and defines the skill-plugin world
- `cargo check -p boternity-infra` passes (bindgen! compiles against WIT)
- `cargo test -p boternity-infra -- skill::wasm_runtime` passes
- Separate engine configs for verified vs untrusted tiers
</verification>

<success_criteria>
WIT interface defines the host-guest contract. Wasmtime runtime loads WASM components with trust-tier-specific configurations. Fuel consumption and epoch interruption are enabled.
</success_criteria>

<output>
After completion, create `.planning/phases/06-skill-system-wasm-sandbox/06-05-SUMMARY.md`
</output>
