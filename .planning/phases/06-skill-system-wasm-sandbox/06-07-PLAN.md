---
phase: 06-skill-system-wasm-sandbox
plan: 07
type: execute
wave: 3
depends_on: ["06-03", "06-05"]
files_modified:
  - crates/boternity-infra/src/skill/wasm_executor.rs
  - crates/boternity-infra/src/skill/mod.rs
autonomous: true

must_haves:
  truths:
    - "WASM skill components execute in a sandboxed Wasmtime store with fuel and memory limits"
    - "Host functions check capability grants before executing (no bypass through WIT imports)"
    - "Fresh Store per invocation prevents state leaks between calls"
    - "Fuel consumption tracks CPU usage and prevents infinite loops"
    - "Memory growth is capped by ResourceLimiter"
  artifacts:
    - path: "crates/boternity-infra/src/skill/wasm_executor.rs"
      provides: "Sandboxed WASM skill execution"
      contains: "WasmSkillExecutor"
  key_links:
    - from: "crates/boternity-infra/src/skill/wasm_executor.rs"
      to: "crates/boternity-infra/src/skill/wasm_runtime.rs"
      via: "uses WasmRuntime.engine_for_tier() and load_component()"
      pattern: "engine_for_tier"
    - from: "crates/boternity-infra/src/skill/wasm_executor.rs"
      to: "crates/boternity-core/src/skill/permission.rs"
      via: "CapabilityEnforcer checks in host import implementations"
      pattern: "enforcer.check"
---

<objective>
Implement the WASM sandboxed skill executor using Wasmtime.

Purpose: Untrusted and verified registry skills run inside a WASM sandbox. This is the core security boundary -- the executor creates a fresh Store per invocation, sets fuel limits, implements ResourceLimiter for memory caps, and every host import function validates capabilities before executing. This is where defense-in-depth starts (WASM layer).

Output: `WasmSkillExecutor` that loads WASM components, implements host imports with capability gates, and enforces resource limits.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-skill-system-wasm-sandbox/06-CONTEXT.md
@.planning/phases/06-skill-system-wasm-sandbox/06-RESEARCH.md
@crates/boternity-types/src/skill.rs
@crates/boternity-infra/src/skill/wasm_runtime.rs
@crates/boternity-core/src/skill/permission.rs
@crates/boternity-core/src/skill/executor.rs
@wit/boternity-skill.wit
</context>

<tasks>

<task type="auto">
  <name>Task 1: WASM skill executor with capability-gated host imports</name>
  <files>crates/boternity-infra/src/skill/wasm_executor.rs, crates/boternity-infra/src/skill/mod.rs</files>
  <action>
Create `crates/boternity-infra/src/skill/wasm_executor.rs`:

This is the most critical security component. Follow research Pattern 2 precisely.

**SkillState struct** (the WASM Store data):
```rust
struct SkillState {
    ctx: WasiCtx,
    table: ResourceTable,
    capabilities: HashSet<Capability>,
    invocation_id: Uuid,
    skill_name: String,
    bot_slug: String,
    bot_name: String,
    fuel_initial: u64,
}
```

Implement `WasiView` for SkillState (required by wasmtime-wasi):
- `table(&mut self) -> &mut ResourceTable`
- `ctx(&mut self) -> &mut WasiCtx`

Implement `ResourceLimiter` for SkillState (per research Pattern 2):
- `memory_growing(current, desired, maximum) -> Result<bool>`: enforce max memory from ResourceLimits
- `table_growing(current, desired, maximum) -> Result<bool>`: cap at 1000 table entries

**Implement the generated Host trait** from bindgen! for SkillState.

Each host function MUST check capabilities before executing. This is Pitfall 4 prevention.

```rust
impl Host for SkillState {
    async fn get_context(&mut self) -> SkillContext {
        SkillContext {
            bot_name: self.bot_name.clone(),
            bot_slug: self.bot_slug.clone(),
            skill_name: self.skill_name.clone(),
            invocation_id: self.invocation_id.to_string(),
        }
    }

    async fn recall_memory(&mut self, query: String, limit: u32) -> Vec<String> {
        if !self.capabilities.contains(&Capability::RecallMemory) {
            return vec![]; // Silent deny for read-only ops
        }
        // TODO: Wire to actual memory store in Plan 10
        vec![]
    }

    async fn http_get(&mut self, url: String) -> Result<String, String> {
        if !self.capabilities.contains(&Capability::HttpGet) {
            return Err("Permission denied: http-get capability not granted".to_string());
        }
        // Execute HTTP GET via reqwest (blocking in async context)
        // For now, stub with error -- will be wired in Plan 10
        Err("HTTP not yet wired".to_string())
    }

    async fn http_post(&mut self, url: String, body: String) -> Result<String, String> {
        if !self.capabilities.contains(&Capability::HttpPost) {
            return Err("Permission denied: http-post capability not granted".to_string());
        }
        Err("HTTP not yet wired".to_string())
    }

    async fn read_file(&mut self, path: String) -> Result<String, String> {
        if !self.capabilities.contains(&Capability::ReadFile) {
            return Err("Permission denied: read-file capability not granted".to_string());
        }
        // Read file within sandbox constraints
        tokio::fs::read_to_string(&path).await
            .map_err(|e| format!("File read error: {e}"))
    }

    async fn write_file(&mut self, path: String, content: String) -> Result<(), String> {
        if !self.capabilities.contains(&Capability::WriteFile) {
            return Err("Permission denied: write-file capability not granted".to_string());
        }
        tokio::fs::write(&path, &content).await
            .map_err(|e| format!("File write error: {e}"))
    }

    async fn get_secret(&mut self, name: String) -> Result<String, String> {
        if !self.capabilities.contains(&Capability::GetSecret) {
            return Err("Permission denied: get-secret capability not granted".to_string());
        }
        // TODO: Wire to secret provider in Plan 10
        Err("Secret access not yet wired".to_string())
    }

    async fn read_env(&mut self, name: String) -> Result<String, String> {
        if !self.capabilities.contains(&Capability::ReadEnv) {
            return Err("Permission denied: read-env capability not granted".to_string());
        }
        std::env::var(&name).map_err(|e| format!("Env error: {e}"))
    }

    async fn log(&mut self, level: String, message: String) {
        // Always available -- no capability check needed
        match level.as_str() {
            "error" => tracing::error!(skill = %self.skill_name, "{message}"),
            "warn" => tracing::warn!(skill = %self.skill_name, "{message}"),
            "info" => tracing::info!(skill = %self.skill_name, "{message}"),
            _ => tracing::debug!(skill = %self.skill_name, "{message}"),
        }
    }
}
```

**WasmSkillExecutor struct:**
```rust
pub struct WasmSkillExecutor {
    runtime: Arc<WasmRuntime>,
}
```

Implement SkillExecutor trait:
1. Get engine for the skill's trust tier from runtime
2. Load component from wasm_path bytes
3. Create Linker, add WASI P2 functions via `wasmtime_wasi::add_to_linker_async`
4. Add custom host imports via generated `SkillPlugin::add_to_linker`
5. Build WasiCtx via WasiCtxBuilder::new().build() (minimal capabilities -- WASI level has no filesystem or network by default)
6. Create fresh Store with SkillState
7. Set fuel: `store.set_fuel(resource_limits.max_fuel)`
8. Apply memory limits: `store.limiter(|state| state)`
9. Instantiate component: `SkillPlugin::instantiate_async(&mut store, &component, &linker)`
10. Call `plugin.call_execute(&mut store, input)`
11. Calculate fuel consumed: initial_fuel - remaining_fuel
12. Return SkillExecutionResult with output, fuel consumed, timing

Per anti-pattern: "Mutable WASM state between invocations" -- fresh Store every time (step 6).

Add `pub mod wasm_executor;` to `crates/boternity-infra/src/skill/mod.rs`.

Unit tests (these won't have real WASM binaries to test with, so test what's testable):
- SkillState ResourceLimiter denies memory growth beyond limit
- SkillState host functions deny when capability is missing
- WasmSkillExecutor::new() succeeds with valid runtime
  </action>
  <verify>Run `cargo check -p boternity-infra` -- must compile (the bindgen! types align with Host impl). Run `cargo test -p boternity-infra -- skill::wasm_executor` for unit tests.</verify>
  <done>WASM skills execute in sandboxed Wasmtime stores with fuel limits, memory caps, and capability-gated host imports. Fresh Store per invocation. No state leaks.</done>
</task>

</tasks>

<verification>
- `cargo check -p boternity-infra` passes (bindgen! + Host impl compile)
- `cargo test -p boternity-infra -- skill::wasm_executor` passes
- Host functions deny when capability is not in grants
- ResourceLimiter enforces memory cap
</verification>

<success_criteria>
WASM components execute in isolated Wasmtime stores. Every host import checks capabilities before executing. Fuel and memory limits are enforced. No state persists between invocations.
</success_criteria>

<output>
After completion, create `.planning/phases/06-skill-system-wasm-sandbox/06-07-SUMMARY.md`
</output>
