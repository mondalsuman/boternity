---
phase: 06-skill-system-wasm-sandbox
plan: 08
type: execute
wave: 4
depends_on: ["06-07"]
files_modified:
  - crates/boternity-infra/src/skill/sandbox.rs
  - crates/boternity-infra/src/skill/sandbox_macos.rs
  - crates/boternity-infra/src/skill/sandbox_linux.rs
  - crates/boternity-infra/src/skill/mod.rs
  - crates/boternity-infra/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "OS-level sandbox wraps WASM execution in a subprocess for defense-in-depth"
    - "macOS uses sandbox-exec with dynamically generated Seatbelt profiles"
    - "Linux uses Landlock for filesystem restrictions in the child process"
    - "The host process is never restricted -- sandbox applies to the child process only"
    - "Sandbox is additive to WASM -- skills run in WASM sandbox INSIDE OS sandbox"
  artifacts:
    - path: "crates/boternity-infra/src/skill/sandbox.rs"
      provides: "OS-level sandbox dispatch"
      contains: "run_sandboxed"
    - path: "crates/boternity-infra/src/skill/sandbox_macos.rs"
      provides: "macOS Seatbelt sandbox"
      contains: "sandbox-exec"
    - path: "crates/boternity-infra/src/skill/sandbox_linux.rs"
      provides: "Linux Landlock sandbox"
      contains: "landlock"
  key_links:
    - from: "crates/boternity-infra/src/skill/sandbox.rs"
      to: "crates/boternity-infra/src/skill/wasm_executor.rs"
      via: "wraps WASM execution in sandboxed subprocess"
      pattern: "run_sandboxed"
---

<objective>
Implement OS-level sandboxing for defense-in-depth.

Purpose: Per roadmap success criteria #5 and user decisions: "Defense-in-depth: WASM sandbox inside OS-level sandbox (seccomp/seatbelt) -- double barrier." The WASM sandbox provides the first layer. This plan adds a second layer by running the WASM executor in a restricted subprocess that has limited filesystem and network access at the OS level. macOS uses Seatbelt (sandbox-exec), Linux uses Landlock.

Output: Platform-specific sandbox implementations and a dispatch layer that wraps WASM execution.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-skill-system-wasm-sandbox/06-CONTEXT.md
@.planning/phases/06-skill-system-wasm-sandbox/06-RESEARCH.md
@crates/boternity-types/src/skill.rs
@crates/boternity-infra/src/skill/wasm_executor.rs
@crates/boternity-infra/src/skill/wasm_runtime.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sandbox configuration and dispatch layer</name>
  <files>crates/boternity-infra/src/skill/sandbox.rs, crates/boternity-infra/src/skill/mod.rs</files>
  <action>
Create `crates/boternity-infra/src/skill/sandbox.rs`:

**SandboxConfig struct:**
```rust
pub struct SandboxConfig {
    pub wasm_path: PathBuf,
    pub input: String,
    pub readable_paths: Vec<PathBuf>,
    pub writable_paths: Vec<PathBuf>,
    pub allow_network: bool,
    pub temp_dir: PathBuf,
    pub trust_tier: TrustTier,
    pub resource_limits: ResourceLimits,
}
```

**Dispatch function:**
```rust
pub async fn run_sandboxed(config: &SandboxConfig) -> anyhow::Result<String> {
    #[cfg(target_os = "macos")]
    return sandbox_macos::run_sandboxed_macos(config).await;

    #[cfg(target_os = "linux")]
    return sandbox_linux::run_sandboxed_linux(config).await;

    #[cfg(not(any(target_os = "macos", target_os = "linux")))]
    {
        tracing::warn!("OS-level sandboxing not available on this platform, running WASM-only sandbox");
        // Fall back to WASM-only execution (no OS sandbox)
        anyhow::bail!("OS-level sandbox not supported on this platform")
    }
}
```

**`should_use_os_sandbox(tier: &TrustTier) -> bool`:**
- Untrusted: always true (mandatory double barrier)
- Verified: configurable (default false -- relaxed sandbox per user decision)
- Local: always false (local skills run natively)

**Note on subprocess model (CRITICAL per Pitfall 3):**
The OS sandbox runs in a SEPARATE subprocess, not the host process. The parent (boternity main process) spawns a child, the child applies OS restrictions to itself, then the child loads + executes the WASM component. Communication is via stdin/stdout JSON.

For v1, we use a simplified approach: the same `boternity` binary is invoked with a special `--wasm-sandbox-exec` hidden subcommand that:
1. Reads WASM path and input from stdin (JSON)
2. Applies OS sandbox to itself
3. Loads and executes WASM component
4. Writes result to stdout (JSON)

This will be wired as a hidden CLI subcommand in Plan 11.

Add `pub mod sandbox;` to `crates/boternity-infra/src/skill/mod.rs`.
  </action>
  <verify>`cargo check -p boternity-infra` passes.</verify>
  <done>Sandbox dispatch layer routes to platform-specific implementation. Configuration captures all sandbox parameters.</done>
</task>

<task type="auto">
  <name>Task 2: Platform-specific sandbox implementations</name>
  <files>crates/boternity-infra/src/skill/sandbox_macos.rs, crates/boternity-infra/src/skill/sandbox_linux.rs, crates/boternity-infra/Cargo.toml, crates/boternity-infra/src/skill/mod.rs</files>
  <action>
**sandbox_macos.rs** (behind `#[cfg(target_os = "macos")]`):

1. `generate_seatbelt_profile(config: &SandboxConfig) -> String`:
   - Start with `(version 1)\n(deny default)\n`
   - Allow process execution: `(allow process-exec)`, `(allow process-fork)`, `(allow sysctl-read)`, `(allow mach-lookup)`
   - Allow reading system libraries: `(allow file-read* (subpath "/usr/lib"))`, `(allow file-read* (subpath "/System/Library"))`, `(allow file-read* (subpath "/Library/Frameworks"))`
   - Allow reading the WASM binary: `(allow file-read* (literal "{wasm_path}"))`
   - Allow each readable_path: `(allow file-read* (subpath "{path}"))`
   - Allow each writable_path: `(allow file-write* (subpath "{path}"))`
   - Allow writing to temp dir: `(allow file-write* (subpath "{temp_dir}"))`
   - If allow_network: `(allow network*)`
   - No env vars, no other access

2. `run_sandboxed_macos(config: &SandboxConfig) -> anyhow::Result<String>`:
   - Generate Seatbelt profile
   - Get path to current executable via `std::env::current_exe()`
   - Spawn: `Command::new("/usr/bin/sandbox-exec").arg("-p").arg(&profile).arg(exe_path).arg("--wasm-sandbox-exec")`
   - Write input JSON to child stdin
   - Read output JSON from child stdout
   - Timeout based on resource_limits.max_duration_ms
   - On failure, return stderr content as error

**sandbox_linux.rs** (behind `#[cfg(target_os = "linux")]`):

Add `landlock = { workspace = true }` to `crates/boternity-infra/Cargo.toml` under a `[target.'cfg(target_os = "linux")'.dependencies]` section.

1. `run_sandboxed_linux(config: &SandboxConfig) -> anyhow::Result<String>`:
   - Similar subprocess model as macOS but without sandbox-exec wrapper
   - Spawn self with `--wasm-sandbox-exec` flag
   - The child process will apply Landlock restrictions to itself

2. `apply_landlock(config: &SandboxConfig) -> anyhow::Result<()>`:
   - Per research Pattern 6: use `landlock::Ruleset` with `ABI::V3`
   - Handle all filesystem access via AccessFs
   - Allow read to /usr, /lib, /lib64, /etc (system libs)
   - Allow read to WASM binary path
   - Allow read to each readable_path
   - Allow read+write to each writable_path and temp_dir
   - Call `restrict_self()` (PERMANENT -- this is the child process)
   - Use best-effort mode for older kernels: if Landlock isn't available, log warning and continue with WASM-only sandbox

Add `#[cfg(target_os = "macos")] pub mod sandbox_macos;` and `#[cfg(target_os = "linux")] pub mod sandbox_linux;` to skill/mod.rs.

Unit tests:
- Seatbelt profile generation includes deny default
- Seatbelt profile includes readable/writable paths
- SandboxConfig builds correctly
- should_use_os_sandbox returns true for Untrusted, false for Local
  </action>
  <verify>Run `cargo check -p boternity-infra` on current platform. Run `cargo test -p boternity-infra -- skill::sandbox` for config tests.</verify>
  <done>macOS Seatbelt and Linux Landlock sandbox implementations are ready. Subprocess model keeps host unrestricted. Defense-in-depth: WASM + OS sandbox.</done>
</task>

</tasks>

<verification>
- `cargo check -p boternity-infra` passes on current platform
- `cargo test -p boternity-infra -- skill::sandbox` passes
- Seatbelt profile generation produces valid deny-default policy
- Host process is never restricted (subprocess model)
</verification>

<success_criteria>
Defense-in-depth is implemented: untrusted WASM skills run inside an OS-level sandbox (Seatbelt on macOS, Landlock on Linux) in addition to the Wasmtime sandbox. The host process remains unrestricted. Sandbox is configurable per trust tier.
</success_criteria>

<output>
After completion, create `.planning/phases/06-skill-system-wasm-sandbox/06-08-SUMMARY.md`
</output>
