---
phase: 06-skill-system-wasm-sandbox
plan: 12
type: execute
wave: 5
depends_on: ["06-10", "06-09"]
files_modified:
  - crates/boternity-api/src/http/handlers/skill.rs
  - crates/boternity-api/src/http/handlers/mod.rs
  - crates/boternity-api/src/http/router.rs
  - apps/web/src/lib/api.ts
  - apps/web/src/routes/bots/$botId/skills.tsx
  - apps/web/src/routes/bots/$botId/route.tsx
  - apps/web/src/types/skill.ts
autonomous: false

must_haves:
  truths:
    - "REST API exposes skill CRUD endpoints for web UI consumption"
    - "Web UI shows installed skills for a bot with trust tier badges"
    - "Web UI allows attaching/detaching skills from a bot"
    - "Web UI shows skill details (capabilities, dependencies, inheritance)"
    - "Skill management works in both CLI and web UI"
  artifacts:
    - path: "crates/boternity-api/src/http/handlers/skill.rs"
      provides: "REST API handlers for skill management"
      contains: "list_skills"
    - path: "apps/web/src/routes/bots/$botId/skills.tsx"
      provides: "Skill management page in web UI"
      contains: "SkillsPage"
    - path: "apps/web/src/types/skill.ts"
      provides: "TypeScript types matching Rust skill types"
      contains: "SkillManifest"
  key_links:
    - from: "apps/web/src/routes/bots/$botId/skills.tsx"
      to: "crates/boternity-api/src/http/handlers/skill.rs"
      via: "fetch /api/bots/{id}/skills"
      pattern: "/api/bots.*skills"
    - from: "crates/boternity-api/src/http/handlers/skill.rs"
      to: "crates/boternity-api/src/state.rs"
      via: "AppState.skill_store for data access"
      pattern: "state.skill_store"
---

<objective>
Implement HTTP API handlers for skill management and the web UI skill browser page.

Purpose: Per user decision: "Both CLI and web UI for skill management." This plan adds REST endpoints for skills and a web UI page within the bot detail view for browsing, attaching, detaching, and inspecting skills. The web UI is the visual counterpart to the CLI commands.

Output: REST API handlers for skills, TypeScript types, and a Skills tab in the bot detail page.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-skill-system-wasm-sandbox/06-CONTEXT.md
@.planning/phases/06-skill-system-wasm-sandbox/06-RESEARCH.md
@crates/boternity-types/src/skill.rs
@crates/boternity-api/src/http/router.rs
@crates/boternity-api/src/http/handlers/mod.rs
@crates/boternity-api/src/state.rs
@apps/web/src/routes/bots/$botId/route.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: REST API handlers for skill management</name>
  <files>crates/boternity-api/src/http/handlers/skill.rs, crates/boternity-api/src/http/handlers/mod.rs, crates/boternity-api/src/http/router.rs</files>
  <action>
Create `crates/boternity-api/src/http/handlers/skill.rs`:

**Endpoints:**

1. `GET /api/skills` -- List all installed skills (global library)
   - Response: `[{ name, description, skill_type, trust_tier, version, source, installed }]`

2. `GET /api/skills/:name` -- Get skill details (full manifest + resolved capabilities)
   - Use inspect_resolved_capabilities for inheritance resolution
   - Response: `{ manifest, body, resolved_capabilities, parent_chain, conflicts_with }`

3. `GET /api/bots/:bot_id/skills` -- List skills attached to a bot
   - Read bot's skills.toml, join with global skill data
   - Response: `[{ name, description, skill_type, trust_tier, enabled, overrides }]`

4. `POST /api/bots/:bot_id/skills` -- Attach a skill to a bot
   - Body: `{ skill_name, capabilities?: [...], overrides?: {...} }`
   - Validates skill exists in global store
   - Adds to bot's skills.toml
   - Response: 201 with skill config

5. `DELETE /api/bots/:bot_id/skills/:name` -- Detach a skill from a bot
   - Removes from bot's skills.toml
   - Does NOT remove from global store
   - Response: 204

6. `PATCH /api/bots/:bot_id/skills/:name` -- Update skill config (enable/disable, overrides)
   - Body: `{ enabled?: bool, overrides?: {...} }`
   - Updates bot's skills.toml
   - Response: 200 with updated config

7. `GET /api/registry/search?q=query` -- Search registries for skills
   - Query cached indices from all enabled registries
   - Response: `[{ name, description, source, categories, install_count, trust_tier }]`

8. `POST /api/skills/install` -- Install a skill from registry
   - Body: `{ source, skill_name?, capabilities_approved: [...] }`
   - Fetches, validates, installs to global store
   - Response: 201 with installed skill info

Add routes to router under `/api/skills` and `/api/bots/:bot_id/skills`.
Add `pub mod skill;` to handlers/mod.rs.

Use the standard response envelope pattern established in Phase 1.
  </action>
  <verify>`cargo check -p boternity-api` passes. Endpoints register in router.</verify>
  <done>REST API provides full skill CRUD for web UI consumption.</done>
</task>

<task type="auto">
  <name>Task 2: Web UI skill management page</name>
  <files>apps/web/src/types/skill.ts, apps/web/src/lib/api.ts, apps/web/src/routes/bots/$botId/skills.tsx, apps/web/src/routes/bots/$botId/route.tsx</files>
  <action>
**types/skill.ts:**
TypeScript interfaces matching Rust types:
```typescript
interface SkillManifest { name: string; description: string; ... }
interface BotSkillConfig { skill_name: string; enabled: boolean; trust_tier: TrustTier; ... }
interface DiscoveredSkill { name: string; description: string; source: string; categories: string[]; ... }
type TrustTier = 'local' | 'verified' | 'untrusted';
type SkillType = 'prompt' | 'tool';
```

**api.ts additions:**
Add API functions:
- `getBotSkills(botId: string): Promise<BotSkillConfig[]>`
- `attachSkill(botId: string, skillName: string): Promise<void>`
- `detachSkill(botId: string, skillName: string): Promise<void>`
- `toggleSkill(botId: string, skillName: string, enabled: boolean): Promise<void>`
- `getAllSkills(): Promise<InstalledSkill[]>`
- `searchRegistry(query: string): Promise<DiscoveredSkill[]>`
- `installSkill(source: string, capabilities: string[]): Promise<void>`

**routes/bots/$botId/skills.tsx:**
Skills tab page with three sections:

1. **Attached Skills** (top section):
   - List of skills attached to this bot
   - Each skill card shows: name, description (truncated), skill type badge (prompt/tool), trust tier badge (color-coded: green/yellow/red), enabled/disabled toggle
   - Detach button (with AlertDialog confirmation)
   - Click card to expand full details (capabilities, dependencies, parent chain)

2. **Available Skills** (middle section):
   - Skills in global library not yet attached to this bot
   - "Attach" button on each
   - Same card format as above

3. **Discover Skills** (bottom section, collapsed by default):
   - Search input for registry search
   - Results list with install button
   - Show source badge, install count, categories
   - Install flow: click install -> show capabilities -> approve -> install + attach

**UI Components:**
- Trust tier badges: `<Badge variant="outline" className={tierColor}>Local</Badge>` (green for local, yellow for verified, red for untrusted)
- Skill type badges: different icons for prompt (MessageSquare) and tool (Wrench)
- Enable/disable: Switch component from shadcn
- Use TanStack Query for data fetching with useBotSkills, useAllSkills hooks
- Responsive layout: single column on mobile, 2-column grid on desktop

**routes/bots/$botId/route.tsx:**
Add "Skills" tab to the bot detail tab navigation (alongside existing tabs like Soul, Identity, etc.). Use the same useMatchRoute pattern from 04-06 decision.
  </action>
  <verify>`pnpm --filter web build` passes. Skills tab appears in bot detail view.</verify>
  <done>Web UI shows bot skills with management controls. Users can attach, detach, enable/disable skills. Registry search and install works from web UI.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete skill system: CLI commands (create, install, list, inspect, browse), TUI browser, web UI skills page, REST API endpoints, WASM sandbox, OS-level sandbox, permission model, inheritance, dependency resolution, audit logging, and registry discovery.</what-built>
  <how-to-verify>
    1. Run `bnity skill create test-prompt-skill` -- verify directory created at ~/.boternity/skills/test-prompt-skill/ with SKILL.md template
    2. Run `bnity skill create test-tool-skill --type tool` -- verify tool skill template with scripts/
    3. Run `bnity skill list` -- verify both skills appear with correct types
    4. Run `bnity skill inspect test-prompt-skill` -- verify manifest details shown
    5. Start the server and open web UI
    6. Navigate to any bot's detail page
    7. Verify "Skills" tab appears in the tab bar
    8. Click Skills tab -- verify attached skills section (empty), available skills section (shows test skills)
    9. Attach test-prompt-skill to the bot from web UI -- verify it appears in attached list
    10. Toggle enable/disable -- verify toggle updates
    11. Detach the skill -- verify it moves back to available
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
- `cargo check --workspace` passes
- `pnpm --filter web build` passes
- REST API endpoints respond correctly
- Web UI Skills tab renders with skill cards
- CLI skill commands work end-to-end
</verification>

<success_criteria>
Skill management works in both CLI and web UI. REST API serves skill data. Web UI shows skills with trust tier badges, enable/disable toggles, and attach/detach controls. Registry search returns results. The complete skill system is functional end-to-end.
</success_criteria>

<output>
After completion, create `.planning/phases/06-skill-system-wasm-sandbox/06-12-SUMMARY.md`
</output>
