---
phase: 06-skill-system-wasm-sandbox
plan: 13
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/boternity-infra/src/skill/wasm_executor.rs
  - crates/boternity-infra/src/skill/sandbox.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Untrusted WASM skills execute inside the OS sandbox subprocess (Seatbelt on macOS, Landlock on Linux)"
    - "Verified WASM skills bypass the OS sandbox and execute directly via Wasmtime"
    - "SandboxResponse output is returned as SkillExecutionResult to callers"
  artifacts:
    - path: "crates/boternity-infra/src/skill/wasm_executor.rs"
      provides: "OS sandbox integration in WasmSkillExecutor::execute()"
      contains: "sandbox::should_use_os_sandbox"
    - path: "crates/boternity-infra/src/skill/sandbox.rs"
      provides: "SandboxConfig construction helper"
      contains: "build_config_for_skill"
  key_links:
    - from: "crates/boternity-infra/src/skill/wasm_executor.rs"
      to: "crates/boternity-infra/src/skill/sandbox.rs"
      via: "sandbox::should_use_os_sandbox() and sandbox::run_sandboxed()"
      pattern: "sandbox::(should_use_os_sandbox|run_sandboxed)"
---

<objective>
Wire OS-level sandbox into the WASM skill execution path for defense-in-depth.

Purpose: Close Gap 1 from VERIFICATION.md -- sandbox::run_sandboxed() exists but has zero callers. WasmSkillExecutor::execute() must delegate to the OS sandbox subprocess for Untrusted skills, completing the defense-in-depth claim (SECU-07, SKIL-10).

Output: WasmSkillExecutor::execute() conditionally routes Untrusted skills through sandbox::run_sandboxed() while Verified skills continue direct WASM execution.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-skill-system-wasm-sandbox/06-07-SUMMARY.md
@.planning/phases/06-skill-system-wasm-sandbox/06-08-SUMMARY.md
@crates/boternity-infra/src/skill/wasm_executor.rs
@crates/boternity-infra/src/skill/sandbox.rs
@crates/boternity-types/src/skill.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SandboxConfig builder helper to sandbox.rs</name>
  <files>crates/boternity-infra/src/skill/sandbox.rs</files>
  <action>
Add a public helper function `build_config_for_skill` to sandbox.rs that constructs a SandboxConfig from skill execution parameters. This separates config construction from the executor, keeping sandbox.rs as the single authority on sandbox configuration.

Function signature:
```rust
pub fn build_config_for_skill(
    wasm_path: &Path,
    input: &str,
    trust_tier: &TrustTier,
    resource_limits: &ResourceLimits,
) -> SandboxConfig
```

Implementation:
- Set `wasm_path` from the skill's compiled .wasm path
- Set `input` as the JSON-encoded input string
- Set `readable_paths` to contain only the skill's install directory (parent of wasm_path) -- the WASM binary needs to be readable by the subprocess
- Set `writable_paths` to empty Vec (untrusted skills get no write access by default)
- Set `allow_network` to false (untrusted skills get no network by default)
- Set `temp_dir` to `std::env::temp_dir().join("boternity-sandbox")` -- a dedicated temp space
- Set `trust_tier` and `resource_limits` from parameters

Also update `SandboxResponse` to include a `from_response` or equivalent parsing helper: add a method `into_execution_result` on SandboxResponse that converts to `SkillExecutionResult`:
```rust
impl SandboxResponse {
    pub fn into_execution_result(self, elapsed: std::time::Duration) -> anyhow::Result<SkillExecutionResult> {
        if self.success {
            Ok(SkillExecutionResult {
                output: self.output.unwrap_or_default(),
                fuel_consumed: self.fuel_consumed,
                memory_peak_bytes: None,
                duration: elapsed,
            })
        } else {
            anyhow::bail!("sandboxed execution failed: {}", self.error.unwrap_or_else(|| "unknown error".to_string()))
        }
    }
}
```

This requires adding `use boternity_core::skill::executor::SkillExecutionResult;` and `use std::path::Path;` to the imports.

Add tests:
- `build_config_for_skill_untrusted` -- verifies config fields are set correctly
- `sandbox_response_into_result_success` -- verifies success conversion
- `sandbox_response_into_result_failure` -- verifies error conversion
  </action>
  <verify>
Run `cargo check -p boternity-infra` -- compiles without errors.
Run `cargo test -p boternity-infra -- sandbox::tests` -- all existing + new tests pass.
  </verify>
  <done>
build_config_for_skill() constructs a valid SandboxConfig from skill parameters. SandboxResponse.into_execution_result() converts sandbox output to SkillExecutionResult. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire OS sandbox into WasmSkillExecutor::execute()</name>
  <files>crates/boternity-infra/src/skill/wasm_executor.rs</files>
  <action>
Modify `WasmSkillExecutor::execute()` to conditionally route through the OS sandbox for Untrusted skills. The existing direct WASM execution path remains for Verified skills.

At the top of execute(), after determining `trust_tier` (line ~260) and getting `wasm_path` (line ~276), add a branch:

```rust
// Defense-in-depth: Untrusted skills run inside OS sandbox subprocess
if super::sandbox::should_use_os_sandbox(&trust_tier) {
    let config = super::sandbox::build_config_for_skill(
        wasm_path,
        input,
        &trust_tier,
        &resource_limits,
    );

    tracing::info!(
        skill = %skill.manifest.name,
        trust_tier = %trust_tier,
        "Executing skill in OS sandbox subprocess"
    );

    let sandbox_output = super::sandbox::run_sandboxed(&config).await
        .with_context(|| format!(
            "OS sandbox execution failed for skill '{}'",
            skill.manifest.name
        ))?;

    // Parse the subprocess JSON response
    let response: super::sandbox::SandboxResponse = serde_json::from_str(&sandbox_output)
        .with_context(|| "Failed to parse sandbox subprocess response")?;

    return response.into_execution_result(start.elapsed());
}
```

This block goes AFTER the Local tier rejection check and wasm_path/resource_limits extraction, but BEFORE the engine selection (step 1: "Get engine for trust tier"). The existing code from engine selection through component instantiation becomes the Verified-tier path (it still runs for Verified since should_use_os_sandbox returns false for Verified).

Add `use serde_json;` if not already imported (it likely is transitively, but add explicitly for clarity).

Key design decisions:
- run_sandboxed() returns the raw stdout from the subprocess, which is JSON-encoded SandboxResponse
- The parent process parses the JSON and converts to SkillExecutionResult
- If the sandbox subprocess fails to spawn or crashes, the error propagates up as an anyhow error
- The duration is measured from the parent's perspective (includes subprocess overhead)

Add a test:
- `wasm_executor_should_use_sandbox_for_untrusted` -- unit test that verifies `should_use_os_sandbox` returns true for Untrusted tier (confirms the branch logic). Full integration test requires a real WASM binary which is beyond unit test scope.
  </action>
  <verify>
Run `cargo check -p boternity-infra` -- compiles without errors.
Run `cargo test -p boternity-infra -- wasm_executor::tests` -- all 14 existing tests + new test pass.
Grep confirmation: `grep -n "should_use_os_sandbox" crates/boternity-infra/src/skill/wasm_executor.rs` returns at least one match.
Grep confirmation: `grep -n "run_sandboxed" crates/boternity-infra/src/skill/wasm_executor.rs` returns at least one match.
  </verify>
  <done>
WasmSkillExecutor::execute() checks should_use_os_sandbox(trust_tier) and delegates Untrusted skills to sandbox::run_sandboxed(). Verified skills continue direct WASM execution. Defense-in-depth chain is complete: WasmSkillExecutor -> sandbox::run_sandboxed -> platform-specific subprocess -> WASM execution inside OS restrictions.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p boternity-infra` compiles cleanly
2. `cargo test -p boternity-infra` -- all tests pass (existing + new)
3. `grep -rn "should_use_os_sandbox" crates/boternity-infra/src/skill/wasm_executor.rs` -- confirms wiring exists
4. `grep -rn "run_sandboxed" crates/boternity-infra/src/skill/wasm_executor.rs` -- confirms sandbox invocation exists
5. `grep -rn "build_config_for_skill" crates/boternity-infra/src/skill/sandbox.rs` -- confirms helper exists
</verification>

<success_criteria>
- sandbox::run_sandboxed() is no longer orphaned -- it has a caller in wasm_executor.rs
- Untrusted skills route through OS sandbox subprocess (defense-in-depth chain complete)
- Verified skills continue direct WASM execution (no regression)
- All existing tests continue to pass
- VERIFICATION.md Gap 1 is closed: "OS-level sandboxing provides a second barrier" is now true
</success_criteria>

<output>
After completion, create `.planning/phases/06-skill-system-wasm-sandbox/06-13-SUMMARY.md`
</output>
