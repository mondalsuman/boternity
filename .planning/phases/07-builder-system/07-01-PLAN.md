---
phase: 07-builder-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/boternity-types/src/builder.rs
  - crates/boternity-types/src/llm.rs
  - crates/boternity-types/src/lib.rs
  - Cargo.toml
  - crates/boternity-types/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Builder domain types exist and compile with serde + schemars derives"
    - "CompletionRequest has output_config field for structured output"
    - "OutputConfig/OutputFormat types model Claude's output_config.format API"
    - "BuilderTurn enum produces valid JSON schema via schemars"
  artifacts:
    - path: "crates/boternity-types/src/builder.rs"
      provides: "Builder domain types"
      contains: "BuilderTurn"
    - path: "crates/boternity-types/src/llm.rs"
      provides: "OutputConfig on CompletionRequest"
      contains: "output_config"
  key_links:
    - from: "crates/boternity-types/src/builder.rs"
      to: "crates/boternity-types/src/llm.rs"
      via: "shared serde/schemars derives"
      pattern: "schemars::JsonSchema"
---

<objective>
Add builder domain types and structured output support to boternity-types.

Purpose: Establish the type foundation that all builder plans depend on -- BuilderState, BuilderTurn, BuilderPhase, PurposeCategory, and the OutputConfig extension to CompletionRequest that enables Claude structured output.
Output: `crates/boternity-types/src/builder.rs` with all builder types, `output_config` field on CompletionRequest.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-builder-system/07-RESEARCH.md
@.planning/phases/07-builder-system/07-CONTEXT.md
@crates/boternity-types/src/llm.rs
@crates/boternity-types/src/lib.rs
@crates/boternity-types/Cargo.toml
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add schemars dependency and builder domain types</name>
  <files>
    Cargo.toml
    crates/boternity-types/Cargo.toml
    crates/boternity-types/src/builder.rs
    crates/boternity-types/src/lib.rs
  </files>
  <action>
    1. Add `schemars = "1"` to workspace dependencies in root Cargo.toml. Add `schemars = { workspace = true }` to boternity-types Cargo.toml.

    2. Create `crates/boternity-types/src/builder.rs` with these types (all derive Debug, Clone, Serialize, Deserialize):

    **BuilderPhase** enum: Basics, Personality, Model, Skills, Review. Derive schemars::JsonSchema. Use `#[serde(rename_all = "snake_case")]`.

    **PurposeCategory** enum: SimpleUtility, ComplexAnalyst, Creative, Coding, Research, CustomerService, Custom(String). Derive JsonSchema. Use `#[serde(rename_all = "snake_case")]`.

    **BuilderTurn** tagged enum `#[serde(tag = "action", rename_all = "snake_case")]` with JsonSchema:
    - `AskQuestion { phase: BuilderPhase, question: String, options: Vec<QuestionOption>, allow_free_text: bool, phase_label: Option<String> }` -- LLM asks the next question
    - `ShowPreview { phase: BuilderPhase, preview: BuilderPreview }` -- show current config preview
    - `ReadyToAssemble { config: BuilderConfig }` -- LLM signals all info gathered, ready to build
    - `Clarify { message: String }` -- LLM needs clarification on vague input

    **QuestionOption** struct with JsonSchema: `id: String, label: String, description: Option<String>`. The description is the brief context per user decision ("Formal tone -- best for professional/enterprise use cases").

    **BuilderPreview** struct with JsonSchema: `name: Option<String>, description: Option<String>, personality_summary: Option<String>, model: Option<String>, skills: Vec<String>, phase: BuilderPhase`.

    **BuilderConfig** struct with JsonSchema: `name: String, description: String, category: String, tags: Vec<String>, personality: PersonalityConfig, model_config: ModelConfig, skills: Vec<SkillRequest>`.

    **PersonalityConfig** struct with JsonSchema: `tone: String, traits: Vec<String>, purpose: String, boundaries: Option<String>`.

    **ModelConfig** struct with JsonSchema: `model: String, temperature: f64, max_tokens: u32`.

    **SkillRequest** struct with JsonSchema: `name: String, description: String, skill_type: String` (skill_type is "local" or "wasm").

    **BuilderAnswer** enum (NO JsonSchema needed, this is user input not LLM output): `OptionIndex(usize)`, `FreeText(String)`, `Confirm(bool)`, `Back`.

    **BuilderState** struct: `session_id: Uuid, phase: BuilderPhase, initial_description: String, purpose_category: Option<PurposeCategory>, conversation: Vec<BuilderExchange>, config: PartialBuilderConfig, phase_history: Vec<BuilderPhase>`. The conversation is the accumulated Q&A.

    **BuilderExchange** struct: `question: String, answer: String, phase: BuilderPhase`.

    **PartialBuilderConfig** struct with all-Option fields: `name: Option<String>, description: Option<String>, category: Option<String>, tags: Option<Vec<String>>, tone: Option<String>, traits: Option<Vec<String>>, purpose: Option<String>, boundaries: Option<String>, model: Option<String>, temperature: Option<f64>, max_tokens: Option<u32>, skills: Vec<SkillRequest>` (skills defaults to empty vec).

    3. Add `pub mod builder;` to `crates/boternity-types/src/lib.rs`.
  </action>
  <verify>
    `cargo check -p boternity-types` compiles without errors.
    Verify schemars schema generation: add a test in builder.rs:
    ```rust
    #[test]
    fn test_builder_turn_schema() {
        let schema = schemars::schema_for!(BuilderTurn);
        let json = serde_json::to_string_pretty(&schema).unwrap();
        assert!(json.contains("action"));
        assert!(json.contains("ask_question"));
        assert!(json.contains("ready_to_assemble"));
    }
    ```
    Run `cargo test -p boternity-types builder` -- test passes.
  </verify>
  <done>All builder domain types compile with Serialize/Deserialize/JsonSchema derives. BuilderTurn schema generation works.</done>
</task>

<task type="auto">
  <name>Task 2: Add OutputConfig to CompletionRequest</name>
  <files>
    crates/boternity-types/src/llm.rs
  </files>
  <action>
    Add `output_config` support to CompletionRequest for Claude structured output:

    1. Add to `crates/boternity-types/src/llm.rs`:

    **OutputFormat** struct: `type_field: String` (serde rename to "type"), `json_schema: OutputJsonSchema`.
    Use `#[serde(rename = "type")]` on type_field. The type_field value should always be "json_schema".

    **OutputJsonSchema** struct: `name: String, schema: serde_json::Value, strict: Option<bool>`.

    **OutputConfig** struct: `format: OutputFormat`.

    2. Add to CompletionRequest:
    ```rust
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output_config: Option<OutputConfig>,
    ```

    3. This is backward compatible -- existing code creates CompletionRequest without output_config (it will be None). However, if existing code uses struct literal construction without `..Default::default()`, add `output_config: None` to all existing construction sites. Search for `CompletionRequest {` across the workspace and update each one.

    IMPORTANT: The schemars crate (v1) generates schemas with `additionalProperties` not set. Research FINDING 1 says Claude structured output needs `additionalProperties: false` on all object schemas. Add a helper function `pub fn add_additional_properties_false(schema: &mut serde_json::Value)` in builder.rs that recursively walks a JSON schema and adds `"additionalProperties": false` to every object that has `"properties"`. This is critical for Claude API compatibility.
  </action>
  <verify>
    `cargo check --workspace` compiles without errors (all construction sites updated).
    Add test:
    ```rust
    #[test]
    fn test_output_config_serialization() {
        let config = OutputConfig {
            format: OutputFormat {
                type_field: "json_schema".to_string(),
                json_schema: OutputJsonSchema {
                    name: "test".to_string(),
                    schema: serde_json::json!({"type": "object"}),
                    strict: Some(true),
                },
            },
        };
        let json = serde_json::to_value(&config).unwrap();
        assert_eq!(json["format"]["type"], "json_schema");
    }
    ```
    Run `cargo test --workspace` -- all tests pass.
  </verify>
  <done>CompletionRequest has output_config field. All existing construction sites updated. OutputConfig serializes correctly with "type" field rename. add_additional_properties_false helper exists in builder.rs.</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles cleanly
- `cargo test -p boternity-types` passes all tests including new builder and output_config tests
- BuilderTurn JSON schema includes tagged "action" discriminator
- CompletionRequest backward-compatible (existing code still works)
</verification>

<success_criteria>
- builder.rs exists with all builder domain types (BuilderTurn, BuilderState, BuilderPhase, PurposeCategory, BuilderConfig, etc.)
- All types derive serde Serialize/Deserialize; LLM output types additionally derive schemars::JsonSchema
- OutputConfig/OutputFormat/OutputJsonSchema exist in llm.rs
- CompletionRequest has `output_config: Option<OutputConfig>` field
- add_additional_properties_false helper function exists
- All workspace tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-builder-system/07-01-SUMMARY.md`
</output>
