---
phase: 07-builder-system
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - crates/boternity-core/src/builder/mod.rs
  - crates/boternity-core/src/builder/agent.rs
  - crates/boternity-core/src/builder/state.rs
  - crates/boternity-core/src/builder/prompt.rs
  - crates/boternity-core/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "BuilderAgent trait defines the surface-agnostic builder conversation interface"
    - "BuilderState correctly accumulates answers across turns"
    - "Forge system prompt instructs the LLM to produce BuilderTurn JSON"
    - "Back navigation truncates conversation and re-evaluates"
  artifacts:
    - path: "crates/boternity-core/src/builder/agent.rs"
      provides: "BuilderAgent trait"
      contains: "trait BuilderAgent"
    - path: "crates/boternity-core/src/builder/state.rs"
      provides: "BuilderState management"
      contains: "impl BuilderState"
    - path: "crates/boternity-core/src/builder/prompt.rs"
      provides: "Forge system prompt builder"
      contains: "build_forge_system_prompt"
  key_links:
    - from: "crates/boternity-core/src/builder/agent.rs"
      to: "crates/boternity-types/src/builder.rs"
      via: "uses BuilderTurn, BuilderAnswer, BuilderState"
      pattern: "BuilderTurn"
    - from: "crates/boternity-core/src/builder/prompt.rs"
      to: "crates/boternity-core/src/builder/state.rs"
      via: "prompt includes accumulated state context"
      pattern: "BuilderState"
---

<objective>
Create the core builder agent trait, state accumulator, and Forge system prompt.

Purpose: Define the surface-agnostic BuilderAgent interface that both CLI and web adapters will use, plus the state management and prompt construction that drive the LLM conversation.
Output: `crates/boternity-core/src/builder/` module with agent trait, state management, and prompt builder.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-builder-system/07-RESEARCH.md
@.planning/phases/07-builder-system/07-CONTEXT.md
@.planning/phases/07-builder-system/07-01-SUMMARY.md
@crates/boternity-types/src/builder.rs
@crates/boternity-core/src/agent/prompt.rs
@crates/boternity-core/src/agent/engine.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: BuilderAgent trait and BuilderState accumulator</name>
  <files>
    crates/boternity-core/src/builder/mod.rs
    crates/boternity-core/src/builder/agent.rs
    crates/boternity-core/src/builder/state.rs
    crates/boternity-core/src/lib.rs
  </files>
  <action>
    1. Create `crates/boternity-core/src/builder/mod.rs` with `pub mod agent; pub mod state; pub mod prompt;`.

    2. Create `crates/boternity-core/src/builder/agent.rs` with:

    **BuilderAgent trait** using RPITIT (consistent with all project traits, no async_trait):
    ```rust
    pub trait BuilderAgent {
        /// Start a new builder session from an initial description.
        /// Returns the first BuilderTurn (typically an AskQuestion).
        fn start(&self, session_id: Uuid, initial_description: &str) -> impl Future<Output = Result<BuilderTurn, BuilderError>> + Send;

        /// Process a user answer and return the next BuilderTurn.
        fn next_turn(&self, state: &mut BuilderState, answer: BuilderAnswer) -> impl Future<Output = Result<BuilderTurn, BuilderError>> + Send;

        /// Resume a builder session from saved state (draft restoration).
        fn resume(&self, state: &BuilderState) -> impl Future<Output = Result<BuilderTurn, BuilderError>> + Send;

        /// Reconfigure an existing bot -- load current config, show it, ask what to adjust.
        fn reconfigure(&self, state: &mut BuilderState, current_config: BuilderConfig) -> impl Future<Output = Result<BuilderTurn, BuilderError>> + Send;
    }
    ```

    **BuilderError** enum (in same file or in boternity-types if preferred, but keep in core for now):
    - `LlmError(String)` -- LLM call failed
    - `ParseError(String)` -- could not parse LLM structured output
    - `StateError(String)` -- invalid state transition
    - `AssemblyError(String)` -- bot/skill creation failed
    Derive Debug, thiserror::Error with Display.

    3. Create `crates/boternity-core/src/builder/state.rs` with:

    **impl BuilderState** (the struct is in boternity-types):
    - `pub fn new(session_id: Uuid, initial_description: String) -> Self` -- creates with Basics phase, empty conversation/config
    - `pub fn record_exchange(&mut self, question: String, answer: String)` -- pushes to conversation vec with current phase
    - `pub fn advance_phase(&mut self, new_phase: BuilderPhase)` -- push current to phase_history, set new phase
    - `pub fn go_back(&mut self) -> Option<BuilderPhase>` -- pop last phase from history, truncate conversation entries from that phase, return the phase we went back to. This implements the user decision for full back navigation with re-evaluation.
    - `pub fn update_config_field(&mut self, field: &str, value: serde_json::Value)` -- update PartialBuilderConfig field by name using serde_json::from_value on individual fields. Use a match on field name to set the right Option field.
    - `pub fn conversation_summary(&self) -> String` -- format last 5 exchanges as context for LLM (prevents context bloat per research pitfall 2)
    - `pub fn question_count(&self) -> usize` -- total exchanges so far
    - `pub fn is_complete(&self) -> bool` -- phase is Review and config has all required fields (name, purpose, model)

    4. Add `pub mod builder;` to `crates/boternity-core/src/lib.rs`.
  </action>
  <verify>
    `cargo check -p boternity-core` compiles.
    Add unit tests in state.rs:
    - test new() creates Basics phase
    - test record_exchange adds to conversation
    - test advance_phase moves phase and records history
    - test go_back truncates correctly
    - test conversation_summary limits to last 5
    Run `cargo test -p boternity-core builder` -- tests pass.
  </verify>
  <done>BuilderAgent trait exists with RPITIT methods. BuilderState has full lifecycle management including back navigation. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Forge system prompt builder</name>
  <files>
    crates/boternity-core/src/builder/prompt.rs
  </files>
  <action>
    Create `crates/boternity-core/src/builder/prompt.rs` with:

    **`pub fn build_forge_system_prompt(state: &BuilderState, mode: BuilderMode) -> String`**

    BuilderMode enum: `NewBot`, `ReconfigureBot`, `NewSkill`, `BatchCreate { variant_count: usize }`.

    The system prompt uses XML tag boundaries consistent with the project pattern (02-05 decision). Structure:

    ```xml
    <forge_identity>
    You are Forge, the bot builder. You are a friendly guide -- warm, encouraging, slightly casual, like a helpful teammate walking through setup. You help users create bots and skills through an interactive conversation.
    </forge_identity>

    <builder_instructions>
    You are conducting a {mode} session. Generate your response as structured JSON matching the BuilderTurn schema.

    RULES:
    1. Ask ONE question at a time with multi-choice options
    2. Every option MUST have a brief description explaining when it's best suited
    3. Always include an "Other" option for free-text input
    4. Adapt question depth to the purpose complexity:
       - Simple utility bots: 3-5 questions, smart defaults
       - Complex analyst/research bots: 6-10 questions, probe for details
       - Creative bots: 4-7 questions, focus on personality
    5. Show phase labels ("Setting up basics...", "Defining personality...", etc.)
    6. Always explain your reasoning for suggestions
    7. When you have enough context, signal ready_to_assemble with the full config

    {if ReconfigureBot: "Show current config first and ask 'What would you like to adjust?'"}
    {if BatchCreate: "Ask 'What makes this variant different?' for each variant"}
    </builder_instructions>

    <accumulated_context>
    Initial description: {state.initial_description}
    Current phase: {state.phase}
    Purpose category: {state.purpose_category or "not yet determined"}
    Questions asked: {state.question_count()}

    Previous exchanges:
    {state.conversation_summary()}
    </accumulated_context>

    <current_config>
    {serialize state.config as readable summary, only non-None fields}
    </current_config>
    ```

    Also add:
    **`pub fn build_forge_soul_content() -> &'static str`** -- returns the SOUL.md content for Forge as a const string. Forge is NOT a real bot in the database; it's embedded as a const. Per research pitfall 6. Include Personality (helpful craftsman, warm, encouraging), Purpose (guide users through bot/skill creation), Boundaries (never creates without confirmation, always explains suggestions).

    **`pub fn format_phase_label(phase: &BuilderPhase) -> &'static str`** -- returns human-readable phase labels per user decision: Basics -> "Setting up basics...", Personality -> "Defining personality...", Model -> "Choosing model...", Skills -> "Selecting skills...", Review -> "Final review...". These are discretion items per CONTEXT.md.
  </action>
  <verify>
    `cargo check -p boternity-core` compiles.
    Add tests:
    - test build_forge_system_prompt contains XML tags
    - test build_forge_system_prompt includes accumulated context
    - test format_phase_label returns correct labels
    - test build_forge_soul_content is non-empty and contains Personality section
    Run `cargo test -p boternity-core builder` -- tests pass.
  </verify>
  <done>Forge system prompt builder produces XML-tagged prompt with accumulated state context. Forge identity embedded as const. Phase labels defined.</done>
</task>

</tasks>

<verification>
- `cargo check -p boternity-core` compiles
- `cargo test -p boternity-core builder` passes all tests
- BuilderAgent trait uses RPITIT (no async_trait)
- BuilderState manages conversation accumulation and back navigation
- Forge prompt uses XML tags consistent with project pattern
</verification>

<success_criteria>
- BuilderAgent trait with start/next_turn/resume/reconfigure methods
- BuilderState with record_exchange, advance_phase, go_back, conversation_summary
- Forge system prompt with XML tags, accumulated context, mode-specific instructions
- Forge identity as embedded const (not a database bot)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-builder-system/07-02-SUMMARY.md`
</output>
