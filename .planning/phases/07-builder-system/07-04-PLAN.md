---
phase: 07-builder-system
plan: 04
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - crates/boternity-core/src/builder/defaults.rs
  - crates/boternity-core/src/builder/assembler.rs
  - crates/boternity-core/src/builder/mod.rs
autonomous: true

must_haves:
  truths:
    - "Smart defaults adapt model/temperature/max_tokens to purpose category"
    - "BotAssembler creates a complete bot with SOUL.md + IDENTITY.md + USER.md + attached skills"
    - "Assembly calls existing BotService::create_bot and SoulService::write_and_save_soul"
    - "Assembly shows explicit confirmation before building (ReadyToAssemble flow)"
  artifacts:
    - path: "crates/boternity-core/src/builder/defaults.rs"
      provides: "SmartDefaults for purpose categories"
      contains: "smart_defaults_for_category"
    - path: "crates/boternity-core/src/builder/assembler.rs"
      provides: "BotAssembler for creating bots from BuilderConfig"
      contains: "BotAssembler"
  key_links:
    - from: "crates/boternity-core/src/builder/assembler.rs"
      to: "crates/boternity-core/src/service/bot.rs"
      via: "calls BotService::create_bot"
      pattern: "create_bot"
    - from: "crates/boternity-core/src/builder/assembler.rs"
      to: "crates/boternity-core/src/service/soul.rs"
      via: "calls SoulService::write_and_save_soul"
      pattern: "write_and_save_soul"
---

<objective>
Implement smart defaults for purpose categories and the BotAssembler that creates complete bots from BuilderConfig.

Purpose: The smart defaults drive adaptive question flow (coding bots get low temperature, creative bots get high temperature). The assembler is the final step that turns a BuilderConfig into real files on disk using existing services.
Output: Smart defaults module and BotAssembler in boternity-core.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-builder-system/07-RESEARCH.md
@.planning/phases/07-builder-system/07-CONTEXT.md
@.planning/phases/07-builder-system/07-02-SUMMARY.md
@crates/boternity-core/src/service/bot.rs
@crates/boternity-core/src/service/soul.rs
@crates/boternity-types/src/builder.rs
@crates/boternity-types/src/bot.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Smart defaults for purpose categories</name>
  <files>
    crates/boternity-core/src/builder/defaults.rs
    crates/boternity-core/src/builder/mod.rs
  </files>
  <action>
    Create `crates/boternity-core/src/builder/defaults.rs`:

    **`pub fn smart_defaults_for_category(category: &PurposeCategory) -> SmartDefaults`**

    SmartDefaults struct: `model: String, temperature: f64, max_tokens: u32, suggested_tone: String, suggested_traits: Vec<String>, suggested_skills: Vec<String>`.

    Per user decision, these are Claude's discretion items. Use these values:

    | Category | Model | Temp | MaxTokens | Tone | Traits | Skills |
    |----------|-------|------|-----------|------|--------|--------|
    | SimpleUtility | claude-sonnet-4-20250514 | 0.3 | 2048 | "direct" | ["efficient", "concise"] | ["web-search"] |
    | ComplexAnalyst | claude-sonnet-4-20250514 | 0.5 | 4096 | "analytical" | ["thorough", "precise", "structured"] | ["web-search", "data-analysis"] |
    | Creative | claude-sonnet-4-20250514 | 0.9 | 4096 | "expressive" | ["creative", "imaginative", "playful"] | ["text-generation"] |
    | Coding | claude-sonnet-4-20250514 | 0.2 | 4096 | "technical" | ["precise", "methodical", "pragmatic"] | ["code-review", "code-generation"] |
    | Research | claude-sonnet-4-20250514 | 0.5 | 4096 | "scholarly" | ["thorough", "citation-aware", "balanced"] | ["web-search", "summarize"] |
    | CustomerService | claude-sonnet-4-20250514 | 0.4 | 2048 | "empathetic" | ["patient", "helpful", "clear"] | ["knowledge-base"] |
    | Custom(_) | claude-sonnet-4-20250514 | 0.7 | 4096 | "adaptive" | ["versatile"] | [] |

    **`pub fn classify_purpose(description: &str) -> PurposeCategory`**

    Purpose-based heuristic categorization (the "hybrid approach" per user decision -- this is the heuristic half; LLM judgment is in the builder agent). Simple keyword matching:
    - Contains "email", "reminder", "timer", "calculator", "converter" -> SimpleUtility
    - Contains "analyze", "data", "report", "metrics", "dashboard" -> ComplexAnalyst
    - Contains "write", "story", "poem", "creative", "art", "music" -> Creative
    - Contains "code", "debug", "program", "develop", "software" -> Coding
    - Contains "research", "study", "academic", "paper", "literature" -> Research
    - Contains "support", "customer", "help desk", "ticket" -> CustomerService
    - Otherwise -> Custom(description first 50 chars)

    Case-insensitive matching. Check in priority order (first match wins).

    Update `crates/boternity-core/src/builder/mod.rs` to add `pub mod defaults;`.
  </action>
  <verify>
    `cargo check -p boternity-core` compiles.
    Add tests:
    - test classify_purpose for each category keyword
    - test smart_defaults_for_category returns expected temperature for Coding (0.2) and Creative (0.9)
    - test Custom category gets default values
    Run `cargo test -p boternity-core builder::defaults` -- tests pass.
  </verify>
  <done>SmartDefaults mapped for all PurposeCategories. classify_purpose heuristic works for common descriptions.</done>
</task>

<task type="auto">
  <name>Task 2: BotAssembler -- create bots from BuilderConfig</name>
  <files>
    crates/boternity-core/src/builder/assembler.rs
    crates/boternity-core/src/builder/mod.rs
  </files>
  <action>
    Create `crates/boternity-core/src/builder/assembler.rs`:

    **BotAssembler** -- a utility struct (no fields) with generic methods that accept services as params. This follows the stateless utility pattern from 02-06.

    ```rust
    pub struct BotAssembler;

    impl BotAssembler {
        /// Assemble a complete bot from a BuilderConfig.
        pub async fn assemble<B, S, F, H>(
            bot_service: &BotService<B, S, F, H>,
            config: &BuilderConfig,
        ) -> Result<AssemblyResult, BuilderError>
        where
            B: BotRepository,
            S: SoulRepository,
            F: FileSystem,
            H: ContentHasher,
        {
            // ... implementation below
        }
    }
    ```

    **AssemblyResult** struct: `bot: Bot, soul_content: String, identity_content: String, user_content: String, skills_attached: Vec<String>, file_paths: AssemblyPaths`.

    **AssemblyPaths** struct: `bot_dir: PathBuf, soul_path: PathBuf, identity_path: PathBuf, user_path: PathBuf`.

    **Exact service call sequence** (per research FINDING 2):

    ```rust
    // Step 1: Create bot via BotService::create_bot
    // This creates the DB record AND writes default SOUL.md, IDENTITY.md, USER.md to disk.
    // Signature: bot_service.create_bot(CreateBotRequest { name, description, category, tags }) -> Bot
    let create_req = CreateBotRequest {
        name: config.name.clone(),
        description: Some(config.description.clone()),
        category: Some(config.category.parse::<BotCategory>().unwrap_or_default()),
        tags: Some(config.tags.clone()),
    };
    let bot = bot_service.create_bot(create_req).await
        .map_err(|e| BuilderError::AssemblyError(e.to_string()))?;

    // Step 2: Generate builder SOUL.md content from PersonalityConfig
    let soul_content = generate_soul_content(&config.personality, &config.name);

    // Step 3: Overwrite default SOUL.md with builder-generated content
    // Uses bot_service.soul_service().write_and_save_soul(&BotId, &str, &Path) -> Soul
    let bot_dir = bot_service.bot_dir(&bot.slug);
    let soul_path = bot_dir.join("SOUL.md");
    bot_service.soul_service()
        .write_and_save_soul(&bot.id, &soul_content, &soul_path).await
        .map_err(|e| BuilderError::AssemblyError(e.to_string()))?;

    // Step 4: Overwrite default IDENTITY.md with builder model config
    // Uses bot_service.soul_service().write_identity(&str, &Path)
    let identity_content = generate_identity_content(&config.model_config);
    let identity_path = bot_dir.join("IDENTITY.md");
    bot_service.soul_service()
        .write_identity(&identity_content, &identity_path).await
        .map_err(|e| BuilderError::AssemblyError(e.to_string()))?;

    // Step 5: Overwrite default USER.md with seeded user context
    // Uses bot_service.soul_service().write_user(&str, &Path)
    let user_content = generate_user_content(&config.name, &config.description);
    let user_path = bot_dir.join("USER.md");
    bot_service.soul_service()
        .write_user(&user_content, &user_path).await
        .map_err(|e| BuilderError::AssemblyError(e.to_string()))?;

    // Step 6: Skill attachment deferred to Plan 07-06
    ```

    Note: Step 1 (create_bot) creates default files, then Steps 2-5 overwrite them with builder-generated content. Per research pitfall 9, this minor inefficiency (write default then overwrite) is acceptable.

    **`fn generate_soul_content(personality: &PersonalityConfig, name: &str) -> String`**

    Generates SOUL.md content following the three-section template per user decision:
    ```markdown
    ---
    name: {name}
    traits: [{personality.traits joined with ", "}]
    tone: {personality.tone}
    ---

    # Personality
    You embody a {personality.tone} personality with these core traits: {traits list}.
    {Expand into a paragraph describing how these traits manifest in conversation.}

    # Purpose
    {personality.purpose}

    # Boundaries
    {personality.boundaries or "Be helpful within your defined purpose. Decline requests outside your expertise area."}
    ```

    **`fn generate_identity_content(model_config: &ModelConfig) -> String`**

    Generates IDENTITY.md frontmatter:
    ```markdown
    ---
    model: {model_config.model}
    temperature: {model_config.temperature}
    max_tokens: {model_config.max_tokens}
    ---
    ```

    **`fn generate_user_content(name: &str, description: &str) -> String`**

    Generates USER.md seeded from builder context:
    ```markdown
    # User Context for {name}

    This bot was created with the following purpose: {description}

    ## Preferences
    (Add your preferences here to help {name} serve you better)

    ## Important Context
    (Share relevant background information)
    ```

    NOTE: Skill attachment is deferred to Plan 07-06 (Skill Builder). The assembler returns skills_attached as empty for now.

    Update `crates/boternity-core/src/builder/mod.rs` to add `pub mod assembler;`.
  </action>
  <verify>
    `cargo check -p boternity-core` compiles.
    Add tests:
    - test generate_soul_content includes Personality/Purpose/Boundaries sections
    - test generate_soul_content includes frontmatter with name and traits
    - test generate_identity_content includes model config values
    - test generate_user_content includes name and description
    Run `cargo test -p boternity-core builder::assembler` -- tests pass.
  </verify>
  <done>BotAssembler creates complete bots from BuilderConfig using existing services with exact call sequence: create_bot -> write_and_save_soul -> write_identity -> write_user. SOUL.md follows three-section template. IDENTITY.md and USER.md generated from config.</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- `cargo test -p boternity-core builder` passes all tests
- Smart defaults return appropriate values for each category
- SOUL.md generation follows Personality/Purpose/Boundaries structure
- Assembly uses existing BotService and SoulService methods (no duplicated bot creation logic)
- Assembly call sequence clearly documented: create_bot -> write_and_save_soul -> write_identity -> write_user
</verification>

<success_criteria>
- SmartDefaults with temperature/model/skills tuned per PurposeCategory
- classify_purpose heuristic categorizes common bot descriptions
- BotAssembler creates bots via existing BotService::create_bot then overwrites with builder content
- Exact service method calls: create_bot(CreateBotRequest), soul_service().write_and_save_soul(&BotId, &str, &Path), soul_service().write_identity(&str, &Path), soul_service().write_user(&str, &Path)
- SOUL.md, IDENTITY.md, USER.md generated from BuilderConfig
- Assembly result contains all paths and content
</success_criteria>

<output>
After completion, create `.planning/phases/07-builder-system/07-04-SUMMARY.md`
</output>
