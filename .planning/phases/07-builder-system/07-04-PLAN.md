---
phase: 07-builder-system
plan: 04
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - crates/boternity-core/src/builder/defaults.rs
  - crates/boternity-core/src/builder/assembler.rs
  - crates/boternity-core/src/builder/mod.rs
autonomous: true

must_haves:
  truths:
    - "Smart defaults adapt model/temperature/max_tokens to purpose category"
    - "BotAssembler creates a complete bot with SOUL.md + IDENTITY.md + USER.md + attached skills"
    - "Assembly calls existing BotService::create_bot and SoulService::write_and_save_soul"
    - "Assembly shows explicit confirmation before building (ReadyToAssemble flow)"
  artifacts:
    - path: "crates/boternity-core/src/builder/defaults.rs"
      provides: "SmartDefaults for purpose categories"
      contains: "smart_defaults_for_category"
    - path: "crates/boternity-core/src/builder/assembler.rs"
      provides: "BotAssembler for creating bots from BuilderConfig"
      contains: "BotAssembler"
  key_links:
    - from: "crates/boternity-core/src/builder/assembler.rs"
      to: "crates/boternity-core/src/service/bot.rs"
      via: "calls BotService::create_bot"
      pattern: "create_bot"
    - from: "crates/boternity-core/src/builder/assembler.rs"
      to: "crates/boternity-core/src/service/soul.rs"
      via: "calls SoulService::write_and_save_soul"
      pattern: "write_and_save_soul"
---

<objective>
Implement smart defaults for purpose categories and the BotAssembler that creates complete bots from BuilderConfig.

Purpose: The smart defaults drive adaptive question flow (coding bots get low temperature, creative bots get high temperature). The assembler is the final step that turns a BuilderConfig into real files on disk using existing services.
Output: Smart defaults module and BotAssembler in boternity-core.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-builder-system/07-RESEARCH.md
@.planning/phases/07-builder-system/07-CONTEXT.md
@.planning/phases/07-builder-system/07-02-SUMMARY.md
@crates/boternity-core/src/service/bot.rs
@crates/boternity-core/src/service/soul.rs
@crates/boternity-types/src/builder.rs
@crates/boternity-types/src/bot.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Smart defaults for purpose categories</name>
  <files>
    crates/boternity-core/src/builder/defaults.rs
    crates/boternity-core/src/builder/mod.rs
  </files>
  <action>
    Create `crates/boternity-core/src/builder/defaults.rs`:

    **`pub fn smart_defaults_for_category(category: &PurposeCategory) -> SmartDefaults`**

    SmartDefaults struct: `model: String, temperature: f64, max_tokens: u32, suggested_tone: String, suggested_traits: Vec<String>, suggested_skills: Vec<String>`.

    Per user decision, these are Claude's discretion items. Use these values:

    | Category | Model | Temp | MaxTokens | Tone | Traits | Skills |
    |----------|-------|------|-----------|------|--------|--------|
    | SimpleUtility | claude-sonnet-4-20250514 | 0.3 | 2048 | "direct" | ["efficient", "concise"] | ["web-search"] |
    | ComplexAnalyst | claude-sonnet-4-20250514 | 0.5 | 4096 | "analytical" | ["thorough", "precise", "structured"] | ["web-search", "data-analysis"] |
    | Creative | claude-sonnet-4-20250514 | 0.9 | 4096 | "expressive" | ["creative", "imaginative", "playful"] | ["text-generation"] |
    | Coding | claude-sonnet-4-20250514 | 0.2 | 4096 | "technical" | ["precise", "methodical", "pragmatic"] | ["code-review", "code-generation"] |
    | Research | claude-sonnet-4-20250514 | 0.5 | 4096 | "scholarly" | ["thorough", "citation-aware", "balanced"] | ["web-search", "summarize"] |
    | CustomerService | claude-sonnet-4-20250514 | 0.4 | 2048 | "empathetic" | ["patient", "helpful", "clear"] | ["knowledge-base"] |
    | Custom(_) | claude-sonnet-4-20250514 | 0.7 | 4096 | "adaptive" | ["versatile"] | [] |

    **`pub fn classify_purpose(description: &str) -> PurposeCategory`**

    Purpose-based heuristic categorization (the "hybrid approach" per user decision -- this is the heuristic half; LLM judgment is in the builder agent). Simple keyword matching:
    - Contains "email", "reminder", "timer", "calculator", "converter" -> SimpleUtility
    - Contains "analyze", "data", "report", "metrics", "dashboard" -> ComplexAnalyst
    - Contains "write", "story", "poem", "creative", "art", "music" -> Creative
    - Contains "code", "debug", "program", "develop", "software" -> Coding
    - Contains "research", "study", "academic", "paper", "literature" -> Research
    - Contains "support", "customer", "help desk", "ticket" -> CustomerService
    - Otherwise -> Custom(description first 50 chars)

    Case-insensitive matching. Check in priority order (first match wins).

    Update `crates/boternity-core/src/builder/mod.rs` to add `pub mod defaults;`.
  </action>
  <verify>
    `cargo check -p boternity-core` compiles.
    Add tests:
    - test classify_purpose for each category keyword
    - test smart_defaults_for_category returns expected temperature for Coding (0.2) and Creative (0.9)
    - test Custom category gets default values
    Run `cargo test -p boternity-core builder::defaults` -- tests pass.
  </verify>
  <done>SmartDefaults mapped for all PurposeCategories. classify_purpose heuristic works for common descriptions.</done>
</task>

<task type="auto">
  <name>Task 2: BotAssembler -- create bots from BuilderConfig</name>
  <files>
    crates/boternity-core/src/builder/assembler.rs
    crates/boternity-core/src/builder/mod.rs
  </files>
  <action>
    Create `crates/boternity-core/src/builder/assembler.rs`:

    **BotAssembler** -- a utility struct (no fields) with generic methods that accept services as params. This follows the stateless utility pattern from 02-06.

    ```rust
    pub struct BotAssembler;

    impl BotAssembler {
        /// Assemble a complete bot from a BuilderConfig.
        ///
        /// Sequence per research FINDING 2:
        /// 1. create_bot (creates DB record + default files)
        /// 2. write_and_save_soul (overwrite default SOUL.md with builder-generated content)
        /// 3. write_identity (overwrite IDENTITY.md with builder config)
        /// 4. write_user (overwrite USER.md with seeded user context)
        /// 5. attach skills (if any requested)
        pub async fn assemble<B, S, F, H>(
            bot_service: &BotService<B, S, F, H>,
            config: &BuilderConfig,
        ) -> Result<AssemblyResult, BuilderError>
        where
            B: BotRepository,
            S: SoulRepository,
            F: FileSystem,
            H: ContentHasher,
        {
            // ... implementation
        }
    }
    ```

    **AssemblyResult** struct: `bot: Bot, soul_content: String, identity_content: String, user_content: String, skills_attached: Vec<String>, file_paths: AssemblyPaths`.

    **AssemblyPaths** struct: `bot_dir: PathBuf, soul_path: PathBuf, identity_path: PathBuf, user_path: PathBuf`.

    Implementation details:

    1. Create bot via BotService::create_bot with CreateBotRequest { name, description, category (parse from string to BotCategory), tags }.

    2. Generate SOUL.md content from PersonalityConfig using a template:
    ```markdown
    ---
    name: {config.name}
    traits: [{personality.traits joined}]
    tone: {personality.tone}
    ---

    # Personality
    {LLM-quality personality paragraph using tone and traits -- for now, generate a structured template. The LLM will improve this in practice.}

    # Purpose
    {personality.purpose}

    # Boundaries
    {personality.boundaries or "Be helpful within your defined purpose. Decline requests outside your expertise area."}
    ```
    Per user decision: SOUL.md template follows three sections (Personality, Purpose, Boundaries). LLM fills in unique content per bot -- but the assembler creates the structural template that the builder's LLM-generated content will populate.

    Actually, the BuilderConfig's PersonalityConfig already has the content. The assembler should format it into the SOUL.md structure, then call write_and_save_soul to overwrite the default.

    3. Generate IDENTITY.md frontmatter from ModelConfig:
    ```markdown
    ---
    model: {model_config.model}
    temperature: {model_config.temperature}
    max_tokens: {model_config.max_tokens}
    ---
    ```

    4. Generate USER.md seeded from builder conversation context (inferred from initial_description and purpose).

    5. Return AssemblyResult with all paths and content.

    NOTE: Skill attachment is deferred to Plan 07-06 (Skill Builder). The assembler returns skills_attached as empty for now and accepts an optional skill attachment callback or returns the list for the caller to handle.

    Update `crates/boternity-core/src/builder/mod.rs` to add `pub mod assembler;`.
  </action>
  <verify>
    `cargo check -p boternity-core` compiles.
    Add tests:
    - test SOUL.md content generation includes Personality/Purpose/Boundaries sections
    - test IDENTITY.md content includes model config values
    - test USER.md content includes initial description context
    Run `cargo test -p boternity-core builder::assembler` -- tests pass.
  </verify>
  <done>BotAssembler creates complete bots from BuilderConfig using existing services. SOUL.md follows three-section template. IDENTITY.md and USER.md generated from config.</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- `cargo test -p boternity-core builder` passes all tests
- Smart defaults return appropriate values for each category
- SOUL.md generation follows Personality/Purpose/Boundaries structure
- Assembly uses existing BotService (no duplicated bot creation logic)
</verification>

<success_criteria>
- SmartDefaults with temperature/model/skills tuned per PurposeCategory
- classify_purpose heuristic categorizes common bot descriptions
- BotAssembler creates bots via existing BotService::create_bot
- SOUL.md, IDENTITY.md, USER.md generated from BuilderConfig
- Assembly result contains all paths and content
</success_criteria>

<output>
After completion, create `.planning/phases/07-builder-system/07-04-SUMMARY.md`
</output>
