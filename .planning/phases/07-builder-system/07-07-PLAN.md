---
phase: 07-builder-system
plan: 07
type: execute
wave: 5
depends_on: ["07-05", "07-06"]
files_modified:
  - crates/boternity-api/src/cli/builder.rs
  - crates/boternity-api/src/cli/skill_create.rs
  - crates/boternity-api/src/cli/mod.rs
  - crates/boternity-api/src/state.rs
autonomous: true

must_haves:
  truths:
    - "User can run bnity create and go through the interactive builder wizard"
    - "CLI uses dialoguer arrow-key selection for multi-choice questions"
    - "Live preview shown after each phase (basics, personality, skills)"
    - "User can go back to previous phases and change answers"
    - "bnity skill create launches standalone skill builder"
    - "Post-create shows detailed summary and offers to open chat"
  artifacts:
    - path: "crates/boternity-api/src/cli/builder.rs"
      provides: "CLI builder wizard command"
      contains: "BuilderCommand"
    - path: "crates/boternity-api/src/cli/skill_create.rs"
      provides: "CLI skill create command"
      contains: "skill_create"
  key_links:
    - from: "crates/boternity-api/src/cli/builder.rs"
      to: "crates/boternity-infra/src/builder/llm_builder.rs"
      via: "CLI creates LlmBuilderAgent and drives the conversation"
      pattern: "LlmBuilderAgent"
    - from: "crates/boternity-api/src/cli/builder.rs"
      to: "crates/boternity-core/src/builder/assembler.rs"
      via: "calls BotAssembler::assemble on ReadyToAssemble"
      pattern: "BotAssembler"
---

<objective>
Implement the CLI builder wizard using dialoguer for interactive multi-choice bot creation.

Purpose: Users can create fully-configured bots through `bnity create` with an interactive wizard that asks adaptive questions, shows live previews, and supports back navigation -- all powered by the universal builder agent.
Output: CLI builder command and standalone skill create command.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-builder-system/07-RESEARCH.md
@.planning/phases/07-builder-system/07-CONTEXT.md
@.planning/phases/07-builder-system/07-05-SUMMARY.md
@.planning/phases/07-builder-system/07-06-SUMMARY.md
@crates/boternity-api/src/cli/mod.rs
@crates/boternity-api/src/cli/bot.rs
@crates/boternity-api/src/state.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: CLI builder wizard (bnity create) and AppState wiring</name>
  <files>
    crates/boternity-api/src/cli/builder.rs
    crates/boternity-api/src/cli/mod.rs
    crates/boternity-api/src/state.rs
  </files>
  <action>
    NOTE: This task is complex -- it implements the conversation loop, three modes (new/resume/reconfigure), and AppState wiring. The conversation loop is the core UX; the modes are thin wrappers around BuilderAgent methods. Focus on getting the main loop right first, then add resume/reconfigure.

    1. Wire BuilderDraftStore and BuilderMemoryStore into AppState FIRST:
    Add `pub builder_draft_store: Arc<SqliteBuilderDraftStore>` and `pub builder_memory_store: Arc<SqliteBuilderMemoryStore>` to AppState in `crates/boternity-api/src/state.rs`. Initialize in AppState::init() after the Phase 6 services section.

    2. Create `crates/boternity-api/src/cli/builder.rs`:

    **Main entry: `pub async fn run_builder_wizard(state: &AppState) -> anyhow::Result<()>`**

    Flow:
    a. Prompt for initial description: `Input::new().with_prompt("What kind of bot do you want to create?").interact_text()?`
    b. Create LlmBuilderAgent with provider from `state.create_single_provider("claude-sonnet-4-20250514")` and memory_store from `state.builder_memory_store.clone()`
    c. Call `builder.start(session_id, &description)` to get first BuilderTurn
    d. Enter the main loop (see below)

    **Main conversation loop:**
    ```rust
    loop {
        match turn {
            BuilderTurn::AskQuestion { phase, question, options, allow_free_text, phase_label } => {
                // Show phase label if present
                if let Some(label) = phase_label {
                    println!("\n{}", style(label).dim());
                }

                // Show the question
                println!("\n{}", style(&question).bold());

                // Build dialoguer Select with options
                let mut items: Vec<String> = options.iter()
                    .map(|o| {
                        if let Some(desc) = &o.description {
                            format!("{} -- {}", o.label, style(desc).dim())
                        } else {
                            o.label.clone()
                        }
                    })
                    .collect();

                // Add "Other (type your own)" and "< Back" options
                if allow_free_text {
                    items.push("Other (type your own)".to_string());
                }
                items.push("< Back".to_string());

                let selection = Select::new()
                    .items(&items)
                    .default(0)
                    .interact()?;

                let answer = if selection == items.len() - 1 {
                    BuilderAnswer::Back
                } else if allow_free_text && selection == items.len() - 2 {
                    let text: String = Input::new()
                        .with_prompt("Your answer")
                        .interact_text()?;
                    BuilderAnswer::FreeText(text)
                } else {
                    BuilderAnswer::OptionIndex(selection)
                };

                turn = builder.next_turn(&mut builder_state, answer).await?;
            }

            BuilderTurn::ShowPreview { phase, preview } => {
                println!("\n{}", style("--- Current Configuration ---").cyan());
                if let Some(name) = &preview.name { println!("  Name: {}", name); }
                if let Some(desc) = &preview.description { println!("  Description: {}", desc); }
                if let Some(personality) = &preview.personality_summary { println!("  Personality: {}", personality); }
                if let Some(model) = &preview.model { println!("  Model: {}", model); }
                if !preview.skills.is_empty() { println!("  Skills: {}", preview.skills.join(", ")); }
                println!("{}", style("---").cyan());
                turn = builder.next_turn(&mut builder_state, BuilderAnswer::Confirm(true)).await?;
            }

            BuilderTurn::ReadyToAssemble { config } => {
                println!("\n{}", style("=== Ready to Create ===").green().bold());
                println!("Name: {}", config.name);
                println!("Description: {}", config.description);
                println!("Category: {}", config.category);
                println!("Model: {} (temp: {}, max: {})", config.model_config.model, config.model_config.temperature, config.model_config.max_tokens);
                println!("Personality: {} tone, traits: {}", config.personality.tone, config.personality.traits.join(", "));
                if !config.skills.is_empty() {
                    println!("Skills:");
                    for skill in &config.skills { println!("  - {}: {}", skill.name, skill.description); }
                }

                let confirmed = Confirm::new().with_prompt("Ready to create?").default(true).interact()?;
                if confirmed {
                    let result = BotAssembler::assemble(&*state.bot_service, &config).await?;
                    println!("\n{}", format_assembly_summary(&result));

                    // Record builder memory for future suggestions
                    let memory_entry = BuilderMemoryEntry {
                        id: Uuid::now_v7(),
                        purpose_category: builder_state.purpose_category.as_ref().map(|c| c.to_string()).unwrap_or_default(),
                        initial_description: builder_state.initial_description.clone(),
                        chosen_tone: Some(config.personality.tone.clone()),
                        chosen_model: Some(config.model_config.model.clone()),
                        chosen_skills: config.skills.iter().map(|s| s.name.clone()).collect(),
                        bot_slug: Some(result.bot.slug.clone()),
                        created_at: chrono::Utc::now(),
                    };
                    let _ = state.builder_memory_store.record_session(memory_entry).await;

                    // Delete draft
                    let _ = state.builder_draft_store.delete_draft(&builder_state.session_id).await;

                    let start_chat = Confirm::new().with_prompt("Start chatting with your new bot?").default(true).interact()?;
                    if start_chat {
                        println!("Run: bnity chat {}", result.bot.slug);
                    }
                } else {
                    turn = builder.next_turn(&mut builder_state, BuilderAnswer::Back).await?;
                    continue;
                }
                break;
            }

            BuilderTurn::Clarify { message } => {
                println!("\n{}", style(&message).yellow());
                let clarification: String = Input::new().with_prompt("Your response").interact_text()?;
                turn = builder.next_turn(&mut builder_state, BuilderAnswer::FreeText(clarification)).await?;
            }
        }

        // Auto-save draft after each turn
        let draft = BuilderDraft {
            session_id: builder_state.session_id,
            state_json: serde_json::to_string(&builder_state).unwrap_or_default(),
            schema_version: 1,
            created_at: chrono::Utc::now(),
            updated_at: chrono::Utc::now(),
        };
        let _ = state.builder_draft_store.save_draft(draft).await;
    }
    ```

    3. Wire into CLI: Add `bnity create` command to the CLI router in `crates/boternity-api/src/cli/mod.rs`. Add a `Create` variant to the CLI commands enum with clap subcommand.

    Also add `bnity create --resume` to resume from a saved draft (list drafts, select one, call builder.resume()), and `bnity create --reconfigure <slug>` to reconfigure an existing bot.
  </action>
  <verify>
    `cargo check -p boternity-api` compiles.
    `cargo test --workspace` passes.
    Run `cargo run -- create --help` -- shows usage for the create command.
  </verify>
  <done>bnity create launches interactive builder wizard with dialoguer Select for multi-choice. Supports back navigation, live preview, explicit confirmation. Draft auto-save and builder memory recording wired. Resume and reconfigure modes available.</done>
</task>

<task type="auto">
  <name>Task 2: Standalone skill create command</name>
  <files>
    crates/boternity-api/src/cli/skill_create.rs
    crates/boternity-api/src/cli/skill.rs
    crates/boternity-api/src/cli/mod.rs
  </files>
  <action>
    Create `crates/boternity-api/src/cli/skill_create.rs`:

    **`pub async fn run_skill_create(state: &AppState) -> anyhow::Result<()>`**

    Flow:
    1. Prompt: "Describe the skill you want to create:"
    2. Ask skill type: Select from ["Local (prompt-based, runs natively)", "WASM (sandboxed, compiled Rust)"]
    3. Call SkillBuilder::generate_skill with the description and type
    4. Show suggested capabilities with reasons:
       ```
       Suggested Permissions:
         [x] network_access -- Needs to make HTTP requests (fetching data)
         [x] file_read -- Needs to read configuration files
       ```
    5. Confirm capabilities: Confirm dialog for each, or accept all
    6. Show generated SKILL.md content
    7. Validate with SkillBuilder::validate_skill
    8. If valid, confirm and write to `~/.boternity/skills/{name}/`
    9. Print success with skill path

    Wire `bnity skill create` as a subcommand under the existing `bnity skill` command. Check `crates/boternity-api/src/cli/skill.rs` for the existing skill command structure and add a `Create` variant.

    Per user decision: both Forge chat and `bnity skill create` CLI available for standalone skill creation. This task handles the CLI path.
  </action>
  <verify>
    `cargo check -p boternity-api` compiles.
    Run `cargo run -- skill create --help` -- shows usage.
    `cargo test --workspace` passes.
  </verify>
  <done>bnity skill create provides standalone interactive skill creation with capability suggestions and validation.</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- `cargo test --workspace` passes
- `bnity create` launches interactive wizard
- `bnity create --resume` resumes from draft
- `bnity skill create` launches standalone skill builder
- Builder draft and memory stores wired into AppState
- Builder memory recorded after successful bot creation
</verification>

<success_criteria>
- CLI wizard uses dialoguer Select with arrow-key navigation
- Multi-choice options include descriptions per user decision
- Live preview updates after each phase
- Back navigation works (returns to previous phase)
- Explicit confirmation before assembly
- Post-create shows detailed summary
- Builder memory recorded after creation (tone, model, skills, slug)
- Draft auto-saved after each turn, deleted after successful creation
- Standalone skill create with capability suggestions
</success_criteria>

<output>
After completion, create `.planning/phases/07-builder-system/07-07-SUMMARY.md`
</output>
