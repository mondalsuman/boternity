---
phase: 07-builder-system
plan: 07
type: execute
wave: 5
depends_on: ["07-05", "07-06"]
files_modified:
  - crates/boternity-api/src/cli/builder.rs
  - crates/boternity-api/src/cli/skill_create.rs
  - crates/boternity-api/src/cli/mod.rs
  - crates/boternity-api/src/state.rs
autonomous: true

must_haves:
  truths:
    - "User can run bnity create and go through the interactive builder wizard"
    - "CLI uses dialoguer arrow-key selection for multi-choice questions"
    - "Live preview shown after each phase (basics, personality, skills)"
    - "User can go back to previous phases and change answers"
    - "bnity skill create launches standalone skill builder"
    - "Post-create shows detailed summary and offers to open chat"
  artifacts:
    - path: "crates/boternity-api/src/cli/builder.rs"
      provides: "CLI builder wizard command"
      contains: "BuilderCommand"
    - path: "crates/boternity-api/src/cli/skill_create.rs"
      provides: "CLI skill create command"
      contains: "skill_create"
  key_links:
    - from: "crates/boternity-api/src/cli/builder.rs"
      to: "crates/boternity-infra/src/builder/llm_builder.rs"
      via: "CLI creates LlmBuilderAgent and drives the conversation"
      pattern: "LlmBuilderAgent"
    - from: "crates/boternity-api/src/cli/builder.rs"
      to: "crates/boternity-core/src/builder/assembler.rs"
      via: "calls BotAssembler::assemble on ReadyToAssemble"
      pattern: "BotAssembler"
---

<objective>
Implement the CLI builder wizard using dialoguer for interactive multi-choice bot creation.

Purpose: Users can create fully-configured bots through `bnity create` with an interactive wizard that asks adaptive questions, shows live previews, and supports back navigation -- all powered by the universal builder agent.
Output: CLI builder command and standalone skill create command.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-builder-system/07-RESEARCH.md
@.planning/phases/07-builder-system/07-CONTEXT.md
@.planning/phases/07-builder-system/07-05-SUMMARY.md
@.planning/phases/07-builder-system/07-06-SUMMARY.md
@crates/boternity-api/src/cli/mod.rs
@crates/boternity-api/src/cli/bot.rs
@crates/boternity-api/src/state.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: CLI builder wizard (bnity create)</name>
  <files>
    crates/boternity-api/src/cli/builder.rs
    crates/boternity-api/src/cli/mod.rs
    crates/boternity-api/src/state.rs
  </files>
  <action>
    1. Create `crates/boternity-api/src/cli/builder.rs`:

    **Main entry: `pub async fn run_builder_wizard(state: &AppState) -> anyhow::Result<()>`**

    Flow:
    a. Prompt for initial description: `Input::new().with_prompt("What kind of bot do you want to create?").interact_text()?`
    b. Create LlmBuilderAgent with a BoxLlmProvider from `state.create_single_provider("claude-sonnet-4-20250514")`
    c. Call `builder.start(session_id, &description)` to get first BuilderTurn
    d. Enter the main loop:

    **Main conversation loop:**
    ```rust
    loop {
        match turn {
            BuilderTurn::AskQuestion { phase, question, options, allow_free_text, phase_label } => {
                // Show phase label if present
                if let Some(label) = phase_label {
                    println!("\n{}", style(label).dim());
                }

                // Show the question
                println!("\n{}", style(&question).bold());

                // Build dialoguer Select with options
                let mut items: Vec<String> = options.iter()
                    .map(|o| {
                        if let Some(desc) = &o.description {
                            format!("{} -- {}", o.label, style(desc).dim())
                        } else {
                            o.label.clone()
                        }
                    })
                    .collect();

                // Add "Other (type your own)" and "< Back" options
                if allow_free_text {
                    items.push("Other (type your own)".to_string());
                }
                items.push("< Back".to_string());

                let selection = Select::new()
                    .items(&items)
                    .default(0)
                    .interact()?;

                let answer = if selection == items.len() - 1 {
                    // Back
                    BuilderAnswer::Back
                } else if allow_free_text && selection == items.len() - 2 {
                    // Other -- free text
                    let text: String = Input::new()
                        .with_prompt("Your answer")
                        .interact_text()?;
                    BuilderAnswer::FreeText(text)
                } else {
                    BuilderAnswer::OptionIndex(selection)
                };

                turn = builder.next_turn(&mut builder_state, answer).await?;
            }

            BuilderTurn::ShowPreview { phase, preview } => {
                // Display preview per user decision (growing preview after each phase)
                println!("\n{}", style("--- Current Configuration ---").cyan());
                if let Some(name) = &preview.name {
                    println!("  Name: {}", name);
                }
                if let Some(desc) = &preview.description {
                    println!("  Description: {}", desc);
                }
                if let Some(personality) = &preview.personality_summary {
                    println!("  Personality: {}", personality);
                }
                if let Some(model) = &preview.model {
                    println!("  Model: {}", model);
                }
                if !preview.skills.is_empty() {
                    println!("  Skills: {}", preview.skills.join(", "));
                }
                println!("{}", style("---").cyan());

                // Continue to next turn automatically
                turn = builder.next_turn(&mut builder_state, BuilderAnswer::Confirm(true)).await?;
            }

            BuilderTurn::ReadyToAssemble { config } => {
                // Show full summary per user decision (structured summary with raw toggle)
                println!("\n{}", style("=== Ready to Create ===").green().bold());
                println!("Name: {}", config.name);
                println!("Description: {}", config.description);
                println!("Category: {}", config.category);
                println!("Model: {} (temp: {}, max: {})", config.model_config.model, config.model_config.temperature, config.model_config.max_tokens);
                println!("Personality: {} tone, traits: {}", config.personality.tone, config.personality.traits.join(", "));
                if !config.skills.is_empty() {
                    println!("Skills:");
                    for skill in &config.skills {
                        println!("  - {}: {}", skill.name, skill.description);
                    }
                }

                // Confirm per user decision (explicit confirmation before building)
                let confirmed = Confirm::new()
                    .with_prompt("Ready to create?")
                    .default(true)
                    .interact()?;

                if confirmed {
                    // Assemble the bot
                    let result = BotAssembler::assemble(&*state.bot_service, &config).await?;
                    println!("\n{}", format_assembly_summary(&result));

                    // Record builder memory for future suggestions
                    // Save to builder memory store (wire through state)

                    // Offer to start chatting per user decision
                    let start_chat = Confirm::new()
                        .with_prompt("Start chatting with your new bot?")
                        .default(true)
                        .interact()?;

                    if start_chat {
                        // Call into the existing chat command with the new bot's slug
                        println!("Run: bnity chat {}", result.bot.slug);
                    }
                } else {
                    // Go back to adjust
                    turn = builder.next_turn(&mut builder_state, BuilderAnswer::Back).await?;
                    continue;
                }
                break;
            }

            BuilderTurn::Clarify { message } => {
                println!("\n{}", style(&message).yellow());
                let clarification: String = Input::new()
                    .with_prompt("Your response")
                    .interact_text()?;
                turn = builder.next_turn(&mut builder_state, BuilderAnswer::FreeText(clarification)).await?;
            }
        }

        // Auto-save draft per user decision
        // draft_store.save_draft(...)
    }
    ```

    2. Wire into CLI: Add `bnity create` (or `bnity builder`) command to the CLI router in `crates/boternity-api/src/cli/mod.rs`. Check the existing clap structure and add a `Create` variant to the CLI commands enum.

    Also add `bnity create --resume` to resume from a saved draft, and `bnity create --reconfigure <slug>` to reconfigure an existing bot.

    3. Wire BuilderDraftStore and BuilderMemoryStore into AppState:
    Add `pub builder_draft_store: Arc<SqliteBuilderDraftStore>` and `pub builder_memory_store: Arc<SqliteBuilderMemoryStore>` to AppState in `crates/boternity-api/src/state.rs`. Initialize in AppState::init().
  </action>
  <verify>
    `cargo check -p boternity-api` compiles.
    `cargo test --workspace` passes.
    Run `cargo run -- create --help` -- shows usage for the create command.
  </verify>
  <done>bnity create launches interactive builder wizard with dialoguer Select for multi-choice. Supports back navigation, live preview, explicit confirmation. Draft auto-save and builder memory wired.</done>
</task>

<task type="auto">
  <name>Task 2: Standalone skill create command</name>
  <files>
    crates/boternity-api/src/cli/skill_create.rs
    crates/boternity-api/src/cli/skill.rs
    crates/boternity-api/src/cli/mod.rs
  </files>
  <action>
    Create `crates/boternity-api/src/cli/skill_create.rs`:

    **`pub async fn run_skill_create(state: &AppState) -> anyhow::Result<()>`**

    Flow:
    1. Prompt: "Describe the skill you want to create:"
    2. Ask skill type: Select from ["Local (prompt-based, runs natively)", "WASM (sandboxed, compiled Rust)"]
    3. Call SkillBuilder::generate_skill with the description and type
    4. Show suggested capabilities with reasons:
       ```
       Suggested Permissions:
         [x] network_access -- Needs to make HTTP requests (fetching data)
         [x] file_read -- Needs to read configuration files
       ```
    5. Confirm capabilities: Confirm dialog for each, or accept all
    6. Show generated SKILL.md content
    7. Validate with SkillBuilder::validate_skill
    8. If valid, confirm and write to `~/.boternity/skills/{name}/`
    9. Print success with skill path

    Wire `bnity skill create` as a subcommand under the existing `bnity skill` command. Check `crates/boternity-api/src/cli/skill.rs` for the existing skill command structure and add a `Create` variant.

    Per user decision: both Forge chat and `bnity skill create` CLI available for standalone skill creation. This task handles the CLI path.
  </action>
  <verify>
    `cargo check -p boternity-api` compiles.
    Run `cargo run -- skill create --help` -- shows usage.
    `cargo test --workspace` passes.
  </verify>
  <done>bnity skill create provides standalone interactive skill creation with capability suggestions and validation.</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- `cargo test --workspace` passes
- `bnity create` launches interactive wizard
- `bnity create --resume` resumes from draft
- `bnity skill create` launches standalone skill builder
- Builder draft and memory stores wired into AppState
</verification>

<success_criteria>
- CLI wizard uses dialoguer Select with arrow-key navigation
- Multi-choice options include descriptions per user decision
- Live preview updates after each phase
- Back navigation works (returns to previous phase)
- Explicit confirmation before assembly
- Post-create shows detailed summary
- Standalone skill create with capability suggestions
- Draft auto-save and memory recording work
</success_criteria>

<output>
After completion, create `.planning/phases/07-builder-system/07-07-SUMMARY.md`
</output>
