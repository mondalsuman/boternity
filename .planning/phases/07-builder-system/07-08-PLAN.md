---
phase: 07-builder-system
plan: 08
type: execute
wave: 5
depends_on: ["07-05", "07-06"]
files_modified:
  - crates/boternity-api/src/http/handlers/builder.rs
  - crates/boternity-api/src/http/handlers/builder_ws.rs
  - crates/boternity-api/src/http/handlers/mod.rs
  - crates/boternity-api/src/http/router.rs
autonomous: true

must_haves:
  truths:
    - "REST endpoints manage builder sessions (create, get, advance, list drafts)"
    - "WebSocket endpoint enables real-time Forge chat builder for both bots AND skills"
    - "Both REST and WebSocket use the same LlmBuilderAgent"
    - "Draft auto-save works through REST API"
    - "Forge can create skills standalone via WebSocket chat (not just bots)"
  artifacts:
    - path: "crates/boternity-api/src/http/handlers/builder.rs"
      provides: "REST API builder session handlers"
      contains: "create_builder_session"
    - path: "crates/boternity-api/src/http/handlers/builder_ws.rs"
      provides: "WebSocket handler for Forge chat (bot + skill modes)"
      contains: "builder_ws_handler"
  key_links:
    - from: "crates/boternity-api/src/http/handlers/builder.rs"
      to: "crates/boternity-infra/src/builder/llm_builder.rs"
      via: "creates LlmBuilderAgent per session"
      pattern: "LlmBuilderAgent"
    - from: "crates/boternity-api/src/http/handlers/builder_ws.rs"
      to: "crates/boternity-infra/src/builder/llm_builder.rs"
      via: "drives builder conversation over WebSocket"
      pattern: "LlmBuilderAgent"
    - from: "crates/boternity-api/src/http/handlers/builder_ws.rs"
      to: "crates/boternity-core/src/builder/skill_builder.rs"
      via: "handles standalone skill creation via Forge chat"
      pattern: "SkillBuilder"
    - from: "crates/boternity-api/src/http/router.rs"
      to: "crates/boternity-api/src/http/handlers/builder.rs"
      via: "mounts builder routes"
      pattern: "/api/v1/builder"
---

<objective>
Create REST API and WebSocket handlers for the web builder, supporting both bot creation and standalone skill creation.

Purpose: The web UI needs REST endpoints for the step-by-step wizard and a WebSocket endpoint for the Forge chat bot. Both surfaces share the same LlmBuilderAgent backend. Per research FINDING 3: REST for wizard, WebSocket for Forge chat. Per user decision: "both Forge chat and bnity skill create CLI command available for standalone skill creation" -- the WebSocket handler must support skill creation sessions in addition to bot creation.
Output: Builder REST handlers and WebSocket handler (with bot + skill modes) mounted on the HTTP router.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-builder-system/07-RESEARCH.md
@.planning/phases/07-builder-system/07-CONTEXT.md
@.planning/phases/07-builder-system/07-05-SUMMARY.md
@.planning/phases/07-builder-system/07-06-SUMMARY.md
@crates/boternity-api/src/http/router.rs
@crates/boternity-api/src/http/handlers/mod.rs
@crates/boternity-api/src/http/handlers/ws.rs
@crates/boternity-api/src/state.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: REST API builder session handlers</name>
  <files>
    crates/boternity-api/src/http/handlers/builder.rs
    crates/boternity-api/src/http/handlers/mod.rs
    crates/boternity-api/src/http/router.rs
  </files>
  <action>
    Create `crates/boternity-api/src/http/handlers/builder.rs`:

    **POST /api/v1/builder/sessions** -- `create_builder_session`
    - Body: `{ "description": "I want a coding assistant", "mode": "bot" }` (mode is "bot" or "skill", defaults to "bot")
    - Creates a new session_id (UUID v7)
    - Creates LlmBuilderAgent with provider
    - If mode is "bot": calls builder.start(session_id, description) with BuilderMode::NewBot
    - If mode is "skill": calls builder.start(session_id, description) with BuilderMode::NewSkill
    - Saves initial state as draft
    - Returns: `{ "session_id": "...", "mode": "bot"|"skill", "turn": BuilderTurn }`

    **POST /api/v1/builder/sessions/:session_id/answer** -- `submit_answer`
    - Body: `{ "answer": BuilderAnswer }` (OptionIndex, FreeText, Confirm, or Back)
    - Loads draft state from store
    - Calls builder.next_turn(state, answer)
    - If ReadyToAssemble, does NOT auto-assemble -- returns the turn for the UI to show confirmation
    - Saves updated state as draft
    - Returns: `{ "turn": BuilderTurn, "state_summary": { "phase": "...", "question_count": N } }`

    **POST /api/v1/builder/sessions/:session_id/assemble** -- `assemble_bot`
    - Body: `{ "config": BuilderConfig }` (the config from ReadyToAssemble turn)
    - Calls BotAssembler::assemble
    - Records builder memory
    - Deletes draft
    - Returns: `{ "result": AssemblyResult }` with bot details and file paths

    **POST /api/v1/builder/sessions/:session_id/create-skill** -- `create_skill`
    - Body: `{ "skill_request": SkillBuildRequest }` (from skill builder flow)
    - Calls SkillBuilder::generate_skill
    - Validates with SkillBuilder::validate_skill
    - Writes skill files to disk
    - Deletes draft
    - Returns: `{ "result": SkillBuildResult }` with skill details and file paths

    **GET /api/v1/builder/sessions/:session_id** -- `get_session`
    - Returns current state summary and last turn
    - Used for resuming sessions

    **GET /api/v1/builder/drafts** -- `list_drafts`
    - Returns list of saved drafts with summaries
    - Used for "Resume" UI

    **DELETE /api/v1/builder/sessions/:session_id** -- `delete_session`
    - Deletes the draft

    **POST /api/v1/builder/sessions/:session_id/reconfigure** -- `reconfigure_bot`
    - Body: `{ "bot_slug": "my-bot" }`
    - Loads existing bot config, populates BuilderState, calls reconfigure mode
    - Returns initial turn for reconfiguration

    Request/Response types: Use the standard envelope pattern from existing handlers (check `crates/boternity-api/src/http/response.rs`).

    Add `pub mod builder;` to `crates/boternity-api/src/http/handlers/mod.rs`.

    Mount routes in `crates/boternity-api/src/http/router.rs`:
    ```rust
    .route("/api/v1/builder/sessions", post(builder::create_builder_session))
    .route("/api/v1/builder/sessions/:session_id/answer", post(builder::submit_answer))
    .route("/api/v1/builder/sessions/:session_id/assemble", post(builder::assemble_bot))
    .route("/api/v1/builder/sessions/:session_id/create-skill", post(builder::create_skill))
    .route("/api/v1/builder/sessions/:session_id", get(builder::get_session).delete(builder::delete_session))
    .route("/api/v1/builder/sessions/:session_id/reconfigure", post(builder::reconfigure_bot))
    .route("/api/v1/builder/drafts", get(builder::list_drafts))
    ```
  </action>
  <verify>
    `cargo check -p boternity-api` compiles.
    `cargo test --workspace` passes.
    Verify routes compile by checking the router builds.
  </verify>
  <done>REST API builder session endpoints handle create/answer/assemble/create-skill/resume/delete flows. Supports both bot and skill creation modes. Draft auto-save on every answer. Routes mounted on router.</done>
</task>

<task type="auto">
  <name>Task 2: WebSocket handler for Forge chat builder (bot + skill modes)</name>
  <files>
    crates/boternity-api/src/http/handlers/builder_ws.rs
    crates/boternity-api/src/http/handlers/mod.rs
    crates/boternity-api/src/http/router.rs
  </files>
  <action>
    Create `crates/boternity-api/src/http/handlers/builder_ws.rs`:

    **WebSocket endpoint: /ws/builder/:session_id** -- `builder_ws_handler`

    Follow the same WebSocket pattern established in Phase 5 (05-06 decision: tokio::select! single-loop, not socket.split()).

    **WsBuilderMessage** enum (serde tagged):
    - `StartBot { description: String }` -- client starts a new bot creation session
    - `StartSkill { description: String }` -- client starts a new standalone skill creation session
    - `Answer { answer: BuilderAnswer }` -- client sends an answer (works for both modes)
    - `AssembleBot { config: BuilderConfig }` -- client confirms bot assembly
    - `CreateSkill { skill_request: SkillBuildRequest }` -- client confirms skill creation
    - `Resume` -- client wants to resume from draft

    **WsBuilderResponse** enum (serde tagged):
    - `Turn { turn: BuilderTurn }` -- next builder turn (works for both modes)
    - `BotAssembled { result: AssemblyResult }` -- bot created
    - `SkillCreated { result: SkillBuildResult }` -- skill created
    - `Error { message: String }` -- error occurred

    Implementation:
    1. On WebSocket upgrade, extract session_id from path
    2. Check if draft exists for this session -- if yes, resume; if no, wait for StartBot or StartSkill message
    3. Track the session mode (bot or skill) in a local enum:
       ```rust
       enum SessionMode { Bot, Skill }
       ```
       Set on StartBot or StartSkill. For bot mode, use BuilderMode::NewBot in the system prompt. For skill mode, use BuilderMode::NewSkill -- the Forge prompt instructs the LLM to ask skill-specific questions (name, description, type, capabilities) instead of bot questions.
    4. Single-loop with tokio::select! handling:
       - Incoming WebSocket messages -> process and respond
       - Heartbeat ping/pong (30s interval, consistent with Phase 5)
    5. On each Answer: call builder.next_turn, save draft, send Turn response
    6. On AssembleBot (only valid in Bot mode): call BotAssembler, record memory, delete draft, send BotAssembled response
    7. On CreateSkill (only valid in Skill mode): call SkillBuilder::generate_skill, validate, write files, delete draft, send SkillCreated response
    8. On disconnect: draft remains saved (resumable)

    The skill creation flow through Forge chat works as follows:
    - User sends StartSkill { description: "A skill that fetches weather data" }
    - Forge (via LlmBuilderAgent with BuilderMode::NewSkill) asks questions about the skill: type (local/wasm), capabilities needed, trigger conditions
    - When enough context gathered, Forge signals ReadyToAssemble (reused turn type) with the skill config embedded
    - Client sends CreateSkill with the gathered SkillBuildRequest
    - Handler calls SkillBuilder::generate_skill, validates, writes to disk, responds with SkillCreated

    Per user decision: "Forge can modify/update existing skills -- full lifecycle management" and "both Forge chat and bnity skill create CLI command available for standalone skill creation". This task implements the Forge chat path for skill creation.

    Add `pub mod builder_ws;` to handler mod.rs.
    Mount in router: `.route("/ws/builder/:session_id", get(builder_ws::builder_ws_handler))`
  </action>
  <verify>
    `cargo check -p boternity-api` compiles.
    `cargo test --workspace` passes.
  </verify>
  <done>WebSocket builder handler enables real-time Forge chat for both bot creation AND standalone skill creation. Supports start-bot/start-skill/answer/assemble-bot/create-skill/resume messages. Session mode tracks bot vs skill flow. Draft persists across disconnects.</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- `cargo test --workspace` passes
- REST endpoints mounted at /api/v1/builder/*
- REST includes /create-skill endpoint for skill creation
- WebSocket endpoint mounted at /ws/builder/:session_id
- WebSocket supports both bot and skill creation modes (StartBot vs StartSkill)
- Both use LlmBuilderAgent for conversation
- Draft auto-save on every turn
</verification>

<success_criteria>
- POST /api/v1/builder/sessions accepts mode: "bot" or "skill"
- POST /api/v1/builder/sessions/:id/answer advances the conversation
- POST /api/v1/builder/sessions/:id/assemble creates the bot
- POST /api/v1/builder/sessions/:id/create-skill creates the skill
- GET /api/v1/builder/drafts lists saved drafts
- WebSocket /ws/builder/:id enables real-time Forge chat
- WebSocket StartBot and StartSkill messages start respective modes
- Both surfaces share the same builder agent
- Drafts persist across disconnects
</success_criteria>

<output>
After completion, create `.planning/phases/07-builder-system/07-08-SUMMARY.md`
</output>
