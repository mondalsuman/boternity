---
phase: 07-builder-system
plan: 08
type: execute
wave: 5
depends_on: ["07-05", "07-06"]
files_modified:
  - crates/boternity-api/src/http/handlers/builder.rs
  - crates/boternity-api/src/http/handlers/builder_ws.rs
  - crates/boternity-api/src/http/handlers/mod.rs
  - crates/boternity-api/src/http/router.rs
autonomous: true

must_haves:
  truths:
    - "REST endpoints manage builder sessions (create, get, advance, list drafts)"
    - "WebSocket endpoint enables real-time Forge chat builder"
    - "Both REST and WebSocket use the same LlmBuilderAgent"
    - "Draft auto-save works through REST API"
  artifacts:
    - path: "crates/boternity-api/src/http/handlers/builder.rs"
      provides: "REST API builder session handlers"
      contains: "create_builder_session"
    - path: "crates/boternity-api/src/http/handlers/builder_ws.rs"
      provides: "WebSocket handler for Forge chat"
      contains: "builder_ws_handler"
  key_links:
    - from: "crates/boternity-api/src/http/handlers/builder.rs"
      to: "crates/boternity-infra/src/builder/llm_builder.rs"
      via: "creates LlmBuilderAgent per session"
      pattern: "LlmBuilderAgent"
    - from: "crates/boternity-api/src/http/handlers/builder_ws.rs"
      to: "crates/boternity-infra/src/builder/llm_builder.rs"
      via: "drives builder conversation over WebSocket"
      pattern: "LlmBuilderAgent"
    - from: "crates/boternity-api/src/http/router.rs"
      to: "crates/boternity-api/src/http/handlers/builder.rs"
      via: "mounts builder routes"
      pattern: "/api/v1/builder"
---

<objective>
Create REST API and WebSocket handlers for the web builder.

Purpose: The web UI needs REST endpoints for the step-by-step wizard and a WebSocket endpoint for the Forge chat bot. Both surfaces share the same LlmBuilderAgent backend. Per research FINDING 3: REST for wizard, WebSocket for Forge chat.
Output: Builder REST handlers and WebSocket handler mounted on the HTTP router.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-builder-system/07-RESEARCH.md
@.planning/phases/07-builder-system/07-CONTEXT.md
@.planning/phases/07-builder-system/07-05-SUMMARY.md
@.planning/phases/07-builder-system/07-06-SUMMARY.md
@crates/boternity-api/src/http/router.rs
@crates/boternity-api/src/http/handlers/mod.rs
@crates/boternity-api/src/http/handlers/ws.rs
@crates/boternity-api/src/state.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: REST API builder session handlers</name>
  <files>
    crates/boternity-api/src/http/handlers/builder.rs
    crates/boternity-api/src/http/handlers/mod.rs
    crates/boternity-api/src/http/router.rs
  </files>
  <action>
    Create `crates/boternity-api/src/http/handlers/builder.rs`:

    **POST /api/v1/builder/sessions** -- `create_builder_session`
    - Body: `{ "description": "I want a coding assistant" }`
    - Creates a new session_id (UUID v7)
    - Creates LlmBuilderAgent with provider
    - Calls builder.start(session_id, description)
    - Saves initial state as draft
    - Returns: `{ "session_id": "...", "turn": BuilderTurn }`

    **POST /api/v1/builder/sessions/:session_id/answer** -- `submit_answer`
    - Body: `{ "answer": BuilderAnswer }` (OptionIndex, FreeText, Confirm, or Back)
    - Loads draft state from store
    - Calls builder.next_turn(state, answer)
    - If ReadyToAssemble, does NOT auto-assemble -- returns the turn for the UI to show confirmation
    - Saves updated state as draft
    - Returns: `{ "turn": BuilderTurn, "state_summary": { "phase": "...", "question_count": N } }`

    **POST /api/v1/builder/sessions/:session_id/assemble** -- `assemble_bot`
    - Body: `{ "config": BuilderConfig }` (the config from ReadyToAssemble turn)
    - Calls BotAssembler::assemble
    - Records builder memory
    - Deletes draft
    - Returns: `{ "result": AssemblyResult }` with bot details and file paths

    **GET /api/v1/builder/sessions/:session_id** -- `get_session`
    - Returns current state summary and last turn
    - Used for resuming sessions

    **GET /api/v1/builder/drafts** -- `list_drafts`
    - Returns list of saved drafts with summaries
    - Used for "Resume" UI

    **DELETE /api/v1/builder/sessions/:session_id** -- `delete_session`
    - Deletes the draft

    **POST /api/v1/builder/sessions/:session_id/reconfigure** -- `reconfigure_bot`
    - Body: `{ "bot_slug": "my-bot" }`
    - Loads existing bot config, populates BuilderState, calls reconfigure mode
    - Returns initial turn for reconfiguration

    Request/Response types: Use the standard envelope pattern from existing handlers (check `crates/boternity-api/src/http/response.rs`).

    Add `pub mod builder;` to `crates/boternity-api/src/http/handlers/mod.rs`.

    Mount routes in `crates/boternity-api/src/http/router.rs`:
    ```rust
    .route("/api/v1/builder/sessions", post(builder::create_builder_session))
    .route("/api/v1/builder/sessions/:session_id/answer", post(builder::submit_answer))
    .route("/api/v1/builder/sessions/:session_id/assemble", post(builder::assemble_bot))
    .route("/api/v1/builder/sessions/:session_id", get(builder::get_session).delete(builder::delete_session))
    .route("/api/v1/builder/sessions/:session_id/reconfigure", post(builder::reconfigure_bot))
    .route("/api/v1/builder/drafts", get(builder::list_drafts))
    ```
  </action>
  <verify>
    `cargo check -p boternity-api` compiles.
    `cargo test --workspace` passes.
    Verify routes compile by checking the router builds.
  </verify>
  <done>REST API builder session endpoints handle create/answer/assemble/resume/delete flows. Draft auto-save on every answer. Routes mounted on router.</done>
</task>

<task type="auto">
  <name>Task 2: WebSocket handler for Forge chat builder</name>
  <files>
    crates/boternity-api/src/http/handlers/builder_ws.rs
    crates/boternity-api/src/http/handlers/mod.rs
    crates/boternity-api/src/http/router.rs
  </files>
  <action>
    Create `crates/boternity-api/src/http/handlers/builder_ws.rs`:

    **WebSocket endpoint: /ws/builder/:session_id** -- `builder_ws_handler`

    Follow the same WebSocket pattern established in Phase 5 (05-06 decision: tokio::select! single-loop, not socket.split()).

    **WsBuilderMessage** enum (serde tagged):
    - `Start { description: String }` -- client starts a new session
    - `Answer { answer: BuilderAnswer }` -- client sends an answer
    - `Assemble { config: BuilderConfig }` -- client confirms assembly
    - `Resume` -- client wants to resume from draft

    **WsBuilderResponse** enum (serde tagged):
    - `Turn { turn: BuilderTurn }` -- next builder turn
    - `Assembled { result: AssemblyResult }` -- bot created
    - `Error { message: String }` -- error occurred

    Implementation:
    1. On WebSocket upgrade, extract session_id from path
    2. Check if draft exists for this session -- if yes, resume; if no, wait for Start message
    3. Single-loop with tokio::select! handling:
       - Incoming WebSocket messages -> process and respond
       - Heartbeat ping/pong (30s interval, consistent with Phase 5)
    4. On each Answer: call builder.next_turn, save draft, send Turn response
    5. On Assemble: call BotAssembler, record memory, delete draft, send Assembled response
    6. On disconnect: draft remains saved (resumable)

    The Forge chat bot in the web UI will connect to this WebSocket. The LlmBuilderAgent processes messages and returns structured turns. The web UI renders these as chat messages with interactive option buttons.

    Add `pub mod builder_ws;` to handler mod.rs.
    Mount in router: `.route("/ws/builder/:session_id", get(builder_ws::builder_ws_handler))`
  </action>
  <verify>
    `cargo check -p boternity-api` compiles.
    `cargo test --workspace` passes.
  </verify>
  <done>WebSocket builder handler enables real-time Forge chat. Supports start/answer/assemble/resume messages. Draft persists across disconnects.</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- `cargo test --workspace` passes
- REST endpoints mounted at /api/v1/builder/*
- WebSocket endpoint mounted at /ws/builder/:session_id
- Both use LlmBuilderAgent for conversation
- Draft auto-save on every turn
</verification>

<success_criteria>
- POST /api/v1/builder/sessions creates a new builder session
- POST /api/v1/builder/sessions/:id/answer advances the conversation
- POST /api/v1/builder/sessions/:id/assemble creates the bot
- GET /api/v1/builder/drafts lists saved drafts
- WebSocket /ws/builder/:id enables real-time Forge chat
- Both surfaces share the same builder agent
- Drafts persist across disconnects
</success_criteria>

<output>
After completion, create `.planning/phases/07-builder-system/07-08-SUMMARY.md`
</output>
