---
phase: 07-builder-system
plan: 10
type: execute
wave: 6
depends_on: ["07-08"]
files_modified:
  - apps/web/src/routes/builder/forge.tsx
  - apps/web/src/components/builder/forge-message.tsx
  - apps/web/src/components/builder/forge-options.tsx
  - apps/web/src/hooks/use-builder-ws.ts
  - apps/web/src/stores/forge-store.ts
autonomous: false

must_haves:
  truths:
    - "User can chat with Forge bot to create a bot through conversation"
    - "User can chat with Forge bot to create a skill through conversation (standalone)"
    - "Forge messages render as chat bubbles with interactive option buttons"
    - "Options are clickable buttons, not just text"
    - "Preview panel shows growing bot or skill configuration"
    - "Assembly confirmation shows in chat with create button"
    - "WebSocket connection for real-time conversation"
  artifacts:
    - path: "apps/web/src/routes/builder/forge.tsx"
      provides: "Forge chat interface route (bot + skill modes)"
      contains: "ForgePage"
    - path: "apps/web/src/hooks/use-builder-ws.ts"
      provides: "WebSocket hook for builder (bot + skill messages)"
      contains: "useBuilderWs"
    - path: "apps/web/src/stores/forge-store.ts"
      provides: "Forge conversation state"
      contains: "useForgeStore"
  key_links:
    - from: "apps/web/src/hooks/use-builder-ws.ts"
      to: "/ws/builder/:session_id"
      via: "WebSocket connection"
      pattern: "ws.*builder"
    - from: "apps/web/src/routes/builder/forge.tsx"
      to: "apps/web/src/hooks/use-builder-ws.ts"
      via: "uses WebSocket hook for real-time messages"
      pattern: "useBuilderWs"
---

<objective>
Build the Forge chat bot interface for conversational bot AND skill creation in the web UI.

Purpose: Per user decision, users can create bots AND skills by chatting with Forge -- a named character with its own avatar. The chat interface renders BuilderTurn responses as interactive messages with clickable option buttons. Uses WebSocket for real-time conversation. Per user decision: "both Forge chat and bnity skill create CLI command available for standalone skill creation" -- Forge handles both bot creation and standalone skill creation via the same chat interface.
Output: Forge chat route, WebSocket hook, message components with interactive options, supporting both bot and skill creation flows.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-builder-system/07-RESEARCH.md
@.planning/phases/07-builder-system/07-CONTEXT.md
@.planning/phases/07-builder-system/07-08-SUMMARY.md
@apps/web/src/routes/chat/$sessionId.tsx
@apps/web/src/hooks/use-agent-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: WebSocket hook and Forge state store</name>
  <files>
    apps/web/src/hooks/use-builder-ws.ts
    apps/web/src/stores/forge-store.ts
  </files>
  <action>
    1. Create `apps/web/src/hooks/use-builder-ws.ts`:

    Follow the WebSocket pattern from Phase 5 (05-08 decision: native WebSocket API, exponential backoff 1s-30s, 30% jitter, max 10 attempts).

    ```typescript
    export function useBuilderWs(sessionId: string | null) {
      // Connect to /ws/builder/{sessionId}
      // Handle messages: parse WsBuilderResponse
      // Send messages: serialize WsBuilderMessage
      // Reconnection with exponential backoff
      // Return: { sendStartBot, sendStartSkill, sendAnswer, sendAssembleBot, sendCreateSkill, isConnected, error }
    }
    ```

    The hook supports both bot and skill creation modes via distinct start messages:
    - `sendStartBot(description: string)` -- sends WsBuilderMessage::StartBot
    - `sendStartSkill(description: string)` -- sends WsBuilderMessage::StartSkill
    - `sendAnswer(answer: BuilderAnswer)` -- sends WsBuilderMessage::Answer (works for both modes)
    - `sendAssembleBot(config: BuilderConfig)` -- sends WsBuilderMessage::AssembleBot
    - `sendCreateSkill(request: SkillBuildRequest)` -- sends WsBuilderMessage::CreateSkill

    On incoming messages:
    - `Turn`: dispatch to forge store
    - `BotAssembled`: dispatch to forge store, show success
    - `SkillCreated`: dispatch to forge store, show success with skill details
    - `Error`: show error toast via sonner

    2. Create `apps/web/src/stores/forge-store.ts`:

    Zustand store for the Forge chat conversation:
    ```typescript
    type ForgeMode = 'bot' | 'skill' | null;

    interface ForgeMessage {
      id: string;
      role: 'forge' | 'user';
      content: string;         // Display text
      turn?: BuilderTurn;      // Structured turn data (for interactive rendering)
      timestamp: Date;
    }

    interface ForgeState {
      sessionId: string | null;
      mode: ForgeMode;         // tracks whether creating bot or skill
      messages: ForgeMessage[];
      preview: BuilderPreview | null;
      isAssembled: boolean;
      assemblyResult: AssemblyResult | null;
      skillResult: SkillBuildResult | null;

      // Actions
      addForgeMessage: (turn: BuilderTurn) => void;
      addUserMessage: (text: string) => void;
      setPreview: (preview: BuilderPreview) => void;
      setAssembled: (result: AssemblyResult) => void;
      setSkillCreated: (result: SkillBuildResult) => void;
      setMode: (mode: ForgeMode) => void;
      reset: () => void;
    }
    ```

    addForgeMessage converts BuilderTurn to a ForgeMessage:
    - AskQuestion: content = question text, turn = full turn data (for option buttons)
    - ShowPreview: content = "Here's what we have so far...", updates preview
    - ReadyToAssemble: content depends on mode:
      - bot mode: "I've got everything I need! Here's your bot:"
      - skill mode: "I've got everything I need! Here's your skill:"
      turn = full data
    - Clarify: content = message text

    addUserMessage: creates a user message with the selected option label or free text.
  </action>
  <verify>
    `cd apps/web && npx tsc --noEmit` type-checks.
    Verify WebSocket URL construction matches the backend route.
    Verify both sendStartBot and sendStartSkill are callable.
  </verify>
  <done>WebSocket hook connects to builder endpoint with reconnection, supporting both bot and skill creation. Forge store manages chat message history with mode tracking.</done>
</task>

<task type="auto">
  <name>Task 2: Forge chat interface with bot and skill creation</name>
  <files>
    apps/web/src/routes/builder/forge.tsx
    apps/web/src/components/builder/forge-message.tsx
    apps/web/src/components/builder/forge-options.tsx
  </files>
  <action>
    1. Create `apps/web/src/routes/builder/forge.tsx`:

    The Forge chat page. Layout similar to the existing chat interface but styled for the builder context:

    ```tsx
    // Left side: chat area (flex-1)
    // Right side: live preview panel (w-80, collapsible on mobile)

    <div className="flex h-full">
      {/* Chat area */}
      <div className="flex-1 flex flex-col">
        {/* Forge header */}
        <div className="border-b p-4 flex items-center gap-3">
          <ForgeAvatar />  {/* Forge's avatar -- anvil/hammer emoji or custom icon */}
          <div>
            <h2 className="font-semibold">Forge</h2>
            <p className="text-sm text-muted-foreground">Bot & Skill Builder</p>
          </div>
        </div>

        {/* Message list */}
        <div className="flex-1 overflow-y-auto p-4 space-y-4">
          {messages.map(msg => (
            <ForgeMessage key={msg.id} message={msg} mode={mode} onOptionSelect={handleOptionSelect} />
          ))}
          {isLoading && <TypingIndicator />}
        </div>

        {/* Input area */}
        <div className="border-t p-4">
          <div className="flex gap-2">
            <Input
              value={input}
              onChange={e => setInput(e.target.value)}
              placeholder="Type your answer or describe what you want..."
              onKeyDown={handleKeyDown}
            />
            <Button onClick={handleSend}>Send</Button>
          </div>
        </div>
      </div>

      {/* Preview panel */}
      {preview && (
        <div className="w-80 border-l p-4 hidden lg:block">
          <BuilderPreview preview={preview} />
        </div>
      )}
    </div>
    ```

    On mount:
    - Generate session_id (UUID)
    - Connect WebSocket
    - Check query params: `?mode=bot&description=...` or `?mode=skill&description=...`
    - If mode is "skill" (from query param or "Create Skill" button): call sendStartSkill(description)
    - If mode is "bot" (default): call sendStartBot(description)
    - If no description param, show Forge greeting: "Hi! I'm Forge. I can help you create bots or skills. What would you like to build?"

    **Intent detection from greeting:** If user types something like "I want to create a skill that..." the initial message is sent as StartSkill. If "I want a bot that..." it's sent as StartBot. Simple keyword detection in the client:
    - Contains "skill" -> StartSkill
    - Contains "bot", "assistant", "agent" or anything else -> StartBot (default)
    This is a UI convenience -- the backend BuilderMode controls the actual flow.

    2. Create `apps/web/src/components/builder/forge-message.tsx`:

    Renders a ForgeMessage as a chat bubble:

    For Forge messages (role = 'forge'):
    - Left-aligned bubble with Forge avatar
    - Text content rendered with markdown (reuse existing markdown renderer from Phase 4)
    - If turn is AskQuestion: render options below the message using ForgeOptions component
    - If turn is ReadyToAssemble:
      - In bot mode: render "Create Bot" button below the summary
      - In skill mode: render "Create Skill" button below the summary
    - Phase label shown as a subtle badge above the message

    For user messages (role = 'user'):
    - Right-aligned bubble, no avatar
    - Plain text

    3. Create `apps/web/src/components/builder/forge-options.tsx`:

    Interactive option buttons for AskQuestion turns:
    ```tsx
    <div className="flex flex-col gap-2 mt-3">
      {options.map((option, i) => (
        <button
          key={option.id}
          onClick={() => onSelect(i)}
          className="text-left p-3 rounded-lg border hover:bg-accent transition-colors"
        >
          <span className="font-medium">{option.label}</span>
          {option.description && (
            <span className="block text-sm text-muted-foreground mt-1">
              {option.description}
            </span>
          )}
        </button>
      ))}
    </div>
    ```

    Clicking an option sends the answer via WebSocket and adds a user message to the store.

    Register /builder/forge route in TanStack Router.
    Add link from /builder landing page: "Or chat with Forge" button.
    Add "Create Skill with Forge" link from /builder landing page (navigates to /builder/forge?mode=skill).
    The Forge chat is also accessible from the sidebar/navigation as a persistent entry point.
  </action>
  <verify>
    `cd apps/web && npm run build` completes without errors.
    `cd apps/web && npx tsc --noEmit` type-checks.
  </verify>
  <done>Forge chat interface with interactive option buttons, live preview panel, markdown rendering, and WebSocket real-time conversation. Supports both bot creation and standalone skill creation via mode detection.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Forge chat bot for conversational bot AND skill creation with interactive options and live preview</what-built>
  <how-to-verify>
    1. Start dev server (backend + frontend)
    2. Navigate to /builder
    3. Click "Chat with Forge"
    4. Verify: Forge greets you with its personality
    5. Type "I want a research assistant that helps with academic papers"
    6. Verify: Forge responds with a question and clickable option buttons
    7. Click an option -- verify it appears as your message and Forge responds
    8. Verify: preview panel on the right shows growing configuration
    9. Continue through the conversation until Forge says "Ready to create"
    10. Click "Create Bot" -- verify bot is created
    11. Verify: Forge congratulates and offers link to chat with new bot
    12. Test skill creation: navigate to /builder/forge?mode=skill or type "I want to create a skill that fetches weather data"
    13. Verify: Forge asks skill-specific questions (type, capabilities, trigger)
    14. Complete the skill flow and click "Create Skill"
    15. Verify: skill files written to ~/.boternity/skills/
    16. Test back navigation: during conversation, type "go back" or use back option
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
- Web app builds without errors
- TypeScript type-checks
- Forge chat accessible from /builder/forge
- WebSocket connects and maintains connection
- Interactive options clickable with visual feedback
- Preview panel updates in real-time
- Bot creation works end-to-end through chat
- Skill creation works end-to-end through chat (standalone, not just during bot creation)
</verification>

<success_criteria>
- Forge has distinct personality (warm, encouraging guide)
- Chat renders as message bubbles with Forge avatar
- AskQuestion turns show clickable option buttons with descriptions
- Live preview panel updates after each answer
- ReadyToAssemble shows summary with "Create Bot" or "Create Skill" button depending on mode
- Created bot opens in chat
- Skill creation flow asks type, capabilities, validates, writes files
- WebSocket reconnection works
- Mode detection: "skill" keyword routes to skill creation, default routes to bot creation
</success_criteria>

<output>
After completion, create `.planning/phases/07-builder-system/07-10-SUMMARY.md`
</output>
