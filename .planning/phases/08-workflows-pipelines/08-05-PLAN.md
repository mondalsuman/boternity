---
phase: 08-workflows-pipelines
plan: 05
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - crates/boternity-core/src/workflow/expression.rs
  - crates/boternity-core/src/workflow/retry.rs
  - crates/boternity-core/src/workflow/mod.rs
autonomous: true

must_haves:
  truths:
    - "JEXL expressions evaluate correctly with dot-notation property access on JSON contexts"
    - "Standard transforms (lower, upper, not, contains, startsWith, endsWith, match, length) are registered"
    - "LLM self-correction retry analyzes failure and suggests a different approach"
    - "Simple retry re-executes up to max_attempts without modification"
  artifacts:
    - path: "crates/boternity-core/src/workflow/expression.rs"
      provides: "WorkflowEvaluator with JEXL evaluation and standard transforms"
      min_lines: 80
    - path: "crates/boternity-core/src/workflow/retry.rs"
      provides: "RetryHandler with Simple and LlmSelfCorrect strategies"
      min_lines: 60
  key_links:
    - from: "crates/boternity-core/src/workflow/expression.rs"
      to: "jexl-eval"
      via: "Evaluator::new() + eval_in_context"
      pattern: "jexl_eval::Evaluator"
    - from: "crates/boternity-core/src/workflow/retry.rs"
      to: "crates/boternity-types/src/workflow.rs"
      via: "RetryConfig, RetryStrategy types"
      pattern: "RetryConfig|RetryStrategy"
---

<objective>
Build the JEXL expression evaluator for `when` clause filtering and conditional steps, and the retry handler with LLM self-correction support.

Purpose: Expressions power trigger filtering (`when: event.type == 'push'`) and conditional step branching. Retry with LLM self-correction is a key differentiator -- the agent analyzes what went wrong and tries a different approach.
Output: Expression evaluator and retry handler in boternity-core/workflow.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-workflows-pipelines/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: JEXL expression evaluator with standard transforms</name>
  <files>crates/boternity-core/src/workflow/expression.rs, crates/boternity-core/src/workflow/mod.rs</files>
  <action>
Create `expression.rs` with `WorkflowEvaluator`:

1. `WorkflowEvaluator` struct wrapping jexl_eval::Evaluator with pre-registered transforms.

2. `WorkflowEvaluator::new() -> Self`:
   - Create jexl_eval::Evaluator
   - Register standard transforms:
     - `lower`: `|value| value.as_str().map(|s| Value::String(s.to_lowercase()))`
     - `upper`: `|value| value.as_str().map(|s| Value::String(s.to_uppercase()))`
     - `not`: `|value| value.as_bool().map(|b| Value::Bool(!b))` (workaround for missing `!` operator)
     - `contains(substr)`: check if string contains substring
     - `startsWith(prefix)`: check if string starts with prefix
     - `endsWith(suffix)`: check if string ends with suffix
     - `match(pattern)`: regex matching using std::regex
     - `length`: returns string length or array length
     - `trim`: trims whitespace
     - `split(delim)`: splits string into array

   Note: jexl-eval 0.4 transform API uses closures. Consult the crate's actual API for exact registration syntax. Transforms take `&[Value]` args where first is the piped value and rest are transform arguments.

3. `evaluate_bool(&self, expression: &str, context: &serde_json::Value) -> Result<bool, WorkflowError>`:
   - Wraps payload in `{ "event": context }` for trigger `when` clauses
   - Calls evaluator.eval_in_context(expression, wrapped_context)
   - If result is Bool, return it. Otherwise WorkflowError::ExpressionError

4. `evaluate_in_workflow_context(&self, expression: &str, workflow_context: &WorkflowContext) -> Result<bool, WorkflowError>`:
   - Creates context JSON with `steps`, `trigger`, and `variables` from WorkflowContext
   - Used for conditional step evaluation (not trigger filtering)

5. `evaluate_value(&self, expression: &str, context: &serde_json::Value) -> Result<serde_json::Value, WorkflowError>`:
   - Returns raw evaluated value (not just bool) for more flexible expressions

CRITICAL: Per research, always pass payloads as context, NEVER interpolate into expression string (pitfall 7: expression injection).

Include comprehensive tests per research Deep Dive 1 findings:
- Dot-notation: `event.payload.user.name` on nested JSON
- Array indexing: `event.tags[0]`
- Boolean operators: `event.type == 'push' && event.branch == 'main'`
- Transforms: `event.name|lower`, `event.msg|contains('error')`
- NOT workaround: `(event.active)|not`
- Ternary with parens: `(event.count > 5) ? 'high' : 'low'`
- `in` operator: `'admin' in event.roles`
- Null handling: accessing undefined field returns null/false
  </action>
  <verify>`cargo test -p boternity-core -- workflow::expression` passes all expression evaluation tests</verify>
  <done>JEXL evaluator handles all workflow expression patterns with standard transforms registered</done>
</task>

<task type="auto">
  <name>Task 2: Retry handler with Simple and LLM self-correction strategies</name>
  <files>crates/boternity-core/src/workflow/retry.rs</files>
  <action>
Create `retry.rs` with `RetryHandler`:

1. `RetryHandler` struct (stateless, same pattern as MemoryExtractor from 02-06):

2. `should_retry(config: &RetryConfig, attempt: u32, error: &str) -> bool`:
   - Returns true if attempt < config.max_attempts
   - Max 3 LLM retry attempts per user decision

3. `prepare_retry(config: &RetryConfig, step: &StepDefinition, error: &str, context: &WorkflowContext) -> RetryAction`:
   - For RetryStrategy::Simple: return RetryAction::Rerun (same input)
   - For RetryStrategy::LlmSelfCorrect: return RetryAction::SelfCorrect { analysis_prompt: String }
     - Build analysis prompt: "The previous execution of step '{step.name}' failed with error: {error}. The step config was: {step.config}. Previous step outputs available: {context summary}. Analyze what went wrong and suggest a corrected approach. Return a JSON object with 'corrected_prompt' or 'corrected_input' field."
     - The actual LLM call happens in the executor (this just prepares the prompt)

4. `RetryAction` enum:
   - Rerun (re-execute same step unchanged)
   - SelfCorrect { analysis_prompt: String } (executor sends to LLM, gets corrected input, re-runs)

5. `build_self_correct_prompt(step_name: &str, step_config: &StepConfig, error: &str, attempt: u32, max_attempts: u32) -> String`:
   - Constructs the prompt that asks the LLM to analyze the failure
   - Includes the original step config, error message, attempt number
   - Asks for structured JSON response with corrected approach

Include tests:
- Simple retry returns Rerun for attempt < max
- Simple retry returns false for attempt >= max
- LlmSelfCorrect produces analysis prompt containing error details
- Max 3 attempts enforced regardless of strategy
  </action>
  <verify>`cargo test -p boternity-core -- workflow::retry` passes</verify>
  <done>Retry handler supports both Simple re-execution and LLM self-correction with proper attempt limits</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- JEXL expressions evaluate correctly for all 10 patterns from research
- Standard transforms (lower, upper, not, contains, startsWith, endsWith, match, length) work
- Retry handler enforces max 3 LLM attempts
- Self-correction prompt includes error context
</verification>

<success_criteria>
- WorkflowEvaluator correctly evaluates JEXL expressions with JSON context
- All standard transforms registered and functional
- RetryHandler produces correct RetryAction for both strategies
- Expression injection is prevented (payloads as context, not interpolated)
</success_criteria>

<output>
After completion, create `.planning/phases/08-workflows-pipelines/08-05-SUMMARY.md`
</output>
