---
phase: 08-workflows-pipelines
plan: 06
type: execute
wave: 3
depends_on: ["08-01", "08-02"]
files_modified:
  - crates/boternity-core/src/message/mod.rs
  - crates/boternity-core/src/message/bus.rs
  - crates/boternity-core/src/message/envelope.rs
  - crates/boternity-core/src/message/handler.rs
  - crates/boternity-core/src/message/router.rs
  - crates/boternity-core/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Bot A can send a direct message to Bot B and Bot B receives it"
    - "Bot A can publish to a channel and all subscribers receive the message"
    - "send_and_wait blocks until recipient responds (with timeout)"
    - "All messages are persisted to SQLite for audit trail"
    - "Loop prevention stops runaway bot-to-bot exchanges"
  artifacts:
    - path: "crates/boternity-core/src/message/bus.rs"
      provides: "MessageBus with direct + pub/sub delivery"
      min_lines: 120
    - path: "crates/boternity-core/src/message/handler.rs"
      provides: "MessageHandler with skill intercept + LLM fallback pipeline"
      min_lines: 60
    - path: "crates/boternity-core/src/message/router.rs"
      provides: "LoopGuard with depth, rate, and time window protection"
      min_lines: 60
  key_links:
    - from: "crates/boternity-core/src/message/bus.rs"
      to: "tokio::sync::mpsc"
      via: "per-bot mailbox channels"
      pattern: "mpsc::Sender|mpsc::Receiver"
    - from: "crates/boternity-core/src/message/bus.rs"
      to: "tokio::sync::broadcast"
      via: "per-channel pub/sub"
      pattern: "broadcast::Sender"
    - from: "crates/boternity-core/src/message/bus.rs"
      to: "crates/boternity-core/src/repository/message.rs"
      via: "MessageRepository for audit persistence"
      pattern: "MessageRepository"
---

<objective>
Build the bot-to-bot message bus with direct messaging, pub/sub channels, loop prevention, and message processing pipeline.

Purpose: Enables bot-to-bot collaboration both within and outside workflows. Direct messaging for 1:1, pub/sub for broadcast. All messages audited.
Output: MessageBus, LoopGuard, MessageHandler in boternity-core/message.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-workflows-pipelines/08-RESEARCH.md
@crates/boternity-core/src/event/bus.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: MessageBus with direct and pub/sub delivery</name>
  <files>crates/boternity-core/src/message/mod.rs, crates/boternity-core/src/message/bus.rs, crates/boternity-core/src/message/envelope.rs, crates/boternity-core/src/lib.rs</files>
  <action>
Create `crates/boternity-core/src/message/` module.

Create `mod.rs` exporting: `pub mod bus; pub mod envelope; pub mod handler; pub mod router;`

Create `envelope.rs` with helper functions:
- `create_direct_message(sender_id: Uuid, sender_name: &str, recipient_id: Uuid, message_type: &str, body: serde_json::Value) -> BotMessage` -- creates BotMessage with Direct recipient, Uuid::now_v7() id, Utc::now() timestamp
- `create_channel_message(sender_id: Uuid, sender_name: &str, channel: &str, message_type: &str, body: serde_json::Value) -> BotMessage` -- creates BotMessage with Channel recipient
- `create_reply(original: &BotMessage, sender_id: Uuid, sender_name: &str, body: serde_json::Value) -> BotMessage` -- reply with reply_to set to original.id

Create `bus.rs` with `MessageBus`:

```rust
pub struct MessageBus {
    // Per-bot direct mailboxes: bot_id -> sender
    direct_senders: Arc<DashMap<Uuid, mpsc::Sender<BotMessage>>>,
    // Per-channel broadcast: channel_name -> sender
    channel_senders: Arc<DashMap<String, broadcast::Sender<BotMessage>>>,
    // Reply channels for sync delivery: message_id -> oneshot sender
    reply_channels: Arc<DashMap<Uuid, oneshot::Sender<BotMessage>>>,
    // Loop guard
    loop_guard: Arc<LoopGuard>,
}
```

Methods:
- `new() -> Self`
- `register_bot(&self, bot_id: Uuid) -> mpsc::Receiver<BotMessage>` -- creates mailbox, returns receiver. If already registered, returns new receiver (old one dropped).
- `unregister_bot(&self, bot_id: &Uuid)` -- removes mailbox
- `send(&self, msg: BotMessage) -> Result<(), MessageError>` -- fire-and-forget delivery. For Direct: look up mailbox, send. For Channel: look up broadcast, send. Persists to MessageRepository via callback. Returns error if recipient not registered.
- `send_and_wait(&self, msg: BotMessage, timeout: Duration) -> Result<BotMessage, MessageError>` -- creates oneshot reply channel keyed by msg.id, sends message, waits for reply with timeout (default 30s). Returns MessageError::Timeout if no reply.
- `reply(&self, original_msg_id: &Uuid, reply: BotMessage) -> Result<(), MessageError>` -- sends reply through oneshot channel if waiting, otherwise through direct mailbox.
- `subscribe(&self, bot_id: Uuid, channel_name: &str) -> broadcast::Receiver<BotMessage>` -- subscribes bot to channel. Auto-creates channel sender if first subscriber (lazy creation per user decision).
- `unsubscribe(&self, _bot_id: &Uuid, _channel_name: &str)` -- removes subscription (note: broadcast doesn't support targeted unsubscribe; receiver is dropped by caller)
- `publish(&self, msg: BotMessage) -> Result<usize, MessageError>` -- publishes to channel. Returns number of receivers.
- `is_registered(&self, bot_id: &Uuid) -> bool` -- checks if bot has active mailbox

`MessageError` enum: NotRegistered(Uuid), Timeout, ChannelFull, LoopDetected(String), SendFailed.

Channel buffer size: 256 for direct (mpsc), 1024 for broadcast.

Add `pub mod message;` to `crates/boternity-core/src/lib.rs`.

Include tests:
- Direct send and receive
- send_and_wait with reply
- send_and_wait timeout
- Channel publish to multiple subscribers
- Unregistered bot returns NotRegistered error
  </action>
  <verify>`cargo test -p boternity-core -- message::bus` passes</verify>
  <done>MessageBus delivers direct and channel messages with sync/async options</done>
</task>

<task type="auto">
  <name>Task 2: LoopGuard and MessageHandler pipeline</name>
  <files>crates/boternity-core/src/message/router.rs, crates/boternity-core/src/message/handler.rs</files>
  <action>
Create `router.rs` with `LoopGuard`:

Per research, 3-layer loop prevention:

```rust
pub struct LoopGuard {
    // Layer 1: Delegation depth per conversation chain
    delegation_depths: DashMap<Uuid, u32>,  // root_message_id -> current depth
    max_delegation_depth: u32,              // default 5

    // Layer 2: Exchange rate per bot pair
    exchange_counts: DashMap<(Uuid, Uuid), ExchangeWindow>,
    max_exchanges_per_window: u32,          // default 10

    // Layer 3: Time window
    window_duration: Duration,              // default 60 seconds
}

struct ExchangeWindow {
    count: u32,
    window_start: Instant,
}
```

Methods:
- `new() -> Self` (with defaults: depth=5, exchanges=10, window=60s)
- `check_allowed(&self, sender_id: &Uuid, recipient_id: &Uuid, reply_to: Option<&Uuid>) -> Result<(), MessageError>`:
  - Layer 1: If reply_to exists, check delegation chain depth. Increment. If >= max, LoopDetected.
  - Layer 2: Get exchange count for (sender, recipient) pair. If window expired, reset. If count >= max, LoopDetected.
  - Layer 3: Time window handled in Layer 2 (reset on expiry).
- `record_exchange(&self, sender_id: &Uuid, recipient_id: &Uuid)` -- increment counter
- `reset_pair(&self, bot_a: &Uuid, bot_b: &Uuid)` -- manual reset

Create `handler.rs` with `MessageHandler`:

The message processing pipeline per research:
1. Check bot's message_handler skill -> if exists, run skill first
2. If skill returns "handled" -> send reply, done
3. If skill returns "pass_through" or no handler -> forward to LLM
4. Create/reuse bot-to-bot session (tagged session_type = 'bot-to-bot')
5. Execute via AgentEngine (non-streaming)
6. Persist exchange to bot-to-bot session

For now, define the trait and a basic implementation:

```rust
pub trait MessageProcessor: Send + Sync {
    fn process_message(
        &self,
        bot_id: &Uuid,
        message: &BotMessage,
    ) -> impl Future<Output = Result<Option<BotMessage>, MessageError>>;
}
```

Implement `DefaultMessageProcessor`:
- Holds no fields (processing pipeline wired later via AppState in Plan 09)
- Returns None for now (placeholder -- actual LLM/skill processing wired in integration plan)
- The key structure is the trait definition so that Plan 09 can provide a concrete implementation

Include tests:
- LoopGuard allows normal exchange
- LoopGuard blocks after max delegation depth
- LoopGuard blocks after max exchanges in window
- LoopGuard resets after time window expires
  </action>
  <verify>`cargo test -p boternity-core -- message::router message::handler` passes</verify>
  <done>LoopGuard prevents runaway bot-to-bot exchanges with 3-layer protection, MessageHandler trait defined</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- Direct messages deliver between registered bots
- send_and_wait blocks and returns reply or times out
- Pub/sub channels auto-create and broadcast to subscribers
- LoopGuard enforces depth, rate, and time window limits
</verification>

<success_criteria>
- MessageBus supports both direct (1:1) and pub/sub (one-to-many) delivery
- send_and_wait provides synchronous request-reply pattern
- All messages are typed envelopes with flexible JSON body
- LoopGuard prevents infinite bot-to-bot loops with 3 layers
- MessageProcessor trait defined for future LLM/skill integration
</success_criteria>

<output>
After completion, create `.planning/phases/08-workflows-pipelines/08-06-SUMMARY.md`
</output>
