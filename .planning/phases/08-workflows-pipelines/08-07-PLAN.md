---
phase: 08-workflows-pipelines
plan: 07
type: execute
wave: 4
depends_on: ["08-04", "08-05"]
files_modified:
  - crates/boternity-core/src/workflow/trigger.rs
  - crates/boternity-core/src/workflow/scheduler.rs
  - crates/boternity-infra/src/workflow/mod.rs
  - crates/boternity-infra/src/workflow/file_trigger.rs
  - crates/boternity-infra/src/workflow/webhook_handler.rs
  - crates/boternity-infra/src/lib.rs
  - crates/boternity-core/src/workflow/mod.rs
autonomous: true

must_haves:
  truths:
    - "Cron-triggered workflows fire on schedule"
    - "Human-readable schedules ('every 5 minutes') work alongside standard cron"
    - "Webhook triggers verify HMAC-SHA256 or bearer token auth"
    - "EventBus triggers fire when matching events are published"
    - "File watch triggers fire when watched paths change"
    - "when clause filtering correctly gates trigger execution"
    - "Missed cron runs are caught up on restart"
  artifacts:
    - path: "crates/boternity-core/src/workflow/trigger.rs"
      provides: "TriggerManager coordinating all trigger types"
      min_lines: 100
    - path: "crates/boternity-core/src/workflow/scheduler.rs"
      provides: "CronScheduler wrapping tokio-cron-scheduler with missed-run catch-up"
      min_lines: 80
    - path: "crates/boternity-infra/src/workflow/webhook_handler.rs"
      provides: "Axum handler for incoming webhooks with HMAC verification"
      min_lines: 60
    - path: "crates/boternity-infra/src/workflow/file_trigger.rs"
      provides: "File watcher bridge to async tokio"
      min_lines: 50
  key_links:
    - from: "crates/boternity-core/src/workflow/scheduler.rs"
      to: "tokio-cron-scheduler"
      via: "JobScheduler wrapping"
      pattern: "JobScheduler|tokio_cron_scheduler"
    - from: "crates/boternity-infra/src/workflow/webhook_handler.rs"
      to: "hmac + sha2"
      via: "HMAC-SHA256 signature verification"
      pattern: "Hmac|HmacSha256"
    - from: "crates/boternity-infra/src/workflow/file_trigger.rs"
      to: "notify"
      via: "File system event bridge"
      pattern: "notify::.*Watcher|recommended_watcher"
---

<objective>
Build the complete trigger system: cron scheduling, webhook receivers, EventBus listeners, and file watchers.

Purpose: Workflows need to be triggered by external events, schedules, and system events. This plan wires all 5 trigger types (manual, cron, webhook, event, file_watch) with expression-based filtering.
Output: TriggerManager, CronScheduler, webhook handler, file watcher in core + infra.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-workflows-pipelines/08-RESEARCH.md
@crates/boternity-core/src/workflow/expression.rs
@crates/boternity-core/src/workflow/executor.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: CronScheduler with missed-run catch-up and TriggerManager</name>
  <files>crates/boternity-core/src/workflow/scheduler.rs, crates/boternity-core/src/workflow/trigger.rs, crates/boternity-core/src/workflow/mod.rs</files>
  <action>
Create `scheduler.rs` with `CronScheduler`:

Wraps `tokio-cron-scheduler::JobScheduler` with custom missed-run detection.

```rust
pub struct CronScheduler {
    scheduler: JobScheduler,
}
```

Methods:
- `new() -> Result<Self, WorkflowError>` -- creates JobScheduler::new().await
- `schedule_workflow(&self, workflow_name: &str, schedule: &str, callback: impl Fn() -> BoxFuture<'static, ()> + Send + Sync + 'static) -> Result<(), WorkflowError>`:
  - Parse schedule: try english-to-cron first (if tokio-cron-scheduler "english" feature handles this natively, use that). Otherwise try raw cron.
  - Create Job::new_async with the callback
  - Add to scheduler
- `start(&self) -> Result<(), WorkflowError>` -- scheduler.start().await
- `stop(&self) -> Result<(), WorkflowError>` -- scheduler.shutdown().await
- `check_missed_runs(workflows: &[(String, String, DateTime<Utc>)]) -> Vec<String>`:
  - Takes (workflow_name, cron_schedule, last_run_at) tuples
  - For each: parse cron via croner, compute last expected occurrence before now
  - If last_run_at < last_expected_occurrence, workflow missed a run -- add to return list
  - This is called on startup to catch up missed cron runs per user decision

Create `trigger.rs` with `TriggerManager`:

Coordinates all trigger types for a single workflow.

```rust
pub struct TriggerManager {
    cron_scheduler: CronScheduler,
    expression_evaluator: WorkflowEvaluator,
    event_bus_subscriber: broadcast::Receiver<AgentEvent>,
    // File watchers stored here, keyed by workflow name
    file_watchers: DashMap<String, ()>,  // placeholder for watcher handles
}
```

Methods:
- `new(event_bus: &EventBus) -> Result<Self, WorkflowError>`
- `register_workflow<F>(&self, def: &WorkflowDefinition, trigger_callback: F) -> Result<(), WorkflowError>` where F: Fn(TriggerContext) -> BoxFuture:
  - For each trigger in def.triggers:
    - Manual: no-op (triggered explicitly via API)
    - Cron: schedule via cron_scheduler
    - Webhook: register path mapping (stored for lookup by webhook handler)
    - Event: subscribe to EventBus, filter by event_type, evaluate `when` clause via expression_evaluator
    - FileWatch: start file watcher via infra file_trigger module
  - `when` clause evaluation: before invoking callback, call expression_evaluator.evaluate_bool() with trigger payload. Only fire if true (or no when clause).

- `unregister_workflow(&self, workflow_name: &str) -> Result<(), WorkflowError>` -- removes all triggers for workflow

- `start(&self) -> Result<(), WorkflowError>` -- starts cron scheduler and event listeners
- `stop(&self) -> Result<(), WorkflowError>` -- stops all

`TriggerContext`:
- trigger_type: String ("manual", "cron", "webhook", "event", "file_watch")
- payload: Option<serde_json::Value>
- triggered_at: DateTime<Utc>

Update `mod.rs` to export: `pub mod trigger; pub mod scheduler;`

Include tests:
- CronScheduler parses standard cron expression
- check_missed_runs detects workflow that should have run
- check_missed_runs returns empty for up-to-date workflow
- TriggerManager registers and fires manual trigger
  </action>
  <verify>`cargo test -p boternity-core -- workflow::scheduler workflow::trigger` passes</verify>
  <done>CronScheduler wraps tokio-cron-scheduler with missed-run catch-up, TriggerManager coordinates all trigger types</done>
</task>

<task type="auto">
  <name>Task 2: Webhook handler and file watcher infrastructure</name>
  <files>crates/boternity-infra/src/workflow/mod.rs, crates/boternity-infra/src/workflow/webhook_handler.rs, crates/boternity-infra/src/workflow/file_trigger.rs, crates/boternity-infra/src/lib.rs</files>
  <action>
Create `crates/boternity-infra/src/workflow/` module directory.

Create `mod.rs` exporting: `pub mod webhook_handler; pub mod file_trigger;`

Create `webhook_handler.rs`:

1. `verify_hmac_sha256(payload: &[u8], signature_header: &str, secret: &[u8]) -> Result<(), WebhookError>`:
   - Strip "sha256=" prefix if present (GitHub convention)
   - Decode hex signature
   - Create HmacSha256 from secret
   - mac.update(payload)
   - mac.verify_slice -- constant-time comparison
   - Per research code example

2. `verify_bearer_token(auth_header: &str, expected_token: &str) -> Result<(), WebhookError>`:
   - Strip "Bearer " prefix
   - Constant-time comparison with expected token

3. `WebhookError` enum: InvalidSignature, SignatureMismatch, MissingHeader, InvalidSecret, InvalidToken

4. `WebhookRegistry`:
   - `registered_webhooks: DashMap<String, WebhookConfig>` (path -> config)
   - `register(&self, path: &str, config: WebhookConfig)`
   - `get_config(&self, path: &str) -> Option<WebhookConfig>`
   - `unregister(&self, path: &str)`

Create `file_trigger.rs`:

1. `start_file_watcher(paths: Vec<PathBuf>) -> Result<(mpsc::Receiver<notify::Event>, WatcherHandle), WorkflowError>`:
   - Create notify::recommended_watcher with callback that uses tx.blocking_send() (per research pitfall 4)
   - Watch all paths recursively
   - Return receiver + handle (keeps watcher alive)
   - Per research code example

2. `WatcherHandle` struct wrapping JoinHandle to keep watcher alive

3. `filter_events(event: &notify::Event, patterns: &[String]) -> bool`:
   - Checks if event path matches any of the glob patterns
   - Used for optional pattern filtering on file watch triggers

Add `pub mod workflow;` to `crates/boternity-infra/src/lib.rs`.

Include tests:
- HMAC-SHA256 verification with known test vectors
- Bearer token verification
- Invalid signature rejected
- File watcher event filtering by pattern
  </action>
  <verify>`cargo test -p boternity-infra -- workflow::webhook workflow::file_trigger` passes</verify>
  <done>Webhook HMAC/bearer verification and file watcher bridge to async tokio implemented</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- Cron scheduling parses both standard and human-readable schedules
- Missed-run catch-up detects workflows that should have run during downtime
- Webhook verification works for both HMAC-SHA256 and bearer token
- File watcher bridges sync notify events to async tokio channels
- Expression-based filtering gates trigger execution
</verification>

<success_criteria>
- All 5 trigger types implemented (manual, cron, webhook, event, file_watch)
- `when` clause filtering evaluates JEXL expressions against trigger payloads
- Human-readable cron strings work ("every 5 minutes", "daily at 9am")
- Missed cron runs caught up on restart
- Webhook auth supports both HMAC-SHA256 and bearer token
</success_criteria>

<output>
After completion, create `.planning/phases/08-workflows-pipelines/08-07-SUMMARY.md`
</output>
