---
phase: 08-workflows-pipelines
plan: 08
type: execute
wave: 5
depends_on: ["08-04", "08-06", "08-07"]
files_modified:
  - crates/boternity-api/src/cli/workflow.rs
  - crates/boternity-api/src/cli/message.rs
  - crates/boternity-api/src/cli/mod.rs
autonomous: true

must_haves:
  truths:
    - "User can create a workflow from a YAML file via CLI"
    - "User can trigger a workflow manually via CLI"
    - "User can list workflows and check run status via CLI"
    - "User can send bot-to-bot messages via CLI"
    - "User can list channels and subscriptions via CLI"
  artifacts:
    - path: "crates/boternity-api/src/cli/workflow.rs"
      provides: "CLI commands: create, trigger, list, status, logs, delete"
      min_lines: 150
    - path: "crates/boternity-api/src/cli/message.rs"
      provides: "CLI commands: send, channels, subscribe, unsubscribe, history"
      min_lines: 80
  key_links:
    - from: "crates/boternity-api/src/cli/workflow.rs"
      to: "crates/boternity-core/src/workflow/definition.rs"
      via: "load_workflow_file for create command"
      pattern: "load_workflow_file|parse_workflow_yaml"
    - from: "crates/boternity-api/src/cli/workflow.rs"
      to: "crates/boternity-core/src/workflow/executor.rs"
      via: "WorkflowExecutor for trigger command"
      pattern: "WorkflowExecutor|execute"
---

<objective>
Build CLI commands for workflow management and bot-to-bot messaging.

Purpose: Users need to create, trigger, list, and inspect workflows from the terminal. They also need to send inter-bot messages and manage channels. Requirement CLII-05.
Output: `bnity workflow` and `bnity message` CLI subcommands.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-workflows-pipelines/08-RESEARCH.md
@crates/boternity-api/src/cli/mod.rs
@crates/boternity-api/src/cli/skill.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: CLI workflow commands (create, trigger, list, status, logs, delete)</name>
  <files>crates/boternity-api/src/cli/workflow.rs, crates/boternity-api/src/cli/mod.rs</files>
  <action>
Create `crates/boternity-api/src/cli/workflow.rs` with clap-derived `WorkflowCommand` enum:

```rust
#[derive(Subcommand)]
pub enum WorkflowCommand {
    /// Create a workflow from a YAML file
    Create {
        /// Path to the workflow YAML file
        file: PathBuf,
        /// Assign to a specific bot (bot-scoped). Omit for global workflow.
        #[arg(long)]
        bot: Option<String>,
    },
    /// Trigger a workflow manually
    Trigger {
        /// Workflow name
        name: String,
        /// Bot scope (if bot-scoped workflow)
        #[arg(long)]
        bot: Option<String>,
        /// JSON payload to pass as trigger context
        #[arg(long)]
        payload: Option<String>,
    },
    /// List all workflows
    List {
        /// Filter by bot scope
        #[arg(long)]
        bot: Option<String>,
    },
    /// Show workflow run status
    Status {
        /// Workflow name or run ID
        target: String,
        /// Show last N runs (default 5)
        #[arg(long, default_value = "5")]
        limit: u32,
    },
    /// Show step-level logs for a specific run
    Logs {
        /// Run ID
        run_id: String,
    },
    /// Delete a workflow definition
    Delete {
        /// Workflow name
        name: String,
        /// Bot scope (if bot-scoped workflow)
        #[arg(long)]
        bot: Option<String>,
    },
    /// Approve a paused workflow step
    Approve {
        /// Run ID of the paused workflow
        run_id: String,
    },
    /// Cancel a running workflow
    Cancel {
        /// Run ID
        run_id: String,
    },
}
```

Implement `handle_workflow_command(cmd: WorkflowCommand, state: &AppState)`:

- **Create**: load_workflow_file(path), resolve owner (Global or Bot by slug lookup), save_definition to repo. Print "Workflow '{name}' created with {N} steps and {M} triggers."
- **Trigger**: look up workflow by name + owner, call executor.execute() with manual trigger type and optional payload. Print run ID and "Workflow triggered. Run ID: {id}". If payload provided, parse as JSON.
- **List**: list_definitions from repo, display in comfy-table: Name | Owner | Steps | Triggers | Last Run
- **Status**: list_runs for workflow, display table: Run ID | Status | Trigger | Started | Duration | Error
- **Logs**: list_step_logs for run, display table: Step | Status | Attempt | Duration | Error. Color-code status (green=completed, yellow=running, red=failed, blue=waiting_approval).
- **Delete**: delete_definition, print confirmation. Use dialoguer::Confirm for safety.
- **Approve**: find run in paused state, approve the pending approval step, resume execution.
- **Cancel**: cancel running workflow via executor.cancel().

Add `WorkflowCommand` as `Workflow` variant to the main CLI command enum in mod.rs (following existing pattern like `Skill`, `Provider`, `Storage` etc.).

Include tests for argument parsing.
  </action>
  <verify>`cargo check -p boternity-api` compiles and CLI help text shows workflow subcommands</verify>
  <done>All workflow CLI commands implemented: create, trigger, list, status, logs, delete, approve, cancel</done>
</task>

<task type="auto">
  <name>Task 2: CLI bot-to-bot message commands</name>
  <files>crates/boternity-api/src/cli/message.rs</files>
  <action>
Create `crates/boternity-api/src/cli/message.rs` with clap-derived `MessageCommand` enum:

```rust
#[derive(Subcommand)]
pub enum MessageCommand {
    /// Send a message from one bot to another
    Send {
        /// Sender bot slug
        #[arg(long)]
        from: String,
        /// Recipient bot slug (for direct message)
        #[arg(long)]
        to: Option<String>,
        /// Channel name (for channel message)
        #[arg(long)]
        channel: Option<String>,
        /// Message type tag
        #[arg(long, default_value = "text")]
        message_type: String,
        /// Message body (text or JSON)
        body: String,
        /// Wait for reply (sync mode)
        #[arg(long)]
        wait: bool,
        /// Timeout in seconds for --wait (default 30)
        #[arg(long, default_value = "30")]
        timeout: u64,
    },
    /// List conversation history between two bots
    History {
        /// First bot slug
        bot_a: String,
        /// Second bot slug
        bot_b: String,
        /// Max messages to show (default 20)
        #[arg(long, default_value = "20")]
        limit: u32,
    },
    /// List all pub/sub channels
    Channels,
    /// Subscribe a bot to a channel
    Subscribe {
        /// Bot slug
        bot: String,
        /// Channel name
        channel: String,
    },
    /// Unsubscribe a bot from a channel
    Unsubscribe {
        /// Bot slug
        bot: String,
        /// Channel name
        channel: String,
    },
    /// Show messages in a channel
    ChannelHistory {
        /// Channel name
        channel: String,
        /// Max messages to show (default 20)
        #[arg(long, default_value = "20")]
        limit: u32,
    },
}
```

Implement `handle_message_command(cmd: MessageCommand, state: &AppState)`:

- **Send**: look up sender and recipient bots by slug, create BotMessage envelope, send via MessageBus. If --wait, use send_and_wait with timeout. Print reply or "Message sent."
- **History**: look up both bots, query MessageRepository::get_messages_between, display in timeline format.
- **Channels**: list_channels from repo, display table: Name | Created | Created By | Subscribers
- **Subscribe/Unsubscribe**: look up bot, call repo methods, print confirmation.
- **ChannelHistory**: query get_channel_messages, display in timeline format.

Add `MessageCommand` as `Message` variant to the main CLI command enum in mod.rs.

Body parsing: try JSON parse first, fallback to wrapping as `{"text": body}` (same pattern as KV store from 03-13).
  </action>
  <verify>`cargo check -p boternity-api` compiles and CLI help text shows message subcommands</verify>
  <done>Bot-to-bot message CLI commands implemented: send, history, channels, subscribe, unsubscribe, channel-history</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- `bnity workflow --help` shows all subcommands
- `bnity message --help` shows all subcommands
- Workflow create accepts YAML file path
- Workflow trigger accepts name and optional payload
- Message send accepts --from, --to/--channel, body
</verification>

<success_criteria>
- CLII-05: Workflow management (create, trigger, list, status) via CLI
- Bot-to-bot messaging via CLI (send, history, channels)
- Color-coded status output for workflow runs and steps
- Workflow approval and cancellation from CLI
</success_criteria>

<output>
After completion, create `.planning/phases/08-workflows-pipelines/08-08-SUMMARY.md`
</output>
