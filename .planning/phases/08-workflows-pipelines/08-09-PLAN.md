---
phase: 08-workflows-pipelines
plan: 09
type: execute
wave: 5
depends_on: ["08-04", "08-06", "08-07"]
files_modified:
  - crates/boternity-api/src/http/handlers/workflow.rs
  - crates/boternity-api/src/http/handlers/webhook.rs
  - crates/boternity-api/src/http/handlers/message.rs
  - crates/boternity-api/src/http/handlers/mod.rs
  - crates/boternity-api/src/state.rs
autonomous: true

must_haves:
  truths:
    - "REST API supports workflow CRUD, trigger, and run status"
    - "Webhook receiver validates auth and triggers workflows"
    - "Bot-to-bot messaging available via REST API"
    - "AppState holds workflow executor, message bus, trigger manager, and repositories"
  artifacts:
    - path: "crates/boternity-api/src/http/handlers/workflow.rs"
      provides: "REST endpoints for workflow CRUD, trigger, runs, steps, approve"
      min_lines: 150
    - path: "crates/boternity-api/src/http/handlers/webhook.rs"
      provides: "POST /api/v1/webhooks/:path receiver with auth verification"
      min_lines: 50
    - path: "crates/boternity-api/src/http/handlers/message.rs"
      provides: "REST endpoints for bot-to-bot messaging and channels"
      min_lines: 80
    - path: "crates/boternity-api/src/state.rs"
      provides: "AppState with Phase 8 services"
      min_lines: 10
  key_links:
    - from: "crates/boternity-api/src/http/handlers/workflow.rs"
      to: "crates/boternity-core/src/workflow/executor.rs"
      via: "WorkflowExecutor for trigger endpoint"
      pattern: "execute|WorkflowExecutor"
    - from: "crates/boternity-api/src/http/handlers/webhook.rs"
      to: "crates/boternity-infra/src/workflow/webhook_handler.rs"
      via: "verify_hmac_sha256 for webhook auth"
      pattern: "verify_hmac|verify_bearer"
    - from: "crates/boternity-api/src/state.rs"
      to: "crates/boternity-core/src/message/bus.rs"
      via: "MessageBus on AppState"
      pattern: "MessageBus"
---

<objective>
Build REST API handlers for workflows, webhooks, and bot-to-bot messaging, and wire all Phase 8 services into AppState.

Purpose: The web UI and external integrations need REST endpoints. AppState must hold the executor, message bus, and trigger manager for both CLI and HTTP use.
Output: REST handlers in boternity-api/http/handlers, updated AppState.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-workflows-pipelines/08-RESEARCH.md
@crates/boternity-api/src/state.rs
@crates/boternity-api/src/http/handlers/mod.rs
@crates/boternity-api/src/http/handlers/builder.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: REST API workflow and webhook handlers</name>
  <files>crates/boternity-api/src/http/handlers/workflow.rs, crates/boternity-api/src/http/handlers/webhook.rs, crates/boternity-api/src/http/handlers/mod.rs</files>
  <action>
Create `crates/boternity-api/src/http/handlers/workflow.rs` with endpoints:

1. `POST /api/v1/workflows` -- Create workflow
   - Body: WorkflowDefinition JSON
   - Validates definition, saves to repo
   - Returns 201 with { id, name, steps_count, triggers_count }

2. `GET /api/v1/workflows` -- List workflows
   - Query params: ?bot=slug (optional filter)
   - Returns array of workflow summaries

3. `GET /api/v1/workflows/:id` -- Get workflow detail
   - Returns full WorkflowDefinition

4. `PUT /api/v1/workflows/:id` -- Update workflow
   - Body: WorkflowDefinition JSON
   - Validates, updates in repo
   - Returns 200

5. `DELETE /api/v1/workflows/:id` -- Delete workflow
   - Returns 204

6. `POST /api/v1/workflows/:id/trigger` -- Trigger workflow manually
   - Body: optional { payload: Value }
   - Creates and starts a workflow run
   - Returns 202 with { run_id, status: "running" }

7. `GET /api/v1/workflows/:id/runs` -- List workflow runs
   - Query params: ?limit=10
   - Returns array of WorkflowRun

8. `GET /api/v1/runs/:run_id` -- Get run detail with step logs
   - Returns { run: WorkflowRun, steps: Vec<WorkflowStepLog> }

9. `POST /api/v1/runs/:run_id/approve` -- Approve paused workflow
   - Returns 200 with updated run status

10. `POST /api/v1/runs/:run_id/cancel` -- Cancel running workflow
    - Returns 200 with updated run status

Create `crates/boternity-api/src/http/handlers/webhook.rs`:

1. `POST /api/v1/webhooks/:path` -- Webhook receiver
   - Extract raw body bytes for signature verification
   - Look up webhook config by path in WebhookRegistry
   - If HMAC auth: extract X-Hub-Signature-256 header, verify via verify_hmac_sha256
   - If Bearer auth: extract Authorization header, verify via verify_bearer_token
   - Parse body as JSON
   - Evaluate `when` clause if present
   - If passes: trigger associated workflow with webhook payload
   - Returns 200 { accepted: true } or 401/403 on auth failure

Create router function `workflow_routes() -> Router<AppState>` mounting all endpoints.

Add `pub mod workflow;` and `pub mod webhook;` to handlers/mod.rs. Wire routes into the main router.

Follow existing handler patterns: extract State<AppState>, Json<T> body, return axum Json responses with appropriate status codes. Use envelope responses consistent with existing handlers.
  </action>
  <verify>`cargo check -p boternity-api` compiles</verify>
  <done>All workflow and webhook REST endpoints implemented with proper routing</done>
</task>

<task type="auto">
  <name>Task 2: REST API message handlers and AppState Phase 8 wiring</name>
  <files>crates/boternity-api/src/http/handlers/message.rs, crates/boternity-api/src/state.rs</files>
  <action>
Create `crates/boternity-api/src/http/handlers/message.rs` with endpoints:

1. `POST /api/v1/messages/send` -- Send bot-to-bot message
   - Body: { from_bot_id: Uuid, to_bot_id: Option<Uuid>, channel: Option<String>, message_type: String, body: Value, wait: Option<bool> }
   - Routes to MessageBus.send() or send_and_wait() based on `wait` flag
   - Returns { message_id, reply: Option<BotMessage> }

2. `GET /api/v1/messages/history/:bot_a/:bot_b` -- Get conversation history
   - Query params: ?limit=20
   - Returns array of BotMessage

3. `GET /api/v1/channels` -- List channels
   - Returns array of Channel with subscriber counts

4. `POST /api/v1/channels/:name/subscribe` -- Subscribe bot to channel
   - Body: { bot_id: Uuid }
   - Returns 200

5. `DELETE /api/v1/channels/:name/subscribe/:bot_id` -- Unsubscribe
   - Returns 204

6. `GET /api/v1/channels/:name/messages` -- Channel message history
   - Query params: ?limit=20
   - Returns array of BotMessage

Add `pub mod message;` to handlers/mod.rs. Wire routes.

**Update `crates/boternity-api/src/state.rs`** -- add Phase 8 services to AppState:

```rust
// --- Phase 8 services ---
/// Workflow definition and run persistence.
pub workflow_repo: Arc<SqliteWorkflowRepository>,
/// Bot-to-bot message persistence.
pub message_repo: Arc<SqliteMessageRepository>,
/// Bot-to-bot message bus (direct + pub/sub).
pub message_bus: Arc<MessageBus>,
/// Webhook registry for incoming webhook path-to-workflow mapping.
pub webhook_registry: Arc<WebhookRegistry>,
```

In `AppState::init()`, add initialization:
- `SqliteWorkflowRepository::new(db_pool.clone())`
- `SqliteMessageRepository::new(db_pool.clone())`
- `MessageBus::new()`
- `WebhookRegistry::new()` (from boternity-infra::workflow)

Import the new types from boternity-core and boternity-infra. Follow the existing pattern of wrapping in Arc.

Note: The full WorkflowExecutor, TriggerManager, and CronScheduler are more complex to wire (they need other services as dependencies). Add them as separate fields if the dependency chain allows, otherwise add TODO comments for integration in Plan 13.
  </action>
  <verify>`cargo check -p boternity-api` compiles and all new fields initialized in AppState::init()</verify>
  <done>Message REST endpoints implemented, AppState holds Phase 8 repositories and message bus</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- Workflow CRUD endpoints return correct status codes
- Webhook receiver verifies auth before triggering
- Message send endpoint routes to MessageBus
- AppState initializes all Phase 8 services
</verification>

<success_criteria>
- Full REST API for workflow lifecycle (CRUD + trigger + runs + approve + cancel)
- Webhook receiver with HMAC-SHA256 and bearer token auth
- Bot-to-bot messaging REST endpoints
- AppState holds all Phase 8 services for shared access
</success_criteria>

<output>
After completion, create `.planning/phases/08-workflows-pipelines/08-09-SUMMARY.md`
</output>
