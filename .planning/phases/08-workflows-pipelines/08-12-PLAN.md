---
phase: 08-workflows-pipelines
plan: 12
type: execute
wave: 3
depends_on: ["08-03"]
files_modified:
  - packages/workflow-sdk/package.json
  - packages/workflow-sdk/tsconfig.json
  - packages/workflow-sdk/src/index.ts
  - packages/workflow-sdk/src/types.ts
  - packages/workflow-sdk/src/builder.ts
  - packages/workflow-sdk/src/cli.ts
  - packages/workflow-sdk/src/templates.ts
  - turbo.json
autonomous: true

must_haves:
  truths:
    - "TypeScript SDK defines workflows with builder pattern that generates valid YAML"
    - "Generated YAML matches the canonical WorkflowDefinition schema"
    - "SDK provides type-safe step references for DAG dependency validation"
    - "CLI tool can build .workflow.ts files to .yaml"
    - "Rust SDK uses boternity-types directly with a builder module"
  artifacts:
    - path: "packages/workflow-sdk/src/builder.ts"
      provides: "Workflow builder with typed step factory functions"
      min_lines: 100
    - path: "packages/workflow-sdk/src/types.ts"
      provides: "TypeScript types matching Rust WorkflowDefinition"
      min_lines: 80
    - path: "packages/workflow-sdk/src/cli.ts"
      provides: "CLI tool: build command to convert .workflow.ts to .yaml"
      min_lines: 40
  key_links:
    - from: "packages/workflow-sdk/src/builder.ts"
      to: "packages/workflow-sdk/src/types.ts"
      via: "builder produces WorkflowDefinition"
      pattern: "WorkflowDefinition"
    - from: "packages/workflow-sdk/src/types.ts"
      to: "crates/boternity-types/src/workflow.rs"
      via: "TypeScript types mirror Rust types"
      pattern: "StepType|StepConfig|TriggerConfig"
---

<objective>
Build the TypeScript SDK package with builder pattern for programmatic workflow definition, and a Rust builder module.

Purpose: Requirement WKFL-03. Users can define workflows programmatically in TypeScript (builder pattern that generates YAML) or Rust (using boternity-types directly). The SDK is a monorepo package.
Output: @boternity/workflow-sdk package in packages/workflow-sdk/, Rust builder helpers in boternity-types.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-workflows-pipelines/08-RESEARCH.md
@turbo.json
@crates/boternity-types/src/workflow.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: TypeScript SDK package with builder pattern</name>
  <files>packages/workflow-sdk/package.json, packages/workflow-sdk/tsconfig.json, packages/workflow-sdk/src/index.ts, packages/workflow-sdk/src/types.ts, packages/workflow-sdk/src/builder.ts, packages/workflow-sdk/src/templates.ts, turbo.json</files>
  <action>
**Create package directory** `packages/workflow-sdk/`

**Create package.json:**
```json
{
  "name": "@boternity/workflow-sdk",
  "version": "0.1.0",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "bin": {
    "boternity-workflow": "dist/cli.js"
  },
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch"
  },
  "dependencies": {
    "yaml": "^2.4.0"
  },
  "devDependencies": {
    "typescript": "^5.6.0",
    "@types/node": "^22.0.0"
  }
}
```

**Create tsconfig.json** (standard TS config targeting ES2022, moduleResolution bundler, strict mode, outDir: dist).

**Create types.ts** -- TypeScript types mirroring Rust WorkflowDefinition:
- WorkflowDefinition, StepDefinition, StepType, StepConfig (discriminated union on type field)
- TriggerConfig (discriminated union), RetryConfig, RetryStrategy
- WebhookAuth, StepUiMetadata, UiPosition
- WorkflowOwner, CodeLanguage
- WorkflowRunStatus, WorkflowStepStatus (string enums)

**Create builder.ts** -- builder pattern per research (CircleCI Config SDK model):

```typescript
export function workflow(name: string): WorkflowBuilder;

class WorkflowBuilder {
  private def: Partial<WorkflowDefinition>;

  description(desc: string): this;
  version(ver: string): this;
  concurrency(n: number): this;
  timeout(secs: number): this;

  // Trigger builders
  onManual(): this;
  onCron(schedule: string): this;
  onWebhook(path: string, auth?: WebhookAuth): this;
  onEvent(source: string, eventType: string, when?: string): this;
  onFileWatch(paths: string[], patterns?: string[]): this;

  // Step factory functions (return StepRef for typed dependency chains)
  agent(id: string, config: { bot: string; prompt: string; model?: string }): StepRef;
  skill(id: string, config: { skill: string; input?: string }): StepRef;
  code(id: string, config: { language: 'typescript' | 'wasm'; source: string }): StepRef;
  http(id: string, config: { method: string; url: string; headers?: Record<string, string>; body?: string }): StepRef;
  conditional(id: string, config: { condition: string; thenSteps: StepRef[]; elseSteps: StepRef[] }): StepRef;
  loop(id: string, config: { condition: string; maxIterations?: number; bodySteps: StepRef[] }): StepRef;
  approval(id: string, config: { prompt: string; timeout?: number }): StepRef;
  subWorkflow(id: string, config: { workflowName: string; input?: unknown }): StepRef;

  // Build final definition
  build(): WorkflowDefinition;
  toYaml(): string;
}

// StepRef for type-safe dependency tracking
class StepRef {
  readonly id: string;
  dependsOn(...parents: StepRef[]): this;
  withCondition(expr: string): this;
  withTimeout(secs: number): this;
  withRetry(config: { maxAttempts: number; strategy: 'simple' | 'llm_self_correct' }): this;
}
```

Usage example:
```typescript
const wf = workflow('daily-digest')
  .description('Gather news and generate summary')
  .onCron('0 9 * * *');

const news = wf.agent('gather-news', { bot: 'researcher', prompt: 'Find top AI news' });
const papers = wf.agent('gather-papers', { bot: 'researcher', prompt: 'Find new arxiv papers' });
const analyze = wf.agent('analyze', { bot: 'analyst', prompt: 'Analyze trends' })
  .dependsOn(news, papers)
  .withRetry({ maxAttempts: 3, strategy: 'llm_self_correct' });

console.log(wf.toYaml());
```

**Create templates.ts** with helper functions:
- `dataPipeline(name: string, botSlug: string)` -> pre-configured WorkflowBuilder
- `approvalFlow(name: string, botSlug: string)` -> pre-configured with approval gate
- `multiBotCollaboration(name: string, bots: string[])` -> parallel agent pattern

**Create index.ts** re-exporting all public types and builder function.

**Update turbo.json** to include `packages/workflow-sdk` in the build pipeline.

Run `cd packages/workflow-sdk && pnpm install && pnpm build` to verify.
  </action>
  <verify>`cd packages/workflow-sdk && pnpm build` compiles and produces dist/ with .js and .d.ts files</verify>
  <done>TypeScript SDK with builder pattern generates valid YAML matching Rust WorkflowDefinition schema</done>
</task>

<task type="auto">
  <name>Task 2: SDK CLI tool and Rust builder helpers</name>
  <files>packages/workflow-sdk/src/cli.ts, crates/boternity-types/src/workflow.rs</files>
  <action>
**Create CLI tool** `packages/workflow-sdk/src/cli.ts`:

Simple CLI that reads .workflow.ts files and outputs .yaml:

```typescript
#!/usr/bin/env node
import { readFileSync, writeFileSync } from 'fs';
import { resolve, basename } from 'path';

const args = process.argv.slice(2);
const command = args[0];

if (command === 'build') {
  const inputFile = args[1];
  if (!inputFile) {
    console.error('Usage: boternity-workflow build <file.workflow.ts>');
    process.exit(1);
  }
  // Dynamic import of the .ts file (requires tsx or ts-node runtime)
  // For now, support .js files directly (after user compiles with tsc)
  const outputFile = args[2] || inputFile.replace(/\.(workflow\.)?(ts|js)$/, '.yaml');

  // Import the workflow module
  const mod = await import(resolve(inputFile));
  const def = mod.default ?? mod.workflow;

  if (!def || typeof def.toYaml !== 'function') {
    console.error('Workflow file must export a WorkflowBuilder (default export or named "workflow")');
    process.exit(1);
  }

  const yaml = def.toYaml();
  writeFileSync(outputFile, yaml, 'utf8');
  console.log(`Workflow written to ${outputFile}`);
} else if (command === 'validate') {
  const inputFile = args[1];
  // Read YAML, parse, validate structure
  const yaml = readFileSync(resolve(inputFile), 'utf8');
  // Basic validation: parse YAML, check required fields
  console.log('Validation passed');
} else {
  console.log('Usage: boternity-workflow <build|validate> <file>');
}
```

Add `"#!/usr/bin/env node"` shebang handling in tsconfig or build script.

**Add Rust builder helpers** to `crates/boternity-types/src/workflow.rs`:

Add builder methods to WorkflowDefinition:

```rust
impl WorkflowDefinition {
    pub fn builder(name: impl Into<String>) -> WorkflowDefinitionBuilder {
        WorkflowDefinitionBuilder::new(name)
    }
}

pub struct WorkflowDefinitionBuilder {
    def: WorkflowDefinition,
}

impl WorkflowDefinitionBuilder {
    pub fn new(name: impl Into<String>) -> Self { ... }
    pub fn description(mut self, desc: impl Into<String>) -> Self { ... }
    pub fn version(mut self, ver: impl Into<String>) -> Self { ... }
    pub fn concurrency(mut self, n: u32) -> Self { ... }
    pub fn timeout(mut self, secs: u64) -> Self { ... }
    pub fn trigger(mut self, trigger: TriggerConfig) -> Self { ... }
    pub fn step(mut self, step: StepDefinition) -> Self { ... }
    pub fn build(self) -> WorkflowDefinition { self.def }
}

impl StepDefinition {
    pub fn agent(id: impl Into<String>, bot: impl Into<String>, prompt: impl Into<String>) -> Self { ... }
    pub fn skill(id: impl Into<String>, skill_name: impl Into<String>) -> Self { ... }
    pub fn http(id: impl Into<String>, method: impl Into<String>, url: impl Into<String>) -> Self { ... }
    pub fn depends_on(mut self, deps: &[&str]) -> Self { ... }
    pub fn with_timeout(mut self, secs: u64) -> Self { ... }
    pub fn with_retry(mut self, config: RetryConfig) -> Self { ... }
}
```

These are convenience constructors for Rust users building workflows programmatically. Users construct WorkflowDefinition structs and serialize to YAML via serde_yaml_ng.

Include tests:
- Rust builder produces valid WorkflowDefinition that serializes to YAML
- StepDefinition::agent creates correct StepConfig::Agent variant
  </action>
  <verify>`cargo test -p boternity-types -- workflow::builder` and `cd packages/workflow-sdk && pnpm build` both pass</verify>
  <done>TypeScript CLI builds .workflow.ts to .yaml, Rust builder helpers provide ergonomic workflow construction</done>
</task>

</tasks>

<verification>
- TypeScript SDK compiles and exports all types
- Builder pattern generates valid YAML
- CLI tool converts .workflow.ts to .yaml
- Rust builder helpers produce correct WorkflowDefinition
- Generated YAML matches canonical schema
</verification>

<success_criteria>
- WKFL-03: TypeScript SDK with builder pattern for programmatic workflow definition
- WKFL-04 (partial): SDK generates YAML interchangeable with visual/YAML representations
- Rust builder helpers in boternity-types for programmatic Rust workflow definition
- CLI tool for .workflow.ts -> .yaml conversion
</success_criteria>

<output>
After completion, create `.planning/phases/08-workflows-pipelines/08-12-SUMMARY.md`
</output>
