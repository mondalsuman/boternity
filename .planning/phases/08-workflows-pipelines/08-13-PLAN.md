---
phase: 08-workflows-pipelines
plan: 13
type: execute
wave: 8
depends_on: ["08-09", "08-11"]
files_modified:
  - apps/web/src/components/workflow/ExecutionOverlay.tsx
  - apps/web/src/hooks/use-workflow-events.ts
  - apps/web/src/components/workflow/WorkflowCanvas.tsx
  - apps/web/src/routes/workflows/builder/$workflowId.tsx
  - crates/boternity-api/src/http/handlers/ws.rs
  - crates/boternity-types/src/event.rs
  - crates/boternity-core/src/workflow/executor.rs
  - crates/boternity-api/src/state.rs
autonomous: true

must_haves:
  truths:
    - "Nodes light up green/yellow/red during live workflow execution"
    - "Connection lines animate data flow between steps via WebSocket"
    - "Workflow lifecycle events are published to EventBus and forwarded to WebSocket"
    - "Step runners wire into real services (agent execution, skill execution) via AppState"
    - "Crash recovery detects and resumes interrupted workflow runs on startup"
  artifacts:
    - path: "apps/web/src/components/workflow/ExecutionOverlay.tsx"
      provides: "Live execution visualization layer on React Flow canvas"
      min_lines: 60
    - path: "apps/web/src/hooks/use-workflow-events.ts"
      provides: "WebSocket hook for workflow execution events"
      min_lines: 40
    - path: "crates/boternity-types/src/event.rs"
      provides: "WorkflowEvent variants added to event system"
      min_lines: 20
  key_links:
    - from: "apps/web/src/components/workflow/ExecutionOverlay.tsx"
      to: "apps/web/src/hooks/use-workflow-events.ts"
      via: "WorkflowEvent subscription drives node status updates"
      pattern: "useWorkflowEvents|WorkflowEvent"
    - from: "crates/boternity-core/src/workflow/executor.rs"
      to: "crates/boternity-core/src/event/bus.rs"
      via: "EventBus.publish for workflow lifecycle events"
      pattern: "event_bus.*publish|WorkflowEvent"
    - from: "crates/boternity-api/src/http/handlers/ws.rs"
      to: "crates/boternity-types/src/event.rs"
      via: "WorkflowEvent forwarded to WebSocket clients"
      pattern: "WorkflowEvent|workflow_"
---

<objective>
Wire live execution visualization, add workflow events to the event bus, connect step runners to real services, and implement crash recovery on startup.

Purpose: This is the integration plan that connects all Phase 8 pieces. Live execution visualization makes workflows observable. Step runners need real service connections. Crash recovery ensures durability.
Output: Live execution overlay, workflow events, service wiring, crash recovery.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-workflows-pipelines/08-RESEARCH.md
@crates/boternity-types/src/event.rs
@crates/boternity-api/src/http/handlers/ws.rs
@crates/boternity-core/src/workflow/executor.rs
@crates/boternity-core/src/workflow/step_runner.rs
@crates/boternity-api/src/state.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Workflow events, service wiring, and crash recovery</name>
  <files>crates/boternity-types/src/event.rs, crates/boternity-core/src/workflow/executor.rs, crates/boternity-core/src/workflow/step_runner.rs, crates/boternity-api/src/state.rs, crates/boternity-api/src/http/handlers/ws.rs</files>
  <action>
**Add WorkflowEvent variants** to `crates/boternity-types/src/event.rs`:

Add new variants to the AgentEvent enum (or create a separate WorkflowEvent enum if separation is cleaner -- prefer extending AgentEvent for WebSocket compatibility):

```rust
// Workflow lifecycle events
WorkflowRunStarted {
    run_id: Uuid,
    workflow_name: String,
    trigger_type: String,
},
WorkflowStepStarted {
    run_id: Uuid,
    step_id: String,
    step_name: String,
    step_type: String,
},
WorkflowStepCompleted {
    run_id: Uuid,
    step_id: String,
    step_name: String,
    duration_ms: u64,
},
WorkflowStepFailed {
    run_id: Uuid,
    step_id: String,
    step_name: String,
    error: String,
    will_retry: bool,
},
WorkflowRunCompleted {
    run_id: Uuid,
    workflow_name: String,
    duration_ms: u64,
    steps_completed: u32,
},
WorkflowRunFailed {
    run_id: Uuid,
    workflow_name: String,
    error: String,
},
WorkflowRunPaused {
    run_id: Uuid,
    step_id: String,
    reason: String,
},
```

Update the `agent_id()` method to return None for workflow events.

**Wire executor to publish events**: Update `DagExecutor.execute()` to publish:
- WorkflowRunStarted when run begins
- WorkflowStepStarted before each step
- WorkflowStepCompleted/Failed after each step
- WorkflowRunCompleted/Failed at end
- WorkflowRunPaused when approval gate hit

**Wire step runners to real services**: Update step_runner.rs:
- Add `AppStateRef` (or specific service references) to ExecutorDeps so step runners can call:
  - Agent step: create_single_provider() + AgentEngine for LLM calls
  - Skill step: SkillExecutor for skill invocation
  - These are references passed through ExecutorDeps, not direct AppState dependency (core cannot depend on api)
- Define a `StepExecutionContext` trait in boternity-core that the API layer implements:
  ```rust
  pub trait StepExecutionContext: Send + Sync {
      fn execute_agent_step(&self, bot_slug: &str, prompt: &str, model: Option<&str>) -> impl Future<Output = Result<String, WorkflowError>>;
      fn execute_skill_step(&self, skill_name: &str, input: &str) -> impl Future<Output = Result<String, WorkflowError>>;
      fn send_bot_message(&self, from_bot_id: Uuid, message: BotMessage) -> impl Future<Output = Result<Option<BotMessage>, WorkflowError>>;
  }
  ```
- Implement this trait in boternity-api (where AppState lives) and pass to executor
- Bot-to-bot message processing (via MessageHandler) MUST create chat sessions with `session_type = 'bot-to-bot'` and `peer_bot_id` set per locked user decision. When a bot processes an incoming message via LLM, the exchange is persisted in a dedicated bot-to-bot session tagged accordingly.

**Add crash recovery to AppState::init()**: After all services initialized:
```rust
// Resume crashed workflow runs
let crashed_runs = workflow_repo.list_crashed_runs().await?;
for run in crashed_runs {
    tracing::warn!(run_id = %run.id, workflow = %run.workflow_name, "Resuming crashed workflow run");
    // Mark as Crashed (not Running) so user can see it was interrupted
    workflow_repo.update_run_status(&run.id, WorkflowRunStatus::Crashed, Some("Server restart"), None).await?;
    // Optionally auto-resume: executor.resume(&run.id).await
    // For v1: just mark as Crashed and log. User can manually resume via CLI/API.
}
```

**Update WebSocket handler** (`ws.rs`) to forward WorkflowEvent variants to connected clients (same pattern as AgentEvent forwarding).

**Wire TriggerManager and CronScheduler** into AppState startup:
- On startup: discover_workflows() for all bot-scoped and global workflows
- Register each with TriggerManager
- Start CronScheduler
- Check for missed cron runs and execute catch-up
- Add shutdown hook to stop scheduler gracefully
  </action>
  <verify>`cargo check --workspace` compiles, workflow events serialize correctly</verify>
  <done>Workflow events flow through EventBus to WebSocket, step runners call real services, crash recovery on startup</done>
</task>

<task type="auto">
  <name>Task 2: Live execution visualization on React Flow canvas</name>
  <files>apps/web/src/components/workflow/ExecutionOverlay.tsx, apps/web/src/hooks/use-workflow-events.ts, apps/web/src/components/workflow/WorkflowCanvas.tsx, apps/web/src/routes/workflows/builder/$workflowId.tsx</files>
  <action>
**Create WebSocket hook** `apps/web/src/hooks/use-workflow-events.ts`:
- Reuse existing WebSocket infrastructure from Phase 5 (useWebSocket hook)
- Filter events by `run_id` to only show events for the current workflow run
- Parse WorkflowEvent variants from the WebSocket message stream
- Expose: currentRunId, stepStatuses: Map<string, StepStatus>, isRunning

```typescript
interface StepStatus {
  status: 'pending' | 'running' | 'completed' | 'failed';
  startedAt?: number;
  completedAt?: number;
  error?: string;
}

export function useWorkflowEvents(runId?: string) {
  const [stepStatuses, setStepStatuses] = useState<Map<string, StepStatus>>(new Map());

  // Subscribe to WebSocket events
  // On WorkflowStepStarted: update step status to 'running'
  // On WorkflowStepCompleted: update to 'completed'
  // On WorkflowStepFailed: update to 'failed'
  // On WorkflowRunCompleted/Failed: mark run done

  return { stepStatuses, isRunning: !!runId };
}
```

**Create ExecutionOverlay** `apps/web/src/components/workflow/ExecutionOverlay.tsx`:
- Renders ON TOP of the canvas (absolute positioning, pointer-events: none)
- Reads step statuses from useWorkflowEvents hook
- For each node, applies CSS class based on status:
  - pending: no special styling
  - running: `animate-pulse bg-yellow-500/20` border glow
  - completed: `bg-green-500/20` border, checkmark icon overlay
  - failed: `bg-red-500/20` border, X icon overlay
- For edges between completed steps: animated dashed line (CSS @keyframes)
- Uses React Flow's `useNodes()` and `useEdges()` to access current graph state

Alternative approach (simpler): instead of a separate overlay component, update node data directly:
- When workflow events arrive, update node.data.status for each affected node
- Custom nodes already handle status-based styling (from Plan 10)
- This approach is simpler and more React-Flow-native

Go with the data-update approach:
- useWorkflowEvents updates node data via setNodes() functional updater
- Each custom node component already renders status colors from data.status

**Update builder page** to support live execution:
- "Run Workflow" button triggers workflow execution via POST /api/v1/workflows/:id/trigger
- Sets runId which activates useWorkflowEvents
- Shows execution progress bar at bottom
- "Cancel" button during execution
- After completion: show summary (steps completed, duration, errors)

**Update WorkflowCanvas** to support status-driven edge animation:
- When edge source node is completed and target node is running, apply animated edge class
- Edge animation: CSS keyframes `dash` animation on stroke-dasharray
- TypedEdge component checks source/target node statuses for animation state

Wire "Test Step" button: sends selected node's config to a new endpoint `POST /api/v1/workflows/:id/test-step` that runs a single step in isolation and returns the result. Display result in a toast or inline below the node.
  </action>
  <verify>`cd apps/web && pnpm build` compiles, execution overlay renders on canvas</verify>
  <done>Live execution visualization shows node status (green/yellow/red) and animated edges via WebSocket</done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles
- `cd apps/web && pnpm build` compiles
- Workflow events published to EventBus during execution
- WebSocket clients receive workflow lifecycle events
- Canvas nodes update color during live execution
- Edges animate when data flows between steps
- Crash recovery marks interrupted runs on startup
- Step runners can invoke agent and skill services
</verification>

<success_criteria>
- Live execution visualization: nodes light up green/yellow/red, edges animate
- All workflow lifecycle events published through EventBus -> WebSocket
- Step runners wired to real services (agent LLM calls, skill execution)
- Crash recovery detects interrupted runs on startup
- Trigger system starts on server boot (cron, event listeners, file watchers)
- Single-step testing from builder UI
</success_criteria>

<output>
After completion, create `.planning/phases/08-workflows-pipelines/08-13-SUMMARY.md`
</output>
