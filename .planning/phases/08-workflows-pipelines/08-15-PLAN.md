---
phase: 08-workflows-pipelines
plan: 15
type: execute
wave: 2
depends_on: ["08-14"]
files_modified:
  - crates/boternity-api/src/state.rs
  - crates/boternity-core/src/workflow/scheduler.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Cron-scheduled workflows execute automatically when their cron expression fires"
    - "Event-driven workflows execute when matching EventBus events occur"
    - "All three trigger types (manual, cron, event) produce Running workflow runs that complete"
  artifacts:
    - path: "crates/boternity-api/src/state.rs"
      provides: "CronScheduler started with executor callbacks, EventBus listener for workflow triggers"
      contains: "cron_scheduler"
    - path: "crates/boternity-core/src/workflow/scheduler.rs"
      provides: "CronScheduler already exists with schedule_workflow taking CronCallback"
  key_links:
    - from: "CronScheduler callback"
      to: "DagExecutor.execute()"
      via: "CronCallback closure loading definition and calling executor"
      pattern: "executor.*execute"
    - from: "EventBus subscriber"
      to: "DagExecutor.execute()"
      via: "tokio::spawn matching event type against registered triggers"
      pattern: "event_bus.*subscribe"
---

<objective>
Wire CronScheduler and EventBus listener to call DagExecutor.execute() so that cron-scheduled and event-driven workflows actually execute instead of sitting idle.

Purpose: Close the trigger gap -- CronScheduler, WebhookRegistry, and EventBus all exist but none call the executor. Plan 08-14 wired manual and webhook triggers. This plan wires cron and event triggers, completing all three trigger types. Webhook triggers were already wired in 08-14 (receive_webhook spawns executor).

Output: CronScheduler started at AppState::init() with workflow definitions loaded, executing workflows on schedule. EventBus listener matching registered event triggers and spawning workflow execution.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-workflows-pipelines/08-VERIFICATION.md
@.planning/phases/08-workflows-pipelines/08-07-SUMMARY.md
@.planning/phases/08-workflows-pipelines/08-14-SUMMARY.md

Key existing code to reference:
@crates/boternity-core/src/workflow/scheduler.rs - CronScheduler with schedule_workflow(workflow_id, schedule, CronCallback)
@crates/boternity-core/src/workflow/trigger.rs - TriggerManager with get_cron_triggers, get_event_triggers, evaluate_when_clause
@crates/boternity-core/src/workflow/executor.rs - DagExecutor (now on AppState after 08-14)
@crates/boternity-core/src/event/bus.rs - EventBus with subscribe() returning broadcast::Receiver
@crates/boternity-api/src/state.rs - AppState (after 08-14 adds workflow_executor)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Start CronScheduler with executor callbacks at AppState init</name>
  <files>
    crates/boternity-api/src/state.rs
  </files>
  <action>
    **Add CronScheduler and TriggerManager to AppState:**
    1. Add imports: `use boternity_core::workflow::scheduler::{CronScheduler, CronCallback};` and `use boternity_core::workflow::trigger::TriggerManager;`
    2. Add fields to AppState struct:
       - `pub cron_scheduler: Arc<CronScheduler>`
       - `pub trigger_manager: Arc<TriggerManager>`
    3. In AppState::init(), after creating workflow_executor:
       a. Create CronScheduler and start it:
          ```rust
          let cron_scheduler = Arc::new(CronScheduler::new());
          cron_scheduler.start().await
              .map_err(|e| anyhow::anyhow!("Failed to start cron scheduler: {e}"))?;
          ```
       b. Create TriggerManager:
          ```rust
          let trigger_manager = Arc::new(TriggerManager::new());
          ```
       c. Load all workflow definitions and register their triggers:
          ```rust
          // Register triggers for all existing workflow definitions
          let all_defs = workflow_repo.list_definitions(None).await.unwrap_or_default();
          for def in &all_defs {
              // Register triggers in TriggerManager
              let _ = trigger_manager.register_workflow(def.id, &def.name, &def.triggers).await;

              // Schedule cron triggers
              for trigger in &def.triggers {
                  if let boternity_types::workflow::TriggerConfig::Cron { schedule, .. } = trigger {
                      let executor = Arc::clone(&workflow_executor);
                      let wf_repo_for_cron = Arc::clone(&workflow_repo);
                      let wf_id = def.id;
                      let sched = Arc::clone(&cron_scheduler);
                      let cb: CronCallback = Arc::new(move |workflow_id, _fired_at| {
                          let exec = Arc::clone(&executor);
                          let repo = Arc::clone(&wf_repo_for_cron);
                          let sched_inner = Arc::clone(&sched);
                          Box::pin(async move {
                              // Record fire time for missed-run detection
                              sched_inner.record_fire(workflow_id).await;
                              // Load the definition and execute
                              match repo.get_definition(&workflow_id).await {
                                  Ok(Some(def)) => {
                                      match exec.execute(&def, "cron", None).await {
                                          Ok(result) => {
                                              tracing::info!(
                                                  %workflow_id,
                                                  run_id = %result.run_id,
                                                  status = ?result.status,
                                                  "cron-triggered workflow completed"
                                              );
                                          }
                                          Err(e) => {
                                              tracing::error!(
                                                  %workflow_id,
                                                  error = %e,
                                                  "cron-triggered workflow failed"
                                              );
                                          }
                                      }
                                  }
                                  Ok(None) => {
                                      tracing::warn!(%workflow_id, "cron trigger: workflow definition not found");
                                  }
                                  Err(e) => {
                                      tracing::error!(%workflow_id, error = %e, "cron trigger: failed to load definition");
                                  }
                              }
                          })
                      });
                      if let Err(e) = cron_scheduler.schedule_workflow(wf_id, schedule, cb).await {
                          tracing::warn!(
                              workflow_id = %def.id,
                              schedule = %schedule,
                              error = %e,
                              "failed to schedule cron trigger"
                          );
                      }
                  }
              }
          }

          if !all_defs.is_empty() {
              tracing::info!(
                  workflows = all_defs.len(),
                  cron_count = cron_scheduler.workflow_count().await,
                  "loaded workflow trigger registrations"
              );
          }
          ```
    4. Add cron_scheduler and trigger_manager to the Ok(Self { ... }) return
    5. Note: The DagExecutor uses RPITIT (not object-safe), so we can't use `Arc<dyn WorkflowExecutor>`. DagExecutor is generic over R: WorkflowRepository. On AppState it's `Arc<DagExecutor<SqliteWorkflowRepository>>`. The CronCallback needs to call executor.execute() which requires &self and &WorkflowDefinition. Since DagExecutor implements WorkflowExecutor, and the method returns impl Future, we need to ensure the closure can call it. Since DagExecutor is behind Arc, and execute() takes &self, this works: `exec.execute(&def, "cron", None).await`.
  </action>
  <verify>
    `cargo check -p boternity-api` compiles cleanly.
    Grep for `cron_scheduler` in state.rs to confirm field exists.
    Grep for `trigger_manager` in state.rs to confirm field exists.
    Grep for `schedule_workflow` in state.rs to confirm cron triggers are registered.
    `cargo test -p boternity-core -- workflow::scheduler` -- existing scheduler tests pass.
  </verify>
  <done>
    CronScheduler is started at AppState::init(), all workflow definitions have their cron triggers registered with callbacks that call DagExecutor.execute(). TriggerManager tracks all trigger registrations for when-clause evaluation.
  </done>
</task>

<task type="auto">
  <name>Task 2: EventBus listener for event-driven workflow triggers</name>
  <files>
    crates/boternity-api/src/state.rs
  </files>
  <action>
    **Add EventBus workflow trigger listener in AppState::init():**

    After registering cron triggers (from Task 1), add an EventBus subscriber that listens for events and matches them against registered event triggers:

    1. Get event triggers from the trigger_manager:
       ```rust
       let event_triggers = trigger_manager.get_event_triggers().await;
       ```
    2. If there are event triggers, spawn a background task that subscribes to the EventBus and matches events:
       ```rust
       if !event_triggers.is_empty() {
           let mut rx = event_bus.subscribe();
           let executor_for_events = Arc::clone(&workflow_executor);
           let repo_for_events = Arc::clone(&workflow_repo);
           let tm_for_events = Arc::clone(&trigger_manager);

           tokio::spawn(async move {
               loop {
                   match rx.recv().await {
                       Ok(event) => {
                           // Get the event type string from the AgentEvent
                           let event_type = event.event_type();
                           let event_json = serde_json::to_value(&event).ok();

                           // Check all registered event triggers
                           let triggers = tm_for_events.get_event_triggers().await;
                           for (workflow_id, _source, trigger_event_type, when_clause) in &triggers {
                               if trigger_event_type != &event_type {
                                   continue;
                               }

                               // Evaluate when clause if present
                               let trigger_ctx = boternity_core::workflow::trigger::TriggerContext::new(
                                   "event",
                                   &event_type,
                                   *workflow_id,
                                   event_json.clone(),
                               );
                               match tm_for_events.evaluate_when_clause(when_clause.as_deref(), &trigger_ctx) {
                                   Ok(true) => {
                                       // Load definition and execute
                                       let exec = Arc::clone(&executor_for_events);
                                       let repo = Arc::clone(&repo_for_events);
                                       let wf_id = *workflow_id;
                                       let payload = event_json.clone();
                                       tokio::spawn(async move {
                                           match repo.get_definition(&wf_id).await {
                                               Ok(Some(def)) => {
                                                   match exec.execute(&def, "event", payload).await {
                                                       Ok(result) => {
                                                           tracing::info!(
                                                               %wf_id,
                                                               run_id = %result.run_id,
                                                               "event-triggered workflow completed"
                                                           );
                                                       }
                                                       Err(e) => {
                                                           tracing::error!(
                                                               %wf_id,
                                                               error = %e,
                                                               "event-triggered workflow failed"
                                                           );
                                                       }
                                                   }
                                               }
                                               _ => {
                                                   tracing::warn!(%wf_id, "event trigger: workflow not found");
                                               }
                                           }
                                       });
                                   }
                                   Ok(false) => {
                                       // When clause didn't match, skip
                                   }
                                   Err(e) => {
                                       tracing::warn!(
                                           %workflow_id,
                                           error = %e,
                                           "event trigger when-clause evaluation failed"
                                       );
                                   }
                               }
                           }
                       }
                       Err(tokio::sync::broadcast::error::RecvError::Lagged(n)) => {
                           tracing::warn!(skipped = n, "workflow event listener lagged, some events missed");
                       }
                       Err(tokio::sync::broadcast::error::RecvError::Closed) => {
                           tracing::info!("event bus closed, workflow event listener shutting down");
                           break;
                       }
                   }
               }
           });

           tracing::info!(
               event_triggers = event_triggers.len(),
               "started workflow event trigger listener"
           );
       }
       ```

    3. Note: AgentEvent needs an `event_type()` method that returns a string identifier. Check if this exists already. If not, add a simple method that returns the variant name as a string (e.g., "workflow_run_started", "bot_created"). If AgentEvent uses serde tagged enum with `#[serde(tag = "type", rename_all = "snake_case")]`, then the type field values are already the event type strings. Use the serde tag value for matching.

    4. If AgentEvent doesn't have event_type(), the simplest approach is to serialize the event to JSON and extract the "type" field: `serde_json::to_value(&event).ok().and_then(|v| v["type"].as_str().map(|s| s.to_string())).unwrap_or_default()`. This works because AgentEvent uses `#[serde(tag = "type")]`.

    **Check for missed cron runs (catch-up on restart):**
    After starting the cron scheduler and loading triggers, check for missed runs:
    ```rust
    // Check for missed cron runs during downtime
    let cron_triggers = trigger_manager.get_cron_triggers().await;
    if !cron_triggers.is_empty() {
        let schedules: Vec<(Uuid, String, Option<DateTime<Utc>>)> = cron_triggers
            .into_iter()
            .map(|(wf_id, schedule)| (wf_id, schedule, None)) // No last_fired baseline on fresh start
            .collect();
        let missed = cron_scheduler.check_missed_runs(&schedules);
        for (wf_id, times) in &missed {
            tracing::warn!(%wf_id, count = times.len(), "catching up missed cron runs");
            // Execute the workflow once for catch-up (not once per missed occurrence, to avoid flooding)
            if let Ok(Some(def)) = workflow_repo.get_definition(wf_id).await {
                let exec = Arc::clone(&workflow_executor);
                tokio::spawn(async move {
                    let _ = exec.execute(&def, "cron_catchup", None).await;
                });
            }
        }
    }
    ```
    Note: Add `use chrono::{DateTime, Utc};` if not already imported in state.rs. Check existing imports first.
  </action>
  <verify>
    `cargo check -p boternity-api` compiles cleanly.
    Grep for `event_bus.subscribe` in state.rs to confirm EventBus listener exists.
    Grep for `event-triggered workflow` in state.rs to confirm event trigger callback exists.
    Grep for `check_missed_runs` in state.rs to confirm catch-up logic exists.
    `cargo test -p boternity-core -- workflow` -- all existing workflow tests pass.
  </verify>
  <done>
    EventBus listener spawned at startup matches incoming events against registered event triggers and executes workflows via DagExecutor.execute(). Missed cron runs are caught up on restart. All three trigger types (manual, cron, event) now actually execute workflows.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p boternity-api` -- all code compiles
2. `cargo test -p boternity-core -- workflow` -- all existing tests pass (47+ workflow tests)
3. `cargo test -p boternity-infra -- workflow` -- existing webhook/file_trigger tests pass
4. Grep `cron_scheduler.start()` in state.rs confirms scheduler starts
5. Grep `schedule_workflow` in state.rs confirms cron triggers registered with executor callback
6. Grep `event_bus.subscribe()` in state.rs confirms event listener spawned
7. Grep `executor_for_events` in state.rs confirms event triggers call executor
</verification>

<success_criteria>
- CronScheduler started at AppState::init() with all workflow cron triggers registered
- Each cron callback loads the workflow definition and calls DagExecutor.execute()
- EventBus listener spawned at startup, matching events to registered triggers
- Event triggers evaluate when-clauses and spawn executor.execute() on match
- Missed cron runs caught up on restart (single catch-up execution per workflow)
- TriggerManager on AppState for centralized trigger registration tracking
</success_criteria>

<output>
After completion, create `.planning/phases/08-workflows-pipelines/08-15-SUMMARY.md`
</output>
