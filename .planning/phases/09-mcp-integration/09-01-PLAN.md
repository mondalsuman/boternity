---
phase: 09-mcp-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/boternity-types/Cargo.toml
  - crates/boternity-types/src/mcp.rs
  - crates/boternity-types/src/lib.rs
  - crates/boternity-infra/Cargo.toml
  - crates/boternity-api/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "MCP domain types compile and are usable from all crates"
    - "rmcp and governor are available as workspace dependencies"
    - "MCP server config, connection status, audit entry, permission scope types exist"
  artifacts:
    - path: "crates/boternity-types/src/mcp.rs"
      provides: "MCP domain types"
      min_lines: 150
      contains: "McpServerConfig"
    - path: "Cargo.toml"
      provides: "Workspace dependency declarations"
      contains: "rmcp"
  key_links:
    - from: "crates/boternity-types/src/lib.rs"
      to: "crates/boternity-types/src/mcp.rs"
      via: "pub mod mcp"
      pattern: "pub mod mcp"
---

<objective>
Define MCP domain types and add Phase 9 workspace dependencies (rmcp, governor).

Purpose: Foundation types that all subsequent MCP plans depend on. Domain types live in boternity-types (zero infra deps). New crate dependencies declared in workspace Cargo.toml and wired to the crates that need them.
Output: mcp.rs with all MCP domain types, workspace Cargo.toml with rmcp + governor.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-mcp-integration/09-RESEARCH.md
@crates/boternity-types/src/lib.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Phase 9 workspace dependencies</name>
  <files>Cargo.toml, crates/boternity-types/Cargo.toml, crates/boternity-infra/Cargo.toml, crates/boternity-api/Cargo.toml</files>
  <action>
Add to workspace `[workspace.dependencies]` in root Cargo.toml:

```toml
# MCP protocol SDK (official)
rmcp = { version = "0.15", features = [
    "client",
    "server",
    "macros",
    "schemars",
    "transport-io",
    "transport-child-process",
    "transport-streamable-http-client-reqwest",
    "transport-streamable-http-server",
] }

# Rate limiting for MCP server
governor = "0.8"
```

Wire `rmcp` to boternity-infra and boternity-api Cargo.toml as workspace deps. Wire `governor` to boternity-infra Cargo.toml. The types crate does NOT depend on rmcp (it only uses serde, uuid, chrono, etc.).

Note: `schemars = "1"` and `regex = "1"` should already be in workspace. If `regex` is not, add it (needed by sanitizer in a later plan). Check if it exists first.
  </action>
  <verify>`cargo check -p boternity-infra --lib 2>&1 | head -20` compiles without rmcp import errors (dep resolution works)</verify>
  <done>rmcp and governor are declared in workspace and wired to boternity-infra and boternity-api</done>
</task>

<task type="auto">
  <name>Task 2: Define MCP domain types</name>
  <files>crates/boternity-types/src/mcp.rs, crates/boternity-types/src/lib.rs</files>
  <action>
Create `crates/boternity-types/src/mcp.rs` with the following domain types. Add `pub mod mcp;` to lib.rs.

**Transport type enum:**
```rust
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum McpTransportType {
    Stdio,
    StreamableHttp,
    Sse,
}
```

**Server config (for JSON file storage):**
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct McpServerConfig {
    pub name: String,
    pub transport: McpTransportType,
    /// For stdio: command to run
    pub command: Option<String>,
    /// For stdio: command arguments
    pub args: Vec<String>,
    /// For HTTP/SSE: server URL
    pub url: Option<String>,
    /// Key name in MCP keystore for credentials
    pub credential_key: Option<String>,
    /// Whether this server is enabled
    pub enabled: bool,
    /// Preset name (e.g., "filesystem", "github") or None for custom
    pub preset: Option<String>,
    /// Allowed tool names (empty = all allowed)
    pub allowed_tools: Vec<String>,
    /// Denied tool names (takes precedence over allowed)
    pub denied_tools: Vec<String>,
    /// Token budget for sampling requests from this server
    pub sampling_budget_tokens: Option<u64>,
}
```

**Connection status enum:**
```rust
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum McpConnectionStatus {
    Connected,
    Disconnected,
    Error,
    Connecting,
}
```

**Connection metadata (for SQLite):**
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct McpConnection {
    pub id: Uuid,
    pub server_name: String,
    pub transport_type: McpTransportType,
    pub status: McpConnectionStatus,
    pub bot_id: Option<Uuid>,
    pub connected_at: Option<DateTime<Utc>>,
    pub disconnected_at: Option<DateTime<Utc>>,
    pub last_health_ping: Option<DateTime<Utc>>,
    pub error_message: Option<String>,
    pub tool_count: i32,
    pub resource_count: i32,
    pub prompt_count: i32,
}
```

**Audit direction:**
```rust
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum McpAuditDirection {
    Client,
    Server,
}
```

**Audit entry:**
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct McpAuditEntry {
    pub id: Uuid,
    pub direction: McpAuditDirection,
    pub event_type: String,
    pub server_name: Option<String>,
    pub bot_id: Option<Uuid>,
    pub client_id: Option<String>,
    pub tool_name: Option<String>,
    pub input_hash: Option<String>,
    pub output_hash: Option<String>,
    pub duration_ms: Option<i64>,
    pub success: bool,
    pub error: Option<String>,
    pub sanitized: bool,
    pub token_usage: Option<i64>,
    pub timestamp: DateTime<Utc>,
}
```

**Tool permission scope:**
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct McpToolPermissions {
    /// Server name -> permission rules
    pub server_permissions: HashMap<String, McpServerPermissions>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct McpServerPermissions {
    pub allowed: Vec<String>,
    pub denied: Vec<String>,
}
```

**Sanitized tool info (after sanitization):**
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct McpToolInfo {
    pub name: String,
    pub description: String,
    pub server_name: String,
    pub input_schema: serde_json::Value,
    pub original_description_hash: String,
}
```

**Bot override config:**
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct McpBotOverride {
    pub additional_servers: Vec<String>,
    pub removed_servers: Vec<String>,
    pub tool_permissions: McpToolPermissions,
}
```

**Top-level config file structure:**
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct McpConfigFile {
    pub servers: HashMap<String, McpServerConfig>,
    pub bot_overrides: HashMap<String, McpBotOverride>,
}
```

**Server preset:**
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct McpServerPreset {
    pub name: String,
    pub display_name: String,
    pub description: String,
    pub transport: McpTransportType,
    pub command: Option<String>,
    pub args: Vec<String>,
    pub url: Option<String>,
    pub requires_credential: bool,
    pub credential_env_hint: Option<String>,
}
```

Use `#[serde(default)]` where appropriate for optional fields. Use `HashMap` from `std::collections`. All types derive `Debug, Clone, Serialize, Deserialize`. McpServerConfig should also impl Default with `enabled: true`.

Add impl blocks:
- `McpToolPermissions::is_allowed(server: &str, tool: &str) -> bool` -- checks allowed/denied lists, denied takes precedence, empty allowed = all allowed
- `McpServerConfig::effective_allowed_tools(permissions: &McpToolPermissions) -> Vec<String>` -- merge server config allowed/denied with override permissions
  </action>
  <verify>`cargo check -p boternity-types` compiles cleanly</verify>
  <done>All MCP domain types exist in mcp.rs, are re-exported from lib.rs, and compile</done>
</task>

</tasks>

<verification>
- `cargo check -p boternity-types` passes
- `cargo check -p boternity-infra --lib` passes (rmcp dep resolves)
- `cargo check -p boternity-api --lib` passes (rmcp dep resolves)
- mcp.rs contains McpServerConfig, McpConnection, McpAuditEntry, McpToolPermissions, McpToolInfo, McpConfigFile, McpServerPreset
</verification>

<success_criteria>
MCP domain types compile and are available from boternity-types::mcp. rmcp and governor are workspace dependencies wired to boternity-infra and boternity-api.
</success_criteria>

<output>
After completion, create `.planning/phases/09-mcp-integration/09-01-SUMMARY.md`
</output>
