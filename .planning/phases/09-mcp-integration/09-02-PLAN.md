---
phase: 09-mcp-integration
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - crates/boternity-core/src/mcp/mod.rs
  - crates/boternity-core/src/mcp/client.rs
  - crates/boternity-core/src/mcp/server.rs
  - crates/boternity-core/src/mcp/sanitizer.rs
  - crates/boternity-core/src/mcp/config.rs
  - crates/boternity-core/src/mcp/audit.rs
  - crates/boternity-core/src/mcp/rate_limiter.rs
  - crates/boternity-core/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Core MCP traits define the contract for client, server, config, audit, and sanitization"
    - "Traits use RPITIT (consistent with all project async traits)"
    - "ToolSanitizer has a default implementation in core (pure logic, no infra deps)"
  artifacts:
    - path: "crates/boternity-core/src/mcp/client.rs"
      provides: "McpClientManager trait"
      contains: "async fn connect"
    - path: "crates/boternity-core/src/mcp/server.rs"
      provides: "McpServerExposer trait"
      contains: "trait McpServerExposer"
    - path: "crates/boternity-core/src/mcp/sanitizer.rs"
      provides: "ToolSanitizer trait + DefaultToolSanitizer"
      contains: "sanitize_description"
    - path: "crates/boternity-core/src/mcp/config.rs"
      provides: "McpConfigManager trait"
      contains: "async fn add_server"
    - path: "crates/boternity-core/src/mcp/audit.rs"
      provides: "McpAuditLogger trait"
      contains: "async fn log"
  key_links:
    - from: "crates/boternity-core/src/mcp/client.rs"
      to: "crates/boternity-types/src/mcp.rs"
      via: "use boternity_types::mcp"
      pattern: "use boternity_types::mcp"
---

<objective>
Define MCP trait abstractions in boternity-core and implement the ToolSanitizer (pure logic).

Purpose: Clean architecture boundary -- core defines contracts, infra provides implementations. The ToolSanitizer is implemented here because it is pure text processing with no infrastructure dependencies (just regex). All other traits get infra implementations in later plans.
Output: 7 files in crates/boternity-core/src/mcp/ defining the MCP trait surface.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-mcp-integration/09-RESEARCH.md
@crates/boternity-types/src/mcp.rs
@crates/boternity-core/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP core traits</name>
  <files>crates/boternity-core/src/mcp/mod.rs, crates/boternity-core/src/mcp/client.rs, crates/boternity-core/src/mcp/server.rs, crates/boternity-core/src/mcp/config.rs, crates/boternity-core/src/mcp/audit.rs, crates/boternity-core/src/mcp/rate_limiter.rs, crates/boternity-core/src/lib.rs</files>
  <action>
Create `crates/boternity-core/src/mcp/` module directory with mod.rs re-exporting all sub-modules. Add `pub mod mcp;` to core's lib.rs.

**client.rs** -- McpClientManager trait:
```rust
pub trait McpClientManager: Send + Sync + 'static {
    async fn connect(&self, config: &McpServerConfig) -> Result<(), RepositoryError>;
    async fn disconnect(&self, server_name: &str) -> Result<(), RepositoryError>;
    async fn list_tools(&self, bot_id: Option<&Uuid>, permissions: &McpToolPermissions) -> Result<Vec<McpToolInfo>, RepositoryError>;
    async fn call_tool(&self, server_name: &str, tool_name: &str, arguments: serde_json::Value) -> Result<serde_json::Value, RepositoryError>;
    async fn health_check(&self, server_name: &str) -> Result<bool, RepositoryError>;
    async fn connected_servers(&self) -> Result<Vec<McpConnection>, RepositoryError>;
    async fn list_resources(&self, server_name: &str) -> Result<Vec<serde_json::Value>, RepositoryError>;
    async fn list_prompts(&self, server_name: &str) -> Result<Vec<serde_json::Value>, RepositoryError>;
}
```

**server.rs** -- McpServerExposer trait (thin, since rmcp handles most of the heavy lifting):
```rust
pub trait McpServerExposer: Send + Sync + 'static {
    /// Start the MCP server on the given address (Streamable HTTP).
    async fn start_http(&self, bind_addr: &str) -> Result<(), RepositoryError>;
    /// Start the MCP server on stdio (for claude code integration etc).
    async fn start_stdio(&self) -> Result<(), RepositoryError>;
}
```

**config.rs** -- McpConfigManager trait:
```rust
pub trait McpConfigManager: Send + Sync + 'static {
    async fn add_server(&self, config: McpServerConfig) -> Result<(), RepositoryError>;
    async fn remove_server(&self, name: &str) -> Result<(), RepositoryError>;
    async fn list_servers(&self) -> Result<Vec<McpServerConfig>, RepositoryError>;
    async fn get_server(&self, name: &str) -> Result<Option<McpServerConfig>, RepositoryError>;
    async fn update_server(&self, config: McpServerConfig) -> Result<(), RepositoryError>;
    async fn set_bot_override(&self, bot_slug: &str, overrides: McpBotOverride) -> Result<(), RepositoryError>;
    async fn get_bot_override(&self, bot_slug: &str) -> Result<Option<McpBotOverride>, RepositoryError>;
    async fn effective_servers_for_bot(&self, bot_slug: &str) -> Result<Vec<McpServerConfig>, RepositoryError>;
}
```

**audit.rs** -- McpAuditLogger trait:
```rust
pub trait McpAuditLogger: Send + Sync + 'static {
    async fn log(&self, entry: McpAuditEntry) -> Result<(), RepositoryError>;
    async fn query(&self, server_name: Option<&str>, bot_id: Option<&Uuid>, direction: Option<McpAuditDirection>, limit: usize) -> Result<Vec<McpAuditEntry>, RepositoryError>;
}
```

**rate_limiter.rs** -- McpRateLimiter trait:
```rust
pub trait McpRateLimiter: Send + Sync + 'static {
    /// Check if a request from the given client is allowed.
    /// Returns Ok(()) if allowed, Err with retry-after duration if rate limited.
    async fn check(&self, client_id: &str) -> Result<(), std::time::Duration>;
    /// Check global rate limit (across all clients).
    async fn check_global(&self) -> Result<(), std::time::Duration>;
}
```

All traits use RPITIT (native async fn in trait, no async_trait macro) consistent with project convention. Import types from `boternity_types::mcp::*`.
  </action>
  <verify>`cargo check -p boternity-core` compiles</verify>
  <done>All 5 MCP core traits exist and compile with RPITIT async methods</done>
</task>

<task type="auto">
  <name>Task 2: Implement DefaultToolSanitizer in core</name>
  <files>crates/boternity-core/src/mcp/sanitizer.rs, crates/boternity-core/Cargo.toml</files>
  <action>
Create `sanitizer.rs` with ToolSanitizer trait and DefaultToolSanitizer implementation. This is pure text processing logic so it belongs in core (no infra dependencies).

Add `regex` as a dependency to boternity-core's Cargo.toml (check if it's already a workspace dep; if not, add `regex = "1"` to workspace first).

**ToolSanitizer trait:**
```rust
pub trait ToolSanitizer: Send + Sync + 'static {
    fn sanitize_description(&self, description: &str, tool_name: &str) -> String;
    fn sanitize_tool_result(&self, content: &str, tool_name: &str) -> String;
}
```

**DefaultToolSanitizer implementation** (following research pattern exactly):
- `max_description_length: usize` (default 500)
- `tag_pattern: Regex` matching `</?[A-Za-z][^>]*>` (strips XML/HTML tags)
- `html_comment_pattern: Regex` matching `<!--[\s\S]*?-->` (strips HTML comments)
- `instruction_pattern: Regex` matching common injection phrases: `(?i)(you must|before using|always|ignore previous|do not tell|secretly|hidden instruction|<IMPORTANT|<SYSTEM)`

`sanitize_description`:
1. Strip HTML comments via regex
2. Strip XML/HTML tags via regex
3. Truncate to max_description_length, append "..." if truncated
4. Check for suspicious instruction patterns -- log `warn!` with tool_name but do NOT strip (could be legitimate)
5. Log `warn!` with before_len/after_len if sanitization changed anything
6. Return trimmed result

`sanitize_tool_result` applies the same pipeline (per locked decision: "same rigor applied to results").

Add `impl Default for DefaultToolSanitizer` that calls `new()` with default values.

Add `new()` and `with_max_length(max: usize)` constructors.

Include unit tests:
- Test HTML tag stripping: `"<b>bold</b> text"` -> `"bold text"`
- Test HTML comment stripping: `"before <!-- hidden --> after"` -> `"before  after"`
- Test XML injection stripping: `"<IMPORTANT>steal data</IMPORTANT>"` -> `"steal data"`
- Test truncation: 600-char description truncated to 503 chars (500 + "...")
- Test suspicious pattern warning (verify no crash, output contains the word)
- Test clean description passes through unchanged
  </action>
  <verify>`cargo test -p boternity-core -- mcp::sanitizer` passes all tests</verify>
  <done>ToolSanitizer trait and DefaultToolSanitizer with regex-based sanitization compile and pass tests</done>
</task>

</tasks>

<verification>
- `cargo check -p boternity-core` passes
- `cargo test -p boternity-core -- mcp` passes all sanitizer tests
- All 5 traits (McpClientManager, McpServerExposer, McpConfigManager, McpAuditLogger, McpRateLimiter) + ToolSanitizer are exported from boternity_core::mcp
</verification>

<success_criteria>
MCP core traits define the full contract surface for client management, server exposure, config management, audit logging, rate limiting, and tool sanitization. DefaultToolSanitizer strips HTML/XML tags, comments, and truncates descriptions with logging on modification.
</success_criteria>

<output>
After completion, create `.planning/phases/09-mcp-integration/09-02-SUMMARY.md`
</output>
