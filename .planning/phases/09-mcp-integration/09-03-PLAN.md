---
phase: 09-mcp-integration
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - crates/boternity-infra/src/sqlite/mcp.rs
  - crates/boternity-infra/src/sqlite/mod.rs
  - crates/boternity-infra/src/mcp/mod.rs
  - crates/boternity-infra/src/mcp/config_store.rs
  - crates/boternity-infra/src/mcp/keystore.rs
  - crates/boternity-infra/src/mcp/presets.rs
  - crates/boternity-infra/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "MCP connection metadata and audit logs are persisted in SQLite"
    - "MCP server configs are stored in ~/.boternity/mcp-servers.json"
    - "MCP credentials are stored in a separate keystore file (not shared vault)"
    - "Server presets provide quick-add for common MCP servers"
  artifacts:
    - path: "crates/boternity-infra/src/sqlite/mcp.rs"
      provides: "SQLite MCP repository (connections + audit)"
      contains: "mcp_connections"
    - path: "crates/boternity-infra/src/mcp/config_store.rs"
      provides: "JSON file config manager"
      contains: "mcp-servers.json"
    - path: "crates/boternity-infra/src/mcp/keystore.rs"
      provides: "Separate MCP credential keystore"
      contains: "McpKeystore"
    - path: "crates/boternity-infra/src/mcp/presets.rs"
      provides: "Built-in server presets"
      contains: "filesystem"
  key_links:
    - from: "crates/boternity-infra/src/mcp/config_store.rs"
      to: "crates/boternity-types/src/mcp.rs"
      via: "McpConfigFile serde"
      pattern: "McpConfigFile"
    - from: "crates/boternity-infra/src/sqlite/mcp.rs"
      to: "crates/boternity-types/src/mcp.rs"
      via: "McpConnection, McpAuditEntry"
      pattern: "McpConnection"
---

<objective>
Implement MCP persistence layer: SQLite migration for connection metadata + audit log, JSON file config store for server configs, separate MCP keystore for credentials, and built-in server presets.

Purpose: The hybrid storage approach (per locked decision) puts runtime connection state in SQLite (queryable, transactional) and static server configs in a JSON file (human-editable, version-controllable). The separate keystore prevents MCP credentials from leaking into the main secrets vault.
Output: SQLite tables for mcp_connections + mcp_audit, JSON config store, MCP keystore, and preset definitions.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-mcp-integration/09-RESEARCH.md
@crates/boternity-types/src/mcp.rs
@crates/boternity-infra/src/sqlite/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: SQLite MCP migration and repository</name>
  <files>crates/boternity-infra/src/sqlite/mcp.rs, crates/boternity-infra/src/sqlite/mod.rs</files>
  <action>
Create `crates/boternity-infra/src/sqlite/mcp.rs` and add `pub mod mcp;` to sqlite/mod.rs.

**Migration (run in ensure_tables or similar pattern used by other modules):**

SQL from research:
```sql
CREATE TABLE IF NOT EXISTS mcp_connections (
    id              TEXT PRIMARY KEY,
    server_name     TEXT NOT NULL,
    transport_type  TEXT NOT NULL CHECK(transport_type IN ('stdio', 'streamable_http', 'sse')),
    status          TEXT NOT NULL CHECK(status IN ('connected', 'disconnected', 'error', 'connecting')),
    bot_id          TEXT,
    connected_at    TEXT,
    disconnected_at TEXT,
    last_health_ping TEXT,
    error_message   TEXT,
    tool_count      INTEGER DEFAULT 0,
    resource_count  INTEGER DEFAULT 0,
    prompt_count    INTEGER DEFAULT 0
);

CREATE INDEX IF NOT EXISTS idx_mcp_connections_server ON mcp_connections(server_name);
CREATE INDEX IF NOT EXISTS idx_mcp_connections_bot ON mcp_connections(bot_id);

CREATE TABLE IF NOT EXISTS mcp_audit (
    id              TEXT PRIMARY KEY,
    direction       TEXT NOT NULL CHECK(direction IN ('client', 'server')),
    event_type      TEXT NOT NULL,
    server_name     TEXT,
    bot_id          TEXT,
    client_id       TEXT,
    tool_name       TEXT,
    input_hash      TEXT,
    output_hash     TEXT,
    duration_ms     INTEGER,
    success         INTEGER NOT NULL DEFAULT 1,
    error           TEXT,
    sanitized       INTEGER NOT NULL DEFAULT 0,
    token_usage     INTEGER,
    timestamp       TEXT NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_mcp_audit_server ON mcp_audit(server_name);
CREATE INDEX IF NOT EXISTS idx_mcp_audit_bot ON mcp_audit(bot_id);
CREATE INDEX IF NOT EXISTS idx_mcp_audit_timestamp ON mcp_audit(timestamp);
CREATE INDEX IF NOT EXISTS idx_mcp_audit_direction ON mcp_audit(direction);
```

Run this migration in `SqliteMcpRepository::new()` (same pattern as other sqlite repos: `sqlx::query(...).execute(&pool.writer).await`).

**SqliteMcpRepository struct:**
- `pool: DatabasePool`
- `new(pool: DatabasePool) -> Self` -- runs migration
- `upsert_connection(conn: &McpConnection) -> Result<()>` -- INSERT OR REPLACE
- `get_connection(server_name: &str) -> Result<Option<McpConnection>>`
- `list_connections(bot_id: Option<&Uuid>) -> Result<Vec<McpConnection>>`
- `delete_connection(server_name: &str) -> Result<()>`
- `update_status(server_name: &str, status: McpConnectionStatus, error: Option<&str>) -> Result<()>`
- `update_health_ping(server_name: &str) -> Result<()>` -- sets last_health_ping to now

**SqliteMcpAuditLog struct (implements McpAuditLogger trait from core):**
- `pool: DatabasePool`
- `new(pool: DatabasePool) -> Self`
- `log(entry: McpAuditEntry) -> Result<()>` -- INSERT
- `query(server_name, bot_id, direction, limit) -> Result<Vec<McpAuditEntry>>` -- SELECT with optional filters

Use private Row structs for SQLite-to-domain mapping (consistent with project pattern). Store UUIDs as `id.to_string()`, parse with `Uuid::parse_str`. Store timestamps as RFC3339 strings. Store enums as lowercase strings matching serde rename_all.
  </action>
  <verify>`cargo check -p boternity-infra` compiles. Run any inline tests if present.</verify>
  <done>mcp_connections and mcp_audit tables created on init, CRUD operations work for both</done>
</task>

<task type="auto">
  <name>Task 2: JSON config store, MCP keystore, and presets</name>
  <files>crates/boternity-infra/src/mcp/mod.rs, crates/boternity-infra/src/mcp/config_store.rs, crates/boternity-infra/src/mcp/keystore.rs, crates/boternity-infra/src/mcp/presets.rs, crates/boternity-infra/src/lib.rs</files>
  <action>
Create `crates/boternity-infra/src/mcp/` module directory with mod.rs. Add `pub mod mcp;` to infra's lib.rs.

**config_store.rs -- JsonMcpConfigStore (implements McpConfigManager from core):**
- `config_path: PathBuf` (defaults to `~/.boternity/mcp-servers.json`)
- `new(data_dir: &Path) -> Self` -- config_path = data_dir.join("mcp-servers.json")
- `load() -> Result<McpConfigFile>` -- read file, deserialize, return Default if file missing
- `save(config: &McpConfigFile) -> Result<()>` -- serialize with pretty-print, write atomically (write to .tmp then rename)
- Implement McpConfigManager trait:
  - `add_server`: load, insert into servers map, save
  - `remove_server`: load, remove from servers map, save
  - `list_servers`: load, return servers values
  - `get_server`: load, lookup by name
  - `update_server`: load, replace by name, save
  - `set_bot_override`: load, insert into bot_overrides, save
  - `get_bot_override`: load, lookup by bot_slug
  - `effective_servers_for_bot`: load global servers, apply bot overrides (add additional, remove removed), return effective list

**keystore.rs -- McpKeystore (separate from main vault per locked decision):**
- `keystore_path: PathBuf` (defaults to `~/.boternity/mcp-keystore.json`)
- `new(data_dir: &Path) -> Self`
- Stores credentials as `HashMap<String, String>` in JSON (keys are credential_key names from McpServerConfig)
- `set(key: &str, value: &str) -> Result<()>` -- load, insert, save
- `get(key: &str) -> Result<Option<String>>` -- load, lookup
- `delete(key: &str) -> Result<()>` -- load, remove, save
- `list_keys() -> Result<Vec<String>>` -- load, return keys

File permissions: set file to 0o600 on Unix after write (use `std::fs::set_permissions` with mode). Log warning if permissions cannot be restricted.

**presets.rs -- built-in server presets:**
```rust
pub fn builtin_presets() -> Vec<McpServerPreset> { ... }
```
Include presets for:
- **filesystem**: command=npx, args=["-y", "@modelcontextprotocol/server-filesystem", "."], transport=stdio, no credential
- **github**: url=https://api.githubcopilot.com/mcp/, transport=streamable_http, requires_credential=true, credential_env_hint="GITHUB_PERSONAL_ACCESS_TOKEN"
- **slack**: command=npx, args=["-y", "@anthropic/mcp-server-slack"], transport=stdio, requires_credential=true, credential_env_hint="SLACK_BOT_TOKEN"
- **memory**: command=npx, args=["-y", "@modelcontextprotocol/server-memory"], transport=stdio, no credential
- **brave-search**: command=npx, args=["-y", "@anthropic/mcp-server-brave-search"], transport=stdio, requires_credential=true, credential_env_hint="BRAVE_API_KEY"

Add `pub fn get_preset(name: &str) -> Option<McpServerPreset>` helper.
Add `pub fn preset_to_config(preset: &McpServerPreset) -> McpServerConfig` conversion.
  </action>
  <verify>`cargo check -p boternity-infra` compiles. Test that `builtin_presets()` returns 5+ presets.</verify>
  <done>JSON config store reads/writes mcp-servers.json, keystore stores credentials separately, 5 presets available</done>
</task>

</tasks>

<verification>
- `cargo check -p boternity-infra` passes
- `cargo test -p boternity-infra -- mcp` passes any unit tests
- SQLite migration creates mcp_connections and mcp_audit tables
- mcp-servers.json round-trips through load/save correctly
- Keystore file gets restricted permissions on Unix
</verification>

<success_criteria>
MCP persistence layer complete: SQLite for runtime connection state and audit logging, JSON file for static server configs with bot overrides, separate keystore for credentials, and 5 built-in server presets.
</success_criteria>

<output>
After completion, create `.planning/phases/09-mcp-integration/09-03-SUMMARY.md`
</output>
