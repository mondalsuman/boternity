---
phase: 09-mcp-integration
plan: 04
type: execute
wave: 3
depends_on: ["09-01", "09-02", "09-03"]
files_modified:
  - crates/boternity-infra/src/mcp/client_manager.rs
  - crates/boternity-infra/src/mcp/transport.rs
  - crates/boternity-infra/src/mcp/sampling.rs
  - crates/boternity-infra/src/mcp/mod.rs
autonomous: true

must_haves:
  truths:
    - "Bot can connect to external MCP servers via stdio and Streamable HTTP transports"
    - "Tools are auto-discovered and sanitized on connect"
    - "Multiple MCP servers per bot simultaneously with tools from all available together"
    - "Hot disconnect removes server without affecting others"
    - "Sampling requests from servers are routed through bot's LLM with budget enforcement"
  artifacts:
    - path: "crates/boternity-infra/src/mcp/client_manager.rs"
      provides: "RmcpClientManager implementing McpClientManager"
      min_lines: 150
      contains: "RmcpClientManager"
    - path: "crates/boternity-infra/src/mcp/transport.rs"
      provides: "Transport factory for stdio/HTTP/SSE"
      contains: "connect_stdio"
    - path: "crates/boternity-infra/src/mcp/sampling.rs"
      provides: "Sampling handler for server-to-client LLM requests"
      contains: "sampling_budget"
  key_links:
    - from: "crates/boternity-infra/src/mcp/client_manager.rs"
      to: "rmcp"
      via: "ServiceExt::serve"
      pattern: "serve"
    - from: "crates/boternity-infra/src/mcp/client_manager.rs"
      to: "crates/boternity-core/src/mcp/sanitizer.rs"
      via: "ToolSanitizer::sanitize_description"
      pattern: "sanitize_description"
---

<objective>
Implement MCP client connection pool with transport factory, tool discovery, sanitization, and sampling handler.

Purpose: This is the core of MCP tool consumption (MCPI-01). Bots connect to external MCP servers, discover tools/resources/prompts, sanitize descriptions, and can call tools during conversation. The sampling handler (per locked decision) routes server-initiated LLM requests through the bot's provider with budget enforcement.
Output: RmcpClientManager that wraps rmcp client sessions, transport factory for all three transport types, and sampling budget handler.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-mcp-integration/09-RESEARCH.md
@crates/boternity-types/src/mcp.rs
@crates/boternity-core/src/mcp/client.rs
@crates/boternity-core/src/mcp/sanitizer.rs
@crates/boternity-infra/src/mcp/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Transport factory</name>
  <files>crates/boternity-infra/src/mcp/transport.rs, crates/boternity-infra/src/mcp/mod.rs</files>
  <action>
Create `transport.rs` that provides factory functions for creating rmcp transports from McpServerConfig.

Add `pub mod transport;` to mcp/mod.rs.

**connect_stdio:**
```rust
pub async fn connect_stdio(
    command: &str,
    args: &[String],
) -> Result<rmcp::service::RunningService<rmcp::RoleClient, impl rmcp::service::Service>, rmcp::Error>
```
Uses `rmcp::transport::TokioChildProcess::new(tokio::process::Command::new(command).args(args))`.
Then `().serve(transport).await`.

**connect_http:**
```rust
pub async fn connect_http(
    url: &str,
    bearer_token: Option<&str>,
) -> Result<RunningService<...>, rmcp::Error>
```
Uses `rmcp::transport::streamable_http_client::StreamableHttpClientTransport::new(url.parse()?)`.
If bearer_token provided, add `Authorization: Bearer {token}` header.

**connect_from_config:**
```rust
pub async fn connect_from_config(
    config: &McpServerConfig,
    credential: Option<&str>,
) -> Result<RunningService<...>, anyhow::Error>
```
Matches on `config.transport` to dispatch to connect_stdio or connect_http. For SSE, attempt Streamable HTTP with fallback (rmcp handles SSE compatibility in Streamable HTTP transport per research).

Note: rmcp's RunningService type includes type parameters that may make trait-object storage challenging. Use `Box<dyn Any + Send + Sync>` for type-erased storage if needed, or store the RunningService directly with concrete types in an enum wrapper.

If rmcp 0.15 API differs from research examples (compile errors), adapt to the actual API on docs.rs. The patterns are close but may need adjustment for exact type names.
  </action>
  <verify>`cargo check -p boternity-infra` compiles the transport module</verify>
  <done>Transport factory creates rmcp sessions from stdio and HTTP configs</done>
</task>

<task type="auto">
  <name>Task 2: Client manager and sampling handler</name>
  <files>crates/boternity-infra/src/mcp/client_manager.rs, crates/boternity-infra/src/mcp/sampling.rs, crates/boternity-infra/src/mcp/mod.rs</files>
  <action>
**client_manager.rs -- RmcpClientManager:**

Struct with:
- `connections: Arc<RwLock<HashMap<String, McpClientConnection>>>` -- active connections keyed by server name
- `sanitizer: Arc<DefaultToolSanitizer>` -- from core
- `audit_logger: Arc<dyn McpAuditLogger>` -- for logging tool calls
- `mcp_repo: Arc<SqliteMcpRepository>` -- for persisting connection metadata

Where `McpClientConnection` is an internal struct holding:
- The rmcp RunningService (type-erased or enum-wrapped)
- `tools: Vec<McpToolInfo>` (sanitized)
- `resources: Vec<serde_json::Value>`
- `prompts: Vec<serde_json::Value>`
- `status: McpConnectionStatus`
- `config: McpServerConfig`

Implement McpClientManager trait:

**connect:**
1. Load credential from keystore if config.credential_key is set
2. Call `connect_from_config(config, credential)`
3. Auto-discover: `service.list_tools()`, `service.list_resources()`, `service.list_prompts()`
4. Sanitize all tool descriptions via `self.sanitizer.sanitize_description()`
5. Compute SHA-256 hash of original description for rug-pull detection
6. Store in connections map
7. Persist connection metadata to SQLite via mcp_repo
8. Log audit entry (direction=client, event_type="connect")

**disconnect:**
1. Remove from connections map
2. Graceful shutdown of rmcp service
3. Update SQLite status to Disconnected
4. Log audit entry

**list_tools:**
1. Read connections
2. Filter by bot_id if provided (check config scope)
3. Apply permission filtering via McpToolPermissions::is_allowed
4. Flatten all tools from all connected servers

**call_tool:**
1. Find connection by server_name
2. Call `service.call_tool(CallToolRequestParams { name, arguments, .. })`
3. Sanitize result content before returning (per locked decision)
4. Compute input/output SHA-256 hashes for audit
5. Log audit entry with duration_ms
6. Return result as serde_json::Value

**health_check:**
1. Send ping to service
2. Update last_health_ping in SQLite
3. Return true/false

**sampling.rs -- BotSamplingHandler:**

Struct implementing rmcp ClientHandler:
- `sampling_budget: Arc<AtomicU64>` -- remaining token budget
- Agent engine reference (or provider) for LLM calls

Implement `handle_sampling_create_message`:
1. Check budget: `remaining = budget.load(Relaxed)`
2. Estimate cost from `request.max_tokens.unwrap_or(1000)`
3. If budget exceeded, return McpError
4. Route through LLM provider (non-streaming)
5. Deduct actual usage from budget
6. Return SamplingCreateMessageResult

Note: The exact rmcp ClientHandler API may require adaptation. If rmcp 0.15 uses a different trait shape, adapt to match. The key behavior is: receive sampling request -> check budget -> call LLM -> return result.

Add both modules to mcp/mod.rs.
  </action>
  <verify>`cargo check -p boternity-infra` compiles. All MCP client functionality compiles.</verify>
  <done>RmcpClientManager connects to MCP servers, discovers tools, sanitizes descriptions, calls tools with audit logging, handles sampling with budget enforcement</done>
</task>

</tasks>

<verification>
- `cargo check -p boternity-infra` passes
- Transport factory handles stdio and HTTP transport creation
- Client manager implements full McpClientManager trait
- Tool descriptions are sanitized on discovery
- Sampling handler enforces token budget
</verification>

<success_criteria>
MCP client infrastructure complete: bots can connect to external MCP servers via stdio/HTTP, auto-discover and sanitize tools, call tools with audit logging, and handle sampling requests with budget enforcement.
</success_criteria>

<output>
After completion, create `.planning/phases/09-mcp-integration/09-04-SUMMARY.md`
</output>
