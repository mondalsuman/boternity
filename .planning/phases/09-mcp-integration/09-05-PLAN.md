---
phase: 09-mcp-integration
plan: 05
type: execute
wave: 3
depends_on: ["09-01", "09-02", "09-03"]
files_modified:
  - crates/boternity-infra/src/mcp/server_handler.rs
  - crates/boternity-infra/src/mcp/tool_registry.rs
  - crates/boternity-infra/src/mcp/mod.rs
autonomous: true

must_haves:
  truths:
    - "BoternityMcpServer implements rmcp ServerHandler with tools for bot interaction"
    - "Tools are namespaced by bot slug (e.g., chat__research-bot)"
    - "Tool annotations (readOnlyHint, destructiveHint) applied to all tools"
    - "Single MCP server process exposes all bots"
  artifacts:
    - path: "crates/boternity-infra/src/mcp/server_handler.rs"
      provides: "BoternityMcpServer implementing rmcp ServerHandler"
      min_lines: 150
      contains: "ServerHandler"
    - path: "crates/boternity-infra/src/mcp/tool_registry.rs"
      provides: "Dynamic tool builder from bot capabilities"
      contains: "build_tools"
  key_links:
    - from: "crates/boternity-infra/src/mcp/server_handler.rs"
      to: "rmcp"
      via: "impl ServerHandler"
      pattern: "ServerHandler"
    - from: "crates/boternity-infra/src/mcp/server_handler.rs"
      to: "boternity-core"
      via: "bot service calls"
      pattern: "bot_service"
---

<objective>
Implement the MCP server handler that exposes bots as MCP tools, plus the dynamic tool registry that builds tool definitions from bot capabilities.

Purpose: This is the core of bot-as-MCP-server (MCPI-02). External tools like Claude Code can discover and invoke bots through the MCP protocol. The server exposes chat, bot listing, memory access, skill invocation, and workflow triggering as fine-grained MCP tools (per locked decision: "everything via tool calls").
Output: BoternityMcpServer handler and tool registry that dynamically generates tool definitions.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-mcp-integration/09-RESEARCH.md
@crates/boternity-types/src/mcp.rs
@crates/boternity-core/src/mcp/server.rs
@crates/boternity-infra/src/mcp/mod.rs
@crates/boternity-api/src/state.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Tool registry for dynamic tool generation</name>
  <files>crates/boternity-infra/src/mcp/tool_registry.rs, crates/boternity-infra/src/mcp/mod.rs</files>
  <action>
Create `tool_registry.rs` that builds rmcp tool definitions dynamically based on registered bots.

Add `pub mod tool_registry;` to mcp/mod.rs.

The tool registry builds tool definitions that the server handler dispatches. Since bots are dynamic (created/deleted at runtime), tools must be generated on-demand rather than statically defined with macros.

**Core tools (always available regardless of bots):**
- `list_bots` -- List all available bots with descriptions (readOnlyHint=true, destructiveHint=false)
- `get_bot` -- Get details of a specific bot by slug (readOnlyHint=true)

**Per-bot tools (generated for each registered bot, namespaced by slug):**
- `chat__{slug}` -- Chat with this bot. Input: { message: String, session_id?: String }. (readOnlyHint=false, destructiveHint=false, idempotentHint=false)
- `create_bot` -- Create a new bot. Input: { name, description?, category? }. (destructiveHint=false)
- `delete_bot` -- Delete a bot. Input: { slug }. (destructiveHint=true)
- `get_memories__{slug}` -- Get recent memories for a bot. Input: { limit?: i32 }. (readOnlyHint=true)
- `add_memory__{slug}` -- Add a memory to a bot. Input: { fact: String, category?: String }. (destructiveHint=false)
- `list_skills__{slug}` -- List installed skills for a bot. (readOnlyHint=true)
- `trigger_workflow` -- Trigger a workflow by name. Input: { name: String, input?: Value }. (destructiveHint=false)

**Implementation:**
```rust
pub struct McpToolRegistry {
    /// Cached tool definitions, refreshed when bots change.
    tools: Arc<RwLock<Vec<rmcp::model::Tool>>>,
}
```

Key methods:
- `build_tools(bots: &[Bot]) -> Vec<rmcp::model::Tool>` -- generates all tool definitions from bot list
- `refresh(&self, bots: &[Bot])` -- rebuilds and caches tools
- `get_tools(&self) -> Vec<rmcp::model::Tool>` -- returns cached tools

For each tool definition, construct `rmcp::model::Tool` with:
- `name`: tool name
- `description`: human-readable description
- `input_schema`: JSON Schema from schemars or manually constructed
- `annotations`: ToolAnnotations with readOnlyHint, destructiveHint, idempotentHint, openWorldHint

Use `schemars::schema_for!` where possible for input schemas, or manually build JSON Schema objects for simple inputs.
  </action>
  <verify>`cargo check -p boternity-infra` compiles the tool registry</verify>
  <done>Tool registry generates dynamic MCP tool definitions with annotations for all bot capabilities</done>
</task>

<task type="auto">
  <name>Task 2: MCP server handler (ServerHandler impl)</name>
  <files>crates/boternity-infra/src/mcp/server_handler.rs, crates/boternity-infra/src/mcp/mod.rs</files>
  <action>
Create `server_handler.rs` implementing rmcp's `ServerHandler` trait for BoternityMcpServer.

Add `pub mod server_handler;` to mcp/mod.rs.

**BoternityMcpServer struct:**
```rust
#[derive(Clone)]
pub struct BoternityMcpServer {
    pub db_pool: DatabasePool,
    pub data_dir: PathBuf,
    pub tool_registry: Arc<McpToolRegistry>,
    pub audit_logger: Arc<dyn McpAuditLogger>,
    // Additional service references as needed for tool dispatch
}
```

**ServerHandler implementation:**

`get_info()`:
```rust
ServerInfo {
    protocol_version: ProtocolVersion::V_2025_11_25,
    capabilities: ServerCapabilities::builder()
        .enable_tools()
        .enable_prompts()
        .build(),
    server_info: Implementation {
        name: "boternity".to_string(),
        version: env!("CARGO_PKG_VERSION").to_string(),
        ..Default::default()
    },
    instructions: Some(
        "Boternity MCP server. Interact with AI bots: chat, manage, invoke skills, and trigger workflows.".to_string(),
    ),
}
```

`list_tools()`:
- Return tools from tool_registry.get_tools()

`call_tool()`:
- Parse tool name to determine dispatch target
- For `list_bots`: query bot repository, return JSON
- For `get_bot`: query by slug, return JSON
- For `chat__{slug}`: extract slug, send message through agent engine, return response
- For `create_bot`/`delete_bot`: delegate to bot service
- For `get_memories__{slug}`: query memory store
- For `add_memory__{slug}`: add via memory service
- For `list_skills__{slug}`: query skill store
- For `trigger_workflow`: find and execute workflow
- Log audit entry for each tool call (direction=server)
- Return `CallToolResult::success(vec![Content::text(...)])` or `CallToolResult::error(...)` on failure

Note: rmcp 0.15 may use `#[tool_handler]` macro to implement ServerHandler. If the macro approach works, use it. If not (because tools are dynamic, not static), implement `ServerHandler` manually by overriding `list_tools` and `call_tool` methods directly. The research shows both approaches.

For dynamic tools (bot-namespaced), manual dispatch is likely needed since macros define static tool sets.

Handle errors gracefully: tool call failures return McpError with descriptive message, not panics.
  </action>
  <verify>`cargo check -p boternity-infra` compiles the server handler</verify>
  <done>BoternityMcpServer implements ServerHandler, dispatches tool calls to bot services, logs audit entries</done>
</task>

</tasks>

<verification>
- `cargo check -p boternity-infra` passes
- BoternityMcpServer advertises tools + prompts capabilities
- Tool registry generates per-bot namespaced tools
- Tool call dispatch routes to correct bot service
</verification>

<success_criteria>
MCP server handler exposes all bots as fine-grained MCP tools with proper annotations. Tool calls are dispatched to bot services (chat, CRUD, memory, skills, workflows) and audit-logged. Tool definitions are dynamic and refresh when bots change.
</success_criteria>

<output>
After completion, create `.planning/phases/09-mcp-integration/09-05-SUMMARY.md`
</output>
