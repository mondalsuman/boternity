---
phase: 09-mcp-integration
plan: 06
type: execute
wave: 4
depends_on: ["09-04", "09-05"]
files_modified:
  - crates/boternity-infra/src/mcp/server_transport.rs
  - crates/boternity-infra/src/mcp/auth.rs
  - crates/boternity-infra/src/mcp/rate_limiter.rs
  - crates/boternity-infra/src/mcp/mod.rs
autonomous: true

must_haves:
  truths:
    - "MCP server can be started on Streamable HTTP transport via axum"
    - "MCP server can be started on stdio for CLI integration (e.g., Claude Code)"
    - "Bearer token authentication rejects unauthenticated connections"
    - "Rate limiter enforces per-client and global request limits"
  artifacts:
    - path: "crates/boternity-infra/src/mcp/server_transport.rs"
      provides: "HTTP and stdio server transport setup"
      contains: "StreamableHttpService"
    - path: "crates/boternity-infra/src/mcp/auth.rs"
      provides: "Bearer token authentication middleware"
      contains: "mcp_auth_middleware"
    - path: "crates/boternity-infra/src/mcp/rate_limiter.rs"
      provides: "Governor-backed rate limiter"
      contains: "GovernorRateLimiter"
  key_links:
    - from: "crates/boternity-infra/src/mcp/server_transport.rs"
      to: "crates/boternity-infra/src/mcp/server_handler.rs"
      via: "BoternityMcpServer factory"
      pattern: "BoternityMcpServer"
    - from: "crates/boternity-infra/src/mcp/auth.rs"
      to: "crates/boternity-infra/src/mcp/server_transport.rs"
      via: "axum middleware layer"
      pattern: "middleware"
---

<objective>
Implement MCP server transport (Streamable HTTP + stdio), bearer token authentication, and governor-backed rate limiting.

Purpose: The server transport layer makes the BoternityMcpServer accessible over network (Streamable HTTP with axum) and locally (stdio for Claude Code). Authentication (per locked decision: "reject unauthenticated entirely") and rate limiting (per locked decision: "configurable per-client and global") protect the server from unauthorized and abusive access.
Output: Server transport factory, auth middleware, and rate limiter.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-mcp-integration/09-RESEARCH.md
@crates/boternity-infra/src/mcp/server_handler.rs
@crates/boternity-infra/src/mcp/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Server transports (HTTP + stdio)</name>
  <files>crates/boternity-infra/src/mcp/server_transport.rs, crates/boternity-infra/src/mcp/mod.rs</files>
  <action>
Create `server_transport.rs` with functions to start the MCP server on both transports.

Add `pub mod server_transport;` to mcp/mod.rs.

**Streamable HTTP server (primary):**
```rust
pub async fn start_mcp_http_server(
    server_factory: impl Fn() -> Result<BoternityMcpServer, anyhow::Error> + Clone + Send + 'static,
    bind_addr: &str,
    auth_tokens: Vec<String>,  // Valid bearer tokens
    rate_limiter: Arc<GovernorRateLimiter>,
) -> Result<(), anyhow::Error>
```

Implementation:
1. Create `StreamableHttpService::new(factory_closure, LocalSessionManager::default().into(), Default::default())`
2. Build axum Router:
   - `Router::new().nest_service("/mcp", service)`
   - Add auth middleware layer (from auth.rs)
   - Add rate limiting middleware (from rate_limiter.rs)
3. Bind to `127.0.0.1:{port}` per security best practice (per pitfall 6: DNS rebinding)
4. `axum::serve(listener, router).with_graceful_shutdown(ctrl_c_signal).await`

**Stdio server (for Claude Code integration):**
```rust
pub async fn start_mcp_stdio_server(
    server: BoternityMcpServer,
) -> Result<(), anyhow::Error>
```

Implementation:
1. Use rmcp's stdio transport (`rmcp::transport::io::stdio()` or equivalent)
2. `server.serve(transport).await`
3. No auth needed for stdio (process-level access control)
4. No rate limiting for stdio (single client)

Both functions block until shutdown. The caller (CLI serve command) picks which transport.

Add Origin header validation for HTTP transport (per pitfall 6):
- Accept requests from localhost origins only by default
- Configurable allowed_origins parameter
  </action>
  <verify>`cargo check -p boternity-infra` compiles the transport module</verify>
  <done>MCP server can start on Streamable HTTP (with axum) and stdio transports</done>
</task>

<task type="auto">
  <name>Task 2: Authentication middleware and rate limiter</name>
  <files>crates/boternity-infra/src/mcp/auth.rs, crates/boternity-infra/src/mcp/rate_limiter.rs, crates/boternity-infra/src/mcp/mod.rs</files>
  <action>
**auth.rs -- Bearer token authentication middleware:**

Add `pub mod auth;` to mcp/mod.rs.

```rust
pub async fn mcp_auth_middleware(
    State(tokens): State<Arc<Vec<String>>>,
    req: axum::extract::Request,
    next: axum::middleware::Next,
) -> Result<axum::response::Response, axum::http::StatusCode>
```

Implementation:
1. Extract `Authorization` header
2. Parse `Bearer {token}` format
3. Constant-time compare against valid tokens (use same XOR pattern from 08-07 webhook auth)
4. Reject with 401 Unauthorized if no match
5. Reject with 401 if no Authorization header at all (per locked decision: "zero anonymous access")

Add helper:
```rust
pub fn constant_time_eq(a: &[u8], b: &[u8]) -> bool
```

Add token management helpers:
- `generate_mcp_token() -> String` -- generates a random 32-byte hex token
- Token stored in `~/.boternity/mcp-server-tokens.json`

**rate_limiter.rs -- Governor-backed rate limiter implementing McpRateLimiter:**

Add `pub mod rate_limiter;` to mcp/mod.rs.

```rust
pub struct GovernorRateLimiter {
    per_client: Arc<RateLimiter<String, DefaultKeyedStateStore<String>, DefaultClock>>,
    global: Arc<RateLimiter<NotKeyed, InMemoryState, DefaultClock>>,
}
```

Implementation using `governor` crate:
- `new(per_client_rps: u32, global_rps: u32)` -- create with configurable rates per second
- Default: per_client_rps=10, global_rps=100
- `check_client(client_id: &str) -> Result<(), Duration>` -- checks per-client + global
- `check_global() -> Result<(), Duration>` -- checks global only

Implement McpRateLimiter trait from core.

Also create an axum middleware function:
```rust
pub async fn mcp_rate_limit_middleware(
    State(limiter): State<Arc<GovernorRateLimiter>>,
    req: axum::extract::Request,
    next: axum::middleware::Next,
) -> Result<axum::response::Response, axum::http::StatusCode>
```

Extract client_id from auth token (or IP address). Check rate limit. Return 429 Too Many Requests with Retry-After header if exceeded.
  </action>
  <verify>`cargo check -p boternity-infra` compiles auth and rate limiter modules</verify>
  <done>Bearer token auth rejects unauthenticated requests, rate limiter enforces per-client and global limits via governor</done>
</task>

</tasks>

<verification>
- `cargo check -p boternity-infra` passes
- Auth middleware validates bearer tokens with constant-time comparison
- Rate limiter uses governor for per-client and global limits
- HTTP server binds to 127.0.0.1 only
- Stdio server works without auth (process-level access)
</verification>

<success_criteria>
MCP server transport layer complete: Streamable HTTP via axum with authentication middleware (zero anonymous access), governor-backed rate limiting (per-client + global), and stdio for local CLI integration. Origin header validated, DNS rebinding mitigated.
</success_criteria>

<output>
After completion, create `.planning/phases/09-mcp-integration/09-06-SUMMARY.md`
</output>
