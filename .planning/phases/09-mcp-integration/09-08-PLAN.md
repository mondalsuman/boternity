---
phase: 09-mcp-integration
plan: 08
type: execute
wave: 4
depends_on: ["09-05"]
files_modified:
  - crates/boternity-infra/src/mcp/prompt_registry.rs
  - crates/boternity-infra/src/mcp/mod.rs
autonomous: true

must_haves:
  truths:
    - "Bot skills are exposed as MCP prompt templates"
    - "Common use cases are surfaced as MCP prompts"
    - "MCP clients can list and get prompt details"
  artifacts:
    - path: "crates/boternity-infra/src/mcp/prompt_registry.rs"
      provides: "MCP prompt definitions from bot skills and use cases"
      min_lines: 80
      contains: "build_prompts"
  key_links:
    - from: "crates/boternity-infra/src/mcp/prompt_registry.rs"
      to: "crates/boternity-infra/src/mcp/server_handler.rs"
      via: "list_prompts integration"
      pattern: "list_prompts"
---

<objective>
Implement MCP prompt registry that exposes bot skills and common use cases as MCP prompt templates.

Purpose: Per locked decision, "bot's skills and common use cases surfaced as MCP prompt templates." MCP prompts are templated messages that clients can discover and use to interact with bots in standardized ways. This makes bots more discoverable and easier to use from external MCP clients.
Output: Prompt registry that generates MCP prompt definitions from bot skills.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-mcp-integration/09-RESEARCH.md
@crates/boternity-types/src/skill.rs
@crates/boternity-infra/src/mcp/server_handler.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: MCP prompt registry</name>
  <files>crates/boternity-infra/src/mcp/prompt_registry.rs, crates/boternity-infra/src/mcp/mod.rs</files>
  <action>
Create `prompt_registry.rs` and add `pub mod prompt_registry;` to mcp/mod.rs.

**McpPromptRegistry:**
```rust
pub struct McpPromptRegistry {
    prompts: Arc<RwLock<Vec<rmcp::model::Prompt>>>,
}
```

**build_prompts(bots: &[Bot], skills_per_bot: &HashMap<String, Vec<InstalledSkill>>) -> Vec<rmcp::model::Prompt>:**

Generate prompt definitions from:

1. **Common use case prompts (always available):**
   - `chat_with_bot` -- "Start a conversation with a bot"
     - Arguments: `bot_slug` (required, string), `topic` (optional, string)
     - Messages: user message constructed from topic
   - `create_new_bot` -- "Create a new bot with guided setup"
     - Arguments: `name` (required), `description` (optional), `category` (optional)
   - `list_all_bots` -- "See all available bots and their descriptions"
     - No arguments

2. **Per-bot skill prompts (dynamic):**
   For each bot with installed skills, generate a prompt per skill:
   - Name: `use_skill__{bot_slug}__{skill_name}`
   - Description: skill description from SKILL.md manifest
   - Arguments: derived from skill parameters if defined

3. **Per-bot identity prompts:**
   - `about__{bot_slug}` -- "Learn about this bot's personality and capabilities"
     - No arguments
     - Returns the bot's description and key soul traits

Methods:
- `refresh(&self, bots: &[Bot], skills_per_bot: &HashMap<String, Vec<InstalledSkill>>)`
- `get_prompts(&self) -> Vec<rmcp::model::Prompt>`
- `get_prompt_messages(name: &str, arguments: HashMap<String, String>) -> Result<Vec<rmcp::model::PromptMessage>>`

Wire into BoternityMcpServer's ServerHandler implementation:
- `list_prompts()` returns prompts from registry
- `get_prompt()` calls `get_prompt_messages()` and returns the constructed messages

Note: If rmcp's Prompt type API differs from research expectations (the research noted this as an open question), adapt to the actual API. Start simple with common use case prompts and extend to per-bot skill prompts.
  </action>
  <verify>`cargo check -p boternity-infra` compiles prompt registry</verify>
  <done>MCP prompts generated from bot skills and common use cases, wired into server handler</done>
</task>

<task type="auto">
  <name>Task 2: Wire prompts into ServerHandler</name>
  <files>crates/boternity-infra/src/mcp/server_handler.rs</files>
  <action>
Update BoternityMcpServer to include prompt_registry field and implement prompt-related ServerHandler methods.

Add to struct:
```rust
pub prompt_registry: Arc<McpPromptRegistry>,
```

Add ServerHandler method implementations for prompts:
- `list_prompts()` -- return all prompts from registry
- `get_prompt()` -- look up prompt by name, resolve arguments, return messages

Update `get_info()` to ensure capabilities include prompts (already should from Plan 05 but verify).

If rmcp's ServerHandler trait does not have separate `list_prompts`/`get_prompt` methods (they may be handled through a different mechanism like `#[prompt_handler]`), adapt to the actual API pattern.
  </action>
  <verify>`cargo check -p boternity-infra` compiles with prompt support in server handler</verify>
  <done>ServerHandler returns prompt templates for bot skills and common use cases</done>
</task>

</tasks>

<verification>
- `cargo check -p boternity-infra` passes
- Prompt registry generates common use case prompts
- Per-bot skill prompts generated for bots with skills
- Server handler lists and resolves prompts
</verification>

<success_criteria>
MCP prompts expose bot skills and common use cases as discoverable templates. External MCP clients can list available prompts and get pre-constructed message sequences for common interactions.
</success_criteria>

<output>
After completion, create `.planning/phases/09-mcp-integration/09-08-SUMMARY.md`
</output>
