---
phase: 09-mcp-integration
plan: 10
type: execute
wave: 5
depends_on: ["09-04", "09-06"]
files_modified:
  - crates/boternity-api/src/http/handlers/mcp.rs
  - crates/boternity-api/src/http/handlers/mod.rs
  - crates/boternity-api/src/http/router.rs
autonomous: true

must_haves:
  truths:
    - "REST API provides endpoints for MCP server management"
    - "Web UI can query MCP connection status, available tools, and audit log"
    - "API supports hot connect/disconnect of MCP servers"
  artifacts:
    - path: "crates/boternity-api/src/http/handlers/mcp.rs"
      provides: "REST API MCP handlers"
      min_lines: 150
      contains: "list_mcp_servers"
    - path: "crates/boternity-api/src/http/router.rs"
      provides: "MCP routes wired into router"
      contains: "/mcp"
  key_links:
    - from: "crates/boternity-api/src/http/handlers/mcp.rs"
      to: "crates/boternity-infra/src/mcp/config_store.rs"
      via: "config store calls"
      pattern: "config_store"
    - from: "crates/boternity-api/src/http/router.rs"
      to: "crates/boternity-api/src/http/handlers/mcp.rs"
      via: "route registration"
      pattern: "handlers::mcp"
---

<objective>
Implement REST API handlers for MCP management and wire them into the HTTP router.

Purpose: The web UI needs REST endpoints to display the MCP tab (per locked decision: "dedicated MCP tab per bot showing connected servers, available tools, connection status"). These endpoints mirror the CLI functionality and enable the web UI to manage MCP servers, browse tool inventories, and view audit logs.
Output: REST handlers for MCP CRUD, status, tools, and audit; routes wired into the existing axum router.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-mcp-integration/09-RESEARCH.md
@crates/boternity-api/src/http/handlers/mod.rs
@crates/boternity-api/src/http/router.rs
@crates/boternity-api/src/state.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: MCP REST API handlers</name>
  <files>crates/boternity-api/src/http/handlers/mcp.rs, crates/boternity-api/src/http/handlers/mod.rs</files>
  <action>
Create `crates/boternity-api/src/http/handlers/mcp.rs` and add `pub mod mcp;` to handlers/mod.rs.

**Endpoints:**

1. `GET /api/v1/mcp/servers` -- List all configured MCP servers
   - Query params: `?bot={slug}` for bot-specific view
   - Returns: `{ servers: McpServerConfig[], bot_overrides: McpBotOverride? }`

2. `POST /api/v1/mcp/servers` -- Add a new MCP server config
   - Body: `McpServerConfig`
   - Returns: 201 with config

3. `DELETE /api/v1/mcp/servers/{name}` -- Remove a server config
   - Returns: 204

4. `GET /api/v1/mcp/connections` -- List active connections with status
   - Query params: `?bot_id={uuid}`
   - Returns: `{ connections: McpConnection[] }`

5. `POST /api/v1/mcp/connections/{name}/connect` -- Connect to a configured server
   - Returns: `{ tools: i32, resources: i32, prompts: i32 }`

6. `POST /api/v1/mcp/connections/{name}/disconnect` -- Disconnect from a server
   - Returns: 204

7. `GET /api/v1/mcp/tools` -- List all available tools across connected servers
   - Query params: `?bot_id={uuid}`
   - Returns: `{ tools: McpToolInfo[] }`

8. `POST /api/v1/mcp/tools/{server}/{tool}` -- Call a tool (for test-tool UI equivalent)
   - Body: `{ arguments: Value }`
   - Returns: `{ result: Value, duration_ms: i64 }`

9. `GET /api/v1/mcp/audit` -- Query audit log
   - Query params: `?server={name}&bot_id={uuid}&direction={client|server}&limit={n}`
   - Returns: `{ entries: McpAuditEntry[] }`

10. `GET /api/v1/mcp/presets` -- List available server presets
    - Returns: `{ presets: McpServerPreset[] }`

11. `PUT /api/v1/bots/{id}/mcp/overrides` -- Set bot-specific MCP overrides
    - Body: `McpBotOverride`
    - Returns: 200

12. `GET /api/v1/bots/{id}/mcp/overrides` -- Get bot-specific MCP overrides
    - Returns: `McpBotOverride`

All handlers use the existing pattern:
- Extract `State(state): State<AppState>`
- Use `ApiResponse` envelope from existing response module
- Return proper HTTP status codes
- Log errors with tracing

Use `mcp_routes() -> Router<AppState>` pattern (like workflow_routes) for clean route organization.
  </action>
  <verify>`cargo check -p boternity-api` compiles all MCP handlers</verify>
  <done>12 REST API endpoints for MCP management, tool browsing, and audit log querying</done>
</task>

<task type="auto">
  <name>Task 2: Wire MCP routes into router</name>
  <files>crates/boternity-api/src/http/router.rs</files>
  <action>
Wire MCP API routes into the existing router.

Add to `build_router` function's api_routes:
```rust
// MCP management (Phase 9)
.merge(handlers::mcp::mcp_routes())
```

Place after the Phase 8 workflow routes merge, before the webhook receiver route.

Also add bot-scoped MCP routes:
```rust
.route("/bots/{id}/mcp/overrides",
    get(handlers::mcp::get_bot_mcp_overrides)
        .put(handlers::mcp::set_bot_mcp_overrides))
```

The `mcp_routes()` function in handlers/mcp.rs should define:
```rust
pub fn mcp_routes() -> Router<AppState> {
    Router::new()
        .route("/mcp/servers", get(list_mcp_servers).post(add_mcp_server))
        .route("/mcp/servers/{name}", delete(remove_mcp_server))
        .route("/mcp/connections", get(list_mcp_connections))
        .route("/mcp/connections/{name}/connect", post(connect_mcp_server))
        .route("/mcp/connections/{name}/disconnect", post(disconnect_mcp_server))
        .route("/mcp/tools", get(list_mcp_tools))
        .route("/mcp/tools/{server}/{tool}", post(call_mcp_tool))
        .route("/mcp/audit", get(query_mcp_audit))
        .route("/mcp/presets", get(list_mcp_presets))
}
```
  </action>
  <verify>`cargo check -p boternity-api` compiles with MCP routes wired</verify>
  <done>MCP routes accessible under /api/v1/mcp/* and /api/v1/bots/{id}/mcp/*</done>
</task>

</tasks>

<verification>
- `cargo check -p boternity-api` passes
- All MCP endpoints are reachable under /api/v1/mcp/
- Bot-scoped MCP overrides under /api/v1/bots/{id}/mcp/
- Handlers follow existing envelope response pattern
</verification>

<success_criteria>
REST API provides complete MCP management surface: server CRUD, connection lifecycle, tool browsing and testing, audit log querying, and preset discovery. All endpoints follow existing API patterns and are wired into the router.
</success_criteria>

<output>
After completion, create `.planning/phases/09-mcp-integration/09-10-SUMMARY.md`
</output>
