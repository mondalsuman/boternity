---
phase: 09-mcp-integration
plan: 13
type: execute
wave: 6
depends_on: ["09-09", "09-10", "09-11"]
files_modified:
  - apps/web/src/components/chat/tool-call-block.tsx
  - apps/web/src/components/chat/message-display.tsx
  - crates/boternity-api/src/cli/chat/mod.rs
autonomous: true

must_haves:
  truths:
    - "MCP tool calls render as collapsible blocks in web UI chat"
    - "Tool call blocks show syntax-highlighted JSON input/output"
    - "CLI chat renders tool calls with formatted output"
    - "Collapsible blocks match the style of Claude Code tool use display"
  artifacts:
    - path: "apps/web/src/components/chat/tool-call-block.tsx"
      provides: "Collapsible tool call block component"
      min_lines: 50
      contains: "ToolCallBlock"
  key_links:
    - from: "apps/web/src/components/chat/tool-call-block.tsx"
      to: "apps/web/src/components/chat/message-display.tsx"
      via: "rendered within message list"
      pattern: "ToolCallBlock"
---

<objective>
Implement inline collapsible tool call blocks in both web UI and CLI chat for MCP tool use visualization.

Purpose: Per locked decision, "inline collapsible tool call blocks in chat (both CLI and web UI), with syntax highlighting for JSON input/output." This provides visibility into what MCP tools the bot is using during conversation, similar to how Claude Code displays tool use.
Output: ToolCallBlock component for web UI, formatted tool call rendering in CLI.
</objective>

<execution_context>
@/Users/smxaz7/.claude/get-shit-done/workflows/execute-plan.md
@/Users/smxaz7/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-mcp-integration/09-RESEARCH.md
@apps/web/src/components/chat/message-display.tsx
@crates/boternity-api/src/cli/chat/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Web UI collapsible tool call blocks</name>
  <files>apps/web/src/components/chat/tool-call-block.tsx, apps/web/src/components/chat/message-display.tsx</files>
  <action>
**tool-call-block.tsx -- Collapsible tool call block component:**

```tsx
interface ToolCallBlockProps {
  toolName: string;
  serverName: string;
  input: Record<string, unknown>;
  result?: string;
  durationMs?: number;
  isError?: boolean;
  isLoading?: boolean;
}
```

Layout:
- Header bar (always visible): icon + tool name + server name badge + duration + expand/collapse chevron
- Collapsed by default after completion, expanded while loading
- When expanded:
  - "Input" section: JSON with syntax highlighting (use highlight.js `json` language, consistent with existing code blocks from 04-05)
  - "Result" section: JSON or text with syntax highlighting
  - Copy button for each section

Styling:
- Rounded border with subtle background (bg-muted/50 or similar)
- Left accent border color: blue for loading, green for success, red for error
- Server name as small Badge component
- Duration shown as "42ms" in muted text
- Chevron icon rotates on expand/collapse (use Collapsible from shadcn/ui)
- Monospace font for JSON content

States:
- Loading: spinner icon, pulsing border, "Calling {toolName}..." text
- Success: check icon, green accent, result displayed
- Error: X icon, red accent, error message displayed

**message-display.tsx integration:**

In the message rendering logic, detect tool_use/tool_result events from the SSE stream and render ToolCallBlock components inline within the message list. Tool call blocks appear between assistant message chunks:

```
Assistant: "Let me check that file for you."
[ToolCallBlock: read_file (filesystem) - 42ms]
Assistant: "The file contains..."
```

Parse the SSE events:
- `{ type: "tool_use", name, server, input }` -> render loading ToolCallBlock
- `{ type: "tool_result", name, result, duration_ms, error? }` -> update to completed state
  </action>
  <verify>`cd /Users/smxaz7/Desktop/Suman/Projects/gh/boternity/apps/web && npx tsc --noEmit 2>&1 | head -20` -- types compile</verify>
  <done>Collapsible tool call blocks render inline in web UI chat with syntax-highlighted JSON</done>
</task>

<task type="auto">
  <name>Task 2: CLI tool call rendering</name>
  <files>crates/boternity-api/src/cli/chat/mod.rs</files>
  <action>
Enhance the CLI chat renderer to display MCP tool calls as formatted blocks.

When the agent response includes tool use:

```
  Tool: read_file [filesystem]
  Input: {
    "path": "/etc/hostname"
  }
  Result: "my-hostname"
  (42ms)
```

Implementation:
- Use `console` crate for styling:
  - Tool name in bold cyan
  - Server name in dim brackets
  - "Input:" and "Result:" labels in dim
  - JSON pretty-printed with 2-space indent
  - Duration in dim parentheses
  - Horizontal rule (---) before and after tool block to separate from conversation

- For long results (>10 lines), truncate with "[...truncated, {n} lines total]" and show first 5 + last 2 lines
- For error results, show in red: "Error: {message}"

- If `--quiet` flag is set, suppress tool call details entirely (just show the final response, consistent with existing --quiet behavior for sub-agents from 05-07)

This should integrate with the existing tool_use detection added in Plan 11 Task 2. If that plan already added basic rendering, enhance it here to match the specified format.
  </action>
  <verify>`cargo check -p boternity-api` compiles CLI tool call rendering</verify>
  <done>CLI chat renders MCP tool calls as formatted, collapsible blocks with syntax highlighting</done>
</task>

</tasks>

<verification>
- TypeScript compiles without errors for web components
- Rust compiles for CLI rendering
- Tool call blocks show in web UI chat (loading -> completed states)
- CLI tool calls formatted with name, server, input, result, duration
- Long results truncated in CLI
- --quiet suppresses tool call details
</verification>

<success_criteria>
MCP tool use is visually clear in both interfaces: web UI shows collapsible blocks with syntax-highlighted JSON (similar to Claude Code), CLI shows formatted blocks with color coding. Both surfaces convey tool name, server, input, result, and timing.
</success_criteria>

<output>
After completion, create `.planning/phases/09-mcp-integration/09-13-SUMMARY.md`
</output>
