//! Builder domain types for the interactive bot creation system.
//!
//! These types model the data shapes for the builder agent ("Forge"):
//! multi-turn structured conversations, builder state accumulation,
//! question/answer flows, and the final assembled configuration.
//!
//! Types that the LLM produces (BuilderTurn, BuilderPhase, etc.) derive
//! `schemars::JsonSchema` to enable Claude's structured output via
//! `output_config.format`.

use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

// ---------------------------------------------------------------------------
// Builder phases
// ---------------------------------------------------------------------------

/// Phase of the builder wizard flow.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum BuilderPhase {
    Basics,
    Personality,
    Model,
    Skills,
    Review,
}

// ---------------------------------------------------------------------------
// Purpose categorization
// ---------------------------------------------------------------------------

/// High-level purpose category for a bot, used to drive smart defaults
/// and adaptive question depth.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum PurposeCategory {
    SimpleUtility,
    ComplexAnalyst,
    Creative,
    Coding,
    Research,
    CustomerService,
    Custom(String),
}

// ---------------------------------------------------------------------------
// LLM output types (derive JsonSchema for structured output)
// ---------------------------------------------------------------------------

/// A single turn produced by the builder LLM.
///
/// Claude is constrained to produce exactly this shape via structured output
/// (`output_config.format` with the JSON schema generated by `schemars`).
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "action", rename_all = "snake_case")]
pub enum BuilderTurn {
    /// LLM asks the next question with multi-choice options.
    AskQuestion {
        phase: BuilderPhase,
        question: String,
        options: Vec<QuestionOption>,
        allow_free_text: bool,
        phase_label: Option<String>,
    },
    /// Show a preview of the current configuration.
    ShowPreview {
        phase: BuilderPhase,
        preview: BuilderPreview,
    },
    /// LLM signals all info gathered, ready to build.
    ReadyToAssemble { config: BuilderConfig },
    /// LLM needs clarification on vague input.
    Clarify { message: String },
}

/// A single option in a builder question.
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct QuestionOption {
    pub id: String,
    pub label: String,
    /// Brief context for the option (e.g., "Formal tone -- best for professional use cases").
    pub description: Option<String>,
}

/// Preview of the bot configuration as it's being assembled.
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct BuilderPreview {
    pub name: Option<String>,
    pub description: Option<String>,
    pub personality_summary: Option<String>,
    pub model: Option<String>,
    pub skills: Vec<String>,
    pub phase: BuilderPhase,
}

/// The fully assembled builder configuration, produced when the LLM
/// signals `ReadyToAssemble`.
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct BuilderConfig {
    pub name: String,
    pub description: String,
    pub category: String,
    pub tags: Vec<String>,
    pub personality: PersonalityConfig,
    pub model_config: ModelConfig,
    pub skills: Vec<SkillRequest>,
}

/// Personality configuration for a bot.
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct PersonalityConfig {
    pub tone: String,
    pub traits: Vec<String>,
    pub purpose: String,
    pub boundaries: Option<String>,
}

/// Model configuration for a bot.
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct ModelConfig {
    pub model: String,
    pub temperature: f64,
    pub max_tokens: u32,
}

/// A skill to be attached to the bot.
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct SkillRequest {
    pub name: String,
    pub description: String,
    /// Either "local" or "wasm".
    pub skill_type: String,
}

// ---------------------------------------------------------------------------
// User input types (no JsonSchema -- these are from the user, not the LLM)
// ---------------------------------------------------------------------------

/// A user's answer to a builder question.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum BuilderAnswer {
    /// Selected option by index.
    OptionIndex(usize),
    /// Free-text via "Other" escape hatch.
    FreeText(String),
    /// Confirmation (yes/no for the final summary).
    Confirm(bool),
    /// Go back to a previous phase.
    Back,
}

// ---------------------------------------------------------------------------
// Builder state (accumulated across the conversation)
// ---------------------------------------------------------------------------

/// The full accumulated state of a builder session.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BuilderState {
    pub session_id: Uuid,
    pub phase: BuilderPhase,
    pub initial_description: String,
    pub purpose_category: Option<PurposeCategory>,
    pub conversation: Vec<BuilderExchange>,
    pub config: PartialBuilderConfig,
    pub phase_history: Vec<BuilderPhase>,
}

/// A single question-answer exchange in the builder conversation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BuilderExchange {
    pub question: String,
    pub answer: String,
    pub phase: BuilderPhase,
}

/// Partially assembled bot configuration -- all fields optional until
/// the builder gathers enough information to fill them.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct PartialBuilderConfig {
    pub name: Option<String>,
    pub description: Option<String>,
    pub category: Option<String>,
    pub tags: Option<Vec<String>>,
    pub tone: Option<String>,
    pub traits: Option<Vec<String>>,
    pub purpose: Option<String>,
    pub boundaries: Option<String>,
    pub model: Option<String>,
    pub temperature: Option<f64>,
    pub max_tokens: Option<u32>,
    #[serde(default)]
    pub skills: Vec<SkillRequest>,
}

// ---------------------------------------------------------------------------
// Schema helpers
// ---------------------------------------------------------------------------

/// Recursively adds `"additionalProperties": false` to every JSON Schema
/// object that has `"properties"`.
///
/// Claude's structured output requires this on all object schemas. The
/// `schemars` crate does not add it by default, so this post-processing
/// step is critical for Claude API compatibility.
pub fn add_additional_properties_false(schema: &mut serde_json::Value) {
    if let Some(obj) = schema.as_object_mut() {
        // If this object has "properties", it represents a JSON Schema object type
        // and needs additionalProperties: false for Claude compatibility.
        if obj.contains_key("properties") {
            obj.insert(
                "additionalProperties".to_string(),
                serde_json::json!(false),
            );
        }

        // Recurse into nested schemas
        for key in [
            "properties",
            "items",
            "anyOf",
            "allOf",
            "oneOf",
            "$defs",
            "definitions",
        ] {
            if let Some(nested) = obj.get_mut(key) {
                if let Some(arr) = nested.as_array_mut() {
                    for item in arr {
                        add_additional_properties_false(item);
                    }
                } else if let Some(obj_nested) = nested.as_object_mut() {
                    for (_, v) in obj_nested {
                        add_additional_properties_false(v);
                    }
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_builder_turn_schema() {
        let schema = schemars::schema_for!(BuilderTurn);
        let json = serde_json::to_string_pretty(&schema).unwrap();
        assert!(json.contains("action"));
        assert!(json.contains("ask_question"));
        assert!(json.contains("ready_to_assemble"));
    }

    #[test]
    fn test_builder_phase_serde_roundtrip() {
        let phase = BuilderPhase::Personality;
        let json = serde_json::to_string(&phase).unwrap();
        assert_eq!(json, "\"personality\"");
        let parsed: BuilderPhase = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed, BuilderPhase::Personality);
    }

    #[test]
    fn test_purpose_category_custom() {
        let cat = PurposeCategory::Custom("game-master".to_string());
        let json = serde_json::to_string(&cat).unwrap();
        assert!(json.contains("custom"));
        assert!(json.contains("game-master"));
        let parsed: PurposeCategory = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed, cat);
    }

    #[test]
    fn test_builder_turn_ask_question_roundtrip() {
        let turn = BuilderTurn::AskQuestion {
            phase: BuilderPhase::Basics,
            question: "What should your bot be called?".to_string(),
            options: vec![QuestionOption {
                id: "1".to_string(),
                label: "CodeHelper".to_string(),
                description: Some("A coding assistant".to_string()),
            }],
            allow_free_text: true,
            phase_label: Some("Setting up basics...".to_string()),
        };
        let json = serde_json::to_string(&turn).unwrap();
        assert!(json.contains("\"action\":\"ask_question\""));
        let parsed: BuilderTurn = serde_json::from_str(&json).unwrap();
        match parsed {
            BuilderTurn::AskQuestion { question, .. } => {
                assert_eq!(question, "What should your bot be called?");
            }
            _ => panic!("expected AskQuestion"),
        }
    }

    #[test]
    fn test_add_additional_properties_false() {
        let mut schema = serde_json::to_value(schemars::schema_for!(BuilderTurn)).unwrap();
        add_additional_properties_false(&mut schema);
        let json = serde_json::to_string_pretty(&schema).unwrap();
        assert!(json.contains("\"additionalProperties\":"));
    }

    #[test]
    fn test_partial_builder_config_defaults() {
        let config = PartialBuilderConfig::default();
        assert!(config.name.is_none());
        assert!(config.skills.is_empty());
    }
}
